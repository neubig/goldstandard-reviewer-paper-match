FlowSeq: Non-Autoregressive Conditional Sequence Generation with Generative Flow
Xuezhe Ma∗,1 Chunting Zhou∗,1 Xian Li2 Graham Neubig1 Eduard Hovy1 1Language Technologies Institute, Carnegie Mellon University 2Facebook AI
{xuezhem, chuntinz, gneubig, ehovy}@cs.cmu.edu xianl@fb.com

arXiv:1909.02480v3 [cs.CL] 9 Oct 2019

Abstract
Most sequence-to-sequence (seq2seq) models are autoregressive; they generate each token by conditioning on previously generated tokens. In contrast, non-autoregressive seq2seq models generate all tokens in one pass, which leads to increased efﬁciency through parallel processing on hardware such as GPUs. However, directly modeling the joint distribution of all tokens simultaneously is challenging, and even with increasingly complex model structures accuracy lags signiﬁcantly behind autoregressive models. In this paper, we propose a simple, efﬁcient, and effective model for non-autoregressive sequence generation using latent variable models. Speciﬁcally, we turn to generative ﬂow, an elegant technique to model complex distributions using neural networks, and design several layers of ﬂow tailored for modeling the conditional density of sequential latent variables. We evaluate this model on three neural machine translation (NMT) benchmark datasets, achieving comparable performance with state-of-the-art nonautoregressive NMT models and almost constant decoding time w.r.t the sequence length.1
1 Introduction
Neural sequence-to-sequence (seq2seq) models (Bahdanau et al., 2015; Rush et al., 2015; Vinyals et al., 2015; Vaswani et al., 2017) generate an output sequence y = {y1, . . . , yT } given an input sequence x = {x1, . . . , xT } using conditional probabilities Pθ(y|x) predicted by neural networks (parameterized by θ).
Most seq2seq models are autoregressive, meaning that they factorize the joint probability of the output sequence given the input sequence Pθ(y|x) into the product of probabilities over the next to-
∗ Equal contribution, in alphabetical order. 1https://github.com/XuezheMax/flowseq

y y
(a)
x
(c)
z y
(b)
x x

Figure 1: (a) Autoregressive (b) non-autoregressive and (c) our proposed sequence generation models. x is the source, y is the target, and z are latent variables.

ken in the sequence given the input sequence and previously generated tokens:

T

Pθ(y|x) = Pθ(yt|y<t, x).

(1)

t=1

Each factor, Pθ(yt|y<t, x), can be implemented by function approximators such as RNNs (Bahdanau et al., 2015) and Transformers (Vaswani et al., 2017). This factorization takes the complicated problem of joint estimation over an exponentially large output space of outputs y, and turns it into a sequence of tractable multi-class classiﬁcation problems predicting yt given the previous words, allowing for simple maximum loglikelihood training. However, this assumption of left-to-right factorization may be sub-optimal from a modeling perspective (Gu et al., 2019; Stern et al., 2019), and generation of outputs must be done through a linear left-to-right pass through the output tokens using beam search, which is not easily parallelizable on hardware such as GPUs.
Recently, there has been work on nonautoregressive sequence generation for neural machine translation (NMT; Gu et al. (2018); Lee et al. (2018); Ghazvininejad et al. (2019)) and language modeling (Ziegler and Rush, 2019). Nonautoregressive models attempt to model the joint distribution Pθ(y|x) directly, decoupling the dependencies of decoding history during generation.

A na¨ıve solution is to assume that each token of the target sequence is independent given the input:

T

Pθ(y|x) = Pθ(yt|x).

(2)

t=1

Unfortunately, the performance of this simple

model falls far behind autoregressive models, as

seq2seq tasks usually do have strong conditional

dependencies between output variables (Gu et al.,

2018). This problem can be mitigated by introduc-

ing a latent variable z to model these conditional

dependencies:

Pθ(y|x) = Pθ(y|z, x)pθ(z|x)dz, (3)
z
where pθ(z|x) is the prior distribution over latent z and Pθ(y|z, x) is the “generative” distribution (a.k.a decoder). Non-autoregressive generation can be achieved by the following independence assumption in the decoding process:

T

Pθ(y|z, x) = Pθ(yt|z, x).

(4)

t=1

Gu et al. (2018) proposed a z representing fertil-

ity scores specifying the number of output words

each input word generates, signiﬁcantly improv-

ing the performance over Eq. (2). But the per-

formance still falls behind state-of-the-art autore-

gressive models due to the limited expressiveness

of fertility to model the interdependence between

words in y.

In this paper, we propose a simple, effective,

and efﬁcient model, FlowSeq, which models ex-

pressive prior distribution pθ(z|x) using a pow-

erful mathematical framework called generative

ﬂow (Rezende and Mohamed, 2015). This frame-

work can elegantly model complex distributions,

and has obtained remarkable success in model-

ing continuous data such as images and speech

through efﬁcient density estimation and sampling

(Kingma and Dhariwal, 2018; Prenger et al., 2019;

Ma and Hovy, 2019). Based on this, we posit

that generative ﬂow also has potential to introduce

more meaningful latent variables z in the non-

autoregressive generation in Eq. (3).

FlowSeq is a ﬂow-based sequence-to-sequence

model, which is (to our knowledge) the ﬁrst

non-autoregressive seq2seq model utilizing gen-

erative ﬂows. It allows for efﬁcient parallel

decoding while modeling the joint distribution

of the output sequence. Experimentally, on

three benchmark datasets for machine translation – WMT2014, WMT2016 and IWSLT-2014, FlowSeq achieves comparable performance with state-of-the-art non-autoregressive models, and almost constant decoding time w.r.t. the sequence length compared to a typical left-to-right Transformer model, which is super-linear.

2 Background

As noted above, incorporating expressive latent variables z is essential to decouple the dependencies between tokens in the target sequence in non-autoregressive models. However, in order to model all of the complexities of sequence generation to the point that we can read off all of the words in the output in an independent fashion (as in Eq. (4)), the prior distribution pθ(z|x) will necessarily be quite complex. In this section, we describe generative ﬂows (Rezende and Mohamed, 2015), an effective method for arbitrary modeling of complicated distributions, before describing how we apply them to sequence-to-sequence generation in §3.

2.1 Flow-based Generative Models
Put simply, ﬂow-based generative models work by transforming a simple distribution (e.g. a simple Gaussian) into a complex one (e.g. the complex prior distribution over z that we want to model) through a chain of invertible transformations.
Formally, a set of latent variables υ ∈ Υ are introduced with a simple prior distribution pΥ(υ). We then deﬁne a bijection function f : Z → Υ (with g = f −1), whereby we can deﬁne a generative process over variables z:

υ ∼ pΥ(υ)

(5)

z = gθ(υ).

An important insight behind ﬂow-based models is

that given this bijection function, the change of

variable formula deﬁnes the model distribution on

z ∈ Z by:

pθ(z) = pΥ(fθ(z)) det( ∂fθ(z) ) . (6) ∂z

Here

∂ fθ (z) ∂z

is

the

Jacobian

matrix

of

fθ

at

z.

Eq. (6) provides a way to calculate the (com-

plex) density of z by calculating the (simple) den-

sity of υ and the Jacobian of the transforma-

tion from z to υ. For efﬁciency purposes, ﬂow-

based models generally use certain types of trans-

formations fθ where both the inverse functions

gθ and the Jacobian determinants are tractable to compute. A stacked sequence of such invertible transformations is also called a (normalizing) ﬂow (Rezende and Mohamed, 2015):

z ←f→1 H1 ←f→2 H2 ←f→3 · · · ←fK→ υ,

g1

g2

g3

gK

where f = f1 ◦ f2 ◦ · · · ◦ fK is a ﬂow of K transformations (omitting θs for brevity).

2.2 Variational Inference and Training
In the context of maximal likelihood estimation (MLE), we wish to minimize the negative loglikelihood of the parameters:

min 1 N − log Pθ(yi|xi), (7) θ∈Θ N
i=1
where D = {(xi, yi)}Ni=1 is the set of training data. However, the likelihood Pθ(y|x) after marginalizing out latent variables z (LHS in Eq. (3)) is intractable to compute or differentiate directly. Variational inference (Wainwright et al., 2008) provides a solution by introducing a parametric inference model qφ(z|y, x) (a.k.a posterior) which is then used to approximate this integral by sampling individual examples of z. These models then optimize the evidence lower bound (ELBO), which considers both the “reconstruction error” log Pθ(y|z, x) and KL-divergence between the posterior and the prior:

log Pθ(y|x) ≥ Eqφ(z|y,x)[log Pθ(y|z, x)] − KL(qφ(z|y, x)||pθ(z|x)). (8)

Both inference model φ and decoder θ parameters are optimized according to this objective.

3 FlowSeq
We ﬁrst overview FlowSeq’s architecture (shown in Figure 2) and training process here before detailing each component in following sections. Similarly to classic seq2seq models, at both training and test time FlowSeq ﬁrst reads the whole input sequence x and calculates a vector for each word in the sequence, the source encoding.
At training time, FlowSeq’s parameters are learned using a variational training paradigm overviewed in §2.2. First, we draw samples of latent codes z from the current posterior qφ(z|y, x). Next, we feed z together with source encodings into the decoder network and the prior ﬂow

to compute the probabilities of Pθ(y|z, x) and pθ(z|x) for optimizing the ELBO (Eq. (8)).
At test time, generation is performed by ﬁrst sampling a latent code z from the prior ﬂow by executing the generative process deﬁned in Eq. (5). In this step, the source encodings produced from the encoder are used as conditional inputs. Then the decoder receives both the sampled latent code z and the source encoder outputs to generate the target sequence y from Pθ(y|z, x).
3.1 Source Encoder
The source encoder encodes the source sequences into hidden representations, which are used in computing attention when generating latent variables in the posterior network and prior network as well as the cross-attention with decoder. Any standard neural sequence model can be used as its encoder, including RNNs (Bahdanau et al., 2015) or Transformers (Vaswani et al., 2017).
3.2 Posterior
Generation of Latent Variables. The latent variables z are represented as a sequence of continuous random vectors z = {z1, . . . , zT } with the same length as the target sequence y. Each zt is a dz-dimensional vector, where dz is the dimension of the latent space. The posterior distribution qφ(z|y, x) models each zt as a diagonal Gaussian with learned mean and variance:
T
qφ(z|y, x) = N (zt|µt(x, y), σt2(x, y)) (9)
t=1
where µt(·) and σt(·) are neural networks such as RNNs or Transformers.
Zero initialization. While we perform standard random initialization for most layers of the network, we initialize the last linear transforms that generate the µ and log σ2 values with zeros. This ensures that the posterior distribution as a simple normal distribution, which we found helps train very deep generative ﬂows more stably.
Token Dropout. The motivation of introducing the latent variable z into the model is to model the uncertainty in the generative process. Thus, it is preferable that z capture contextual interdependence between tokens in y. However, there is an obvious local optimum where the posterior network generates a latent vector zt that only encodes the information about the corresponding target token yt, and the decoder simply generates the

Output Probabilities
+
Target Decoder

forward pass
backward pass
+ multi-head attention

Posterior

1

2

3

4

5

+
Target Encoder

1

2

3

4

5

+

One Step of Flow

×K

Emb1
A

Emb2
dog

Emb3
runs

Emb4
away

Emb5
.

Source Encodings
+
Source Encoder

Split Squeeze One Step of Flow

×(L − 1) ×K

Emb1
ein

Emb2

Emb3

Emb4

hund rannte weg

Emb5
.

1

2

3

4

5

∼  (0; )

Prior Flow

Figure 2: Neural architecture of FlowSeq, including the encoder, the decoder and the posterior networks, together with the multi-scale architecture of the prior ﬂow. The architecture of each ﬂow step is in Figure 3.

“correct” token at each step t with zt as input. In this case, FlowSeq reduces to the baseline model in Eq. (2). To escape this undesired local optimum, we apply token-level dropout to randomly drop an entire token when calculating the posterior, to ensure the model also has to learn how to use contextual information. This technique is similar to the “masked language model” in previous studies (Melamud et al., 2016; Devlin et al., 2018; Ma et al., 2018).
3.3 Decoder
As the decoder, we take the latent sequence z as input, run it through several layers of a neural sequence model such as a Transformer, then directly predict the output tokens in y individually and independently. Notably, unlike standard seq2seq decoders, we do not perform causal masking to prevent attending to future tokens, making the model fully non-autoregressive.
3.4 Flow Architecture for Prior
The ﬂow architecture is based on Glow (Kingma and Dhariwal, 2018). It consists of a series of steps of ﬂow, combined in a multi-scale architecture (see Figure 2.) Each step of ﬂow consists three types of elementary ﬂows – actnorm, invertible multi-head linear, and coupling. Note that all three functions are invertible and conducive to calculation of log determinants (details in Appendix A).

Actnorm. The activation normalization layer (actnorm; Kingma and Dhariwal (2018)) is an alternative for batch normalization (Ioffe and Szegedy, 2015), that has mainly been used in the context of image data to alleviate problems in model training. Actnorm performs an afﬁne transformation of the activations using a scale and bias parameter per feature for sequences:

zt = s zt + b.

(10)

Both z and z are tensors of shape [T × dz] with time dimension t and feature dimension dz. The parameters are initialized such that over each feature zt has zero mean and unit variance given an initial mini-batch of data.

Invertible Multi-head Linear Layers. To incorporate general permutations of variables along the feature dimension to ensure that each dimension can affect every other ones after a sufﬁcient number of steps of ﬂow, Kingma and Dhariwal (2018) proposed a trainable invertible 1×1 convolution layer for 2D images. It is straightforward to apply similar transformations to sequential data:

zt = ztW,

(11)

where W is the weight matrix of shape [dz × dz]. The log-determinant of this transformation is:

log det ∂linear(z; W) ∂z

= T · log |det(W)|

The cost of computing det(W) is O(d3z).

Afﬁne Coupling Layer Linear Layer ActNorm

Inter-Attention source encodings
Encoder

(a) One step of ﬂow.

(b) Coupling layer splits.

(c) NN function on the split of the coupling layer.

Figure 3: (a) The architecture of one step of our ﬂow. (b) The visualization of three split pattern for coupling layers, where the red color denotes za and the blue color denotes zvb. (c) The attention-based architecture of the NN function in coupling layers.

Unfortunately, dz in Seq2Seq generation is commonly large, e.g. 512, signiﬁcantly slowing down the model for computing det(W). To apply this to sequence generation, we propose a multihead invertible linear layer, which ﬁrst splits each dz-dimensional feature vector into h heads with dimension dh = dz/h. Then the linear transformation in (11) is applied to each head, with dh × dh weight matrix W, signiﬁcantly reducing the dimension. For splitting of heads, one step of ﬂow contains one linear layer with either rowmajor or column-major splitting format, and these steps with different linear layers are composed in an alternating pattern.
Afﬁne Coupling Layers. To model interdependence across time steps, we use afﬁne coupling layers (Dinh et al., 2016):
za, zb = split(z) za = za zb = s(za, x) zb + b(za, x) z = concat(za, zb),
where s(za, x) and b(za, x) are outputs of two neural networks with za and x as input. These are shown in Figure 3 (c). In experiments, we implement s(·) and b(·) with one Transformer decoder layer (Vaswani et al., 2017): multi-head selfattention over za, followed by multi-head interattention over x, followed by a position-wise feedforward network. The input za is fed into this layer in one pass, without causal masking.
As in Dinh et al. (2016), the split() function splits z the input tensor into two halves, while the concat operation performs the corresponding reverse concatenation operation. In our architecture, three types of split functions are used, based on

the split dimension and pattern. Figure 3 (b) illustrates the three splitting types. The ﬁrst type of split groups z along the time dimension on alternate indices. In this case, FlowSeq mainly models the interactions between time-steps. The second and third types of splits perform on the feature dimension, with continuous and alternate patterns, respectively. For each type of split, we alternate za and zb to increase the ﬂexibility of the split function. Different types of afﬁne coupling layers alternate in the ﬂow, similar to the linear layers.

Multi-scale Architecture. We follow Dinh et al.

(2016) in implementing a multi-scale architecture

using the squeezing operation on the feature di-

mension, which has been demonstrated helpful for

training deep ﬂows. Formally, each scale is a com-

bination of several steps of the ﬂow (see Figure 3

(a)). After each scale, the model drops half of the

dimensions with the third type of split in Figure 3

(b) to reduce computational and memory cost, out-

putting the tensor with shape [T × d2 ]. Then the

squeezing

operation

transforms

the

T

×

d 2

tensor

into

an

T 2

×d

one

as

the

input

of

the

next

scale.

We

pad each sentence with EOS tokens to ensure T is

divisible by 2. The right component of Figure 2

illustrates the multi-scale architecture.

3.5 Predicting Target Sequence Length
In autoregressive seq2seq models, it is natural to determine the length of the sequence dynamically by simply predicting a special EOS token. However, for FlowSeq to predict the entire sequence in parallel, it needs to know its length in advance to generate the latent sequence z. Instead of predicting the absolute length of the target sequence, we predict the length difference between source

and target sequences using a classiﬁer with a range of [−20, 20]. Numbers in this range are predicted by max-pooling the source encodings into a single vector,2 running this through a linear layer, and taking a softmax. This classiﬁer is learned jointly with the rest of the model.
3.6 Decoding Process
At inference time, the model needs to identify the sequence with the highest conditional probability by marginalizing over all possible latent variables (see Eq. (3)), which is intractable in practice. We propose three approximating decoding algorithms to reduce the search space.
Argmax Decoding. Following Gu et al. (2018), one simple and effective method is to select the best sequence by choosing the highest-probability latent sequence z:
z∗ = argmax pθ(z|x)
z∈Z
y∗ = argmax Pθ(y|z∗, x)
y
where identifying y∗ only requires independently maximizing the local probability for each output position (see Eq. 4).
Noisy Parallel Decoding (NPD). A more accurate approximation of decoding, proposed in Gu et al. (2018), is to draw samples from the latent space and compute the best output for each latent sequence. Then, a pre-trained autoregressive model is adopted to rank these sequences. In FlowSeq, different candidates can be generated by sampling different target lengths or different samples from the prior, and both of the strategies can be batched via masks during decoding. In our experiments, we ﬁrst select the top l length candidates from the length predictor in §3.5. Then, for each length candidate we use r random samples from the prior network to generate output sequences, yielding a total of l × r candidates.
Importance Weighted Decoding (IWD) The third approximating method is based on the lower bound of importance weighted estimation (Burda et al., 2015). Similarly to NPD, IWD ﬁrst draws samples from the latent space and computes the best output for each latent sequence. Then, IWD
2We experimented with other methods such as meanpooling or taking the last hidden state and found no major difference in our experiments

ranks these candidate sequences with K importance samples:

zi ∼ pθ(z|x), ∀i = 1, . . . , N

yˆi = argmax Pθ(y|zi, x)
y

z(ik) ∼ qφ(z|yˆi, x), ∀k = 1, . . . , K

P (yˆi|x) ≈ 1 K Pθ(yˆi|z(ik),x)pθ(z(ik)|x)

K k=1

qφ(z(ik)|yˆi,x)

IWD does not rely on a separate pre-trained model, though it signiﬁcantly slows down the decoding speed. The detailed comparison of these three decoding methods is provided in §4.2.

3.7 Discussion
Different from the architecture proposed in Ziegler and Rush (2019), the architecture of FlowSeq is not using any autoregressive ﬂow (Kingma et al., 2016; Papamakarios et al., 2017), yielding a truly non-autoregressive model with both efﬁcient density estimation and generation. Note that FlowSeq remains non-autoregressive even if we use an RNN in the architecture because RNN is only used to encode a complete sequence of codes and all the input tokens can be fed into the RNN in parallel. This makes it possible to use highly-optimized implementations of RNNs such as those provided by cuDNN.3 Thus while RNNs do experience some drop in speed, it is less extreme than that experienced when using autoregressive models.

4 Experiments
4.1 Experimental Setups
Translation Datasets We evaluate FlowSeq on three machine translation benchmark datasets: WMT2014 DE-EN (around 4.5M sentence pairs), WMT2016 RO-EN (around 610K sentence pairs) and a smaller dataset IWSLT2014 DE-EN (around 150K sentence pairs) (Cettolo et al., 2012). We use scripts from fairseq (Ott et al., 2019) to preprocess WMT2014 and IWSLT2014, where the preprocessing steps follow Vaswani et al. (2017) for WMT2014. We use the data provided by Lee et al. (2018) for WMT2016. For both WMT datasets, the source and target languages share the same set of subword embeddings while for IWSLT2014 we use separate embeddings. During training, we ﬁlter out sentences longer than 80 for WMT dataset and 60 for IWSLT, respectively.
3https://devblogs.nvidia.com/optimizing-recurrentneural-networks-cudnn-5/

Models

WMT2014

WMT2016

IWSLT2014

EN-DE DE-EN EN-RO RO-EN DE-EN

CMLM-base LV NAR
FlowSeq-base FlowSeq-large

10.88 11.80
18.55 20.85

Raw Data

–

20.24

–

–

23.36 25.40

29.26 29.86

– –
30.16 30.69

– –
24.75 –

NAT-IR CTC Loss NAT w/ FT NAT-REG CMLM-small CMLM-base
FlowSeq-base FlowSeq-large

Knowledge Distillation

13.91 17.68 17.69 20.65 15.06 18.12

16.77 19.80 21.47 24.77 19.26 22.26

24.45 19.93 27.29
– 20.12 23.65

21.45 23.72

26.16 28.39

29.34 29.73

25.73 24.71 29.06
– 20.36 22.78
30.44 30.72

21.86 –
20.32 23.89
– –
27.55 –

Table 1: BLEU scores on three MT benchmark datasets for FlowSeq with argmax decoding and baselines with purely non-autoregressive decoding methods. The ﬁrst and second block are results of models trained w/w.o. knowledge distillation, respectively.

Modules and Hyperparameters We implement the encoder, decoder and posterior networks with standard (unmasked) Transformer layers (Vaswani et al., 2017). For WMT datasets, we use 8 attention heads, the encoder consists of 6 layers, and the decoder and posterior are composed of 4 layers. For IWSLT, we use 4 attention heads, the encoder has 5 layers, and decoder and posterior have 3 layers. The prior ﬂow consists of 3 scales with the number of steps [48, 48, 16] from bottom to top. To dissect the impact of model dimension on translation quality and speed, we perform experiments on two versions of FlowSeq with dmodel/dhidden = 256/512 (base) and dmodel/dhidden = 512/1024 (large). More model details are provided in Appendix B.

Optimization Parameter optimization is performed with the Adam optimizer (Kingma and Ba, 2014) with β = (0.9, 0.999), = 1e−8 and AMSGrad (Reddi et al., 2018). Each mini-batch consist of 2048 sentences. The learning rate is initialized to 5e − 4, and exponentially decays with rate 0.999995. The gradient clipping cutoff is 1.0. For all the FlowSeq models, we apply 0.1 label smoothing (Vaswani et al., 2017) and averaged the 5 best checkpoints to create the ﬁnal model.
At the beginning of training, the posterior network is randomly initialized, producing noisy supervision to the prior. To mitigate this issue, we ﬁrst set the weight of the KL term in the ELBO to zero for 30,000 updates to train the encoder, decoder and posterior networks. Then the KL weight

Models

WMT2014

WMT2016

EN-DE DE-EN EN-RO RO-EN

Transformer-base Our Implementation

Autoregressive Methods

27.30 27.16

– 31.44

– 32.92

– 33.09

Raw Data

CMLM-base (reﬁnement 4) CMLM-base (reﬁnement 10)

22.06 24.65

FlowSeq-base (IWD n = 15) FlowSeq-base (NPD n = 15) FlowSeq-base (NPD n = 30) FlowSeq-large (IWD n = 15) FlowSeq-large (NPD n = 15) FlowSeq-large (NPD n = 30)

20.20 20.81 21.15 22.94 23.14 23.64

– –
24.63 25.76 26.04 27.16 27.71 28.29

30.89 32.53
30.61 31.38 31.74 31.08 31.97 32.35

– –
31.50 32.01 32.45 32.03 32.46 32.91

Knowledge Distillation

NAT-IR (reﬁnement 10) NAT w/ FT (NPD n = 10) NAT-REG (NPD n = 9) LV NAR (reﬁnement 4) CMLM-small (reﬁnement 10) CMLM-base (reﬁnement 10)

21.61 18.66 24.61 24.20 25.51 26.92

25.48 22.42 28.90
– 29.47 30.86

FlowSeq-base (IWD n = 15) FlowSeq-base (NPD n = 15) FlowSeq-base (NPD n = 30) FlowSeq-large (IWD n = 15) FlowSeq-large (NPD n = 15) FlowSeq-large (NPD n = 30)

22.49 23.08 23.48 24.70 25.03 25.31

27.40 28.07 28.40 29.44 30.48 30.68

29.32 29.02
– – 31.65 32.42
30.59 31.35 31.75 31.02 31.89 32.20

30.19 31.44
– – 32.27 33.06
31.58 32.11 32.49 31.97 32.43 32.84

Table 2: BLEU scores on two WMT datasets of models using advanced decoding methods. The ﬁrst block are autoregressive Transformer-base (Vaswani et al., 2017). The second and third blocks are results of models trained w/w.o. knowledge distillation, respectively. n = l × r is the total number of rescoring candidates.

linearly increases to one for another 10,000 updates, which we found essential to accelerate training and achieve stable performance.
Knowledge Distillation Previous work on nonautoregressive generation (Gu et al., 2018; Ghazvininejad et al., 2019) has used translations produced by a pre-trained autoregressive NMT model as the training data, noting that this can signiﬁcantly improve the performance. We analyze the impact of distillation in § 4.2.
4.2 Main Results
We ﬁrst conduct experiments to compare the performance of FlowSeq with strong baseline models, including NAT w/ Fertility (Gu et al., 2018), NAT-IR (Lee et al., 2018), NAT-REG (Wang et al., 2019), LV NAR (Shu et al., 2019), CTC Loss (Libovicky` and Helcl, 2018), and CMLM (Ghazvininejad et al., 2019).
Table 1 provides the BLEU scores of FlowSeq with argmax decoding, together with baselines with purely non-autoregressive decoding methods that generate output sequence in one parallel pass. The ﬁrst block lists results of models trained

Decoding Time (s / sent) Relative Decoding Speed-up
Decoding Time (s / sent) Relative Decoding Speed-up

6

0.25

Transformer FlowSeq-base

FlowSeq-large

5

0.20

FlowSeq-base speedup

FlowSeq-large speedup

4

0.15

0.10

3

0.05

2

0.00 0 20 40 60 80 100 120 1 Batch Size

(a) batch size

0.050 0.045 0.040 0.035 0.030 0.025 0.020 0.015 0.010
(0, 10]

Transformer FlowSeq-base FlowSeq-large FlowSeq-base speedup FlowSeq-large speedup
(10, 20] (20, 30] (30, 40] Length of Target Sentence

(b) target length

6 5 4 3 2 1 >40 0

Figure 4: The decoding speed of the Transformer (batched, beam size 5) and FlowSeq on WMT14 EN-DE test set (a) w.r.t. different batch sizes (b) bucketed by different target sentence lengths (batch size 32).

on raw data, while the second block shows results using knowledge distillation. Without using knowledge distillation, the FlowSeq base model achieves signiﬁcant improvements (more than 9 BLEU points) over the baselines. This demonstrates the effectiveness of FlowSeq in modeling complex interdependences in the target languages.
Regarding the effect of knowledge distillation, we can mainly obtain two observations: i) Similar to the ﬁndings in previous work, knowledge distillation still beneﬁts the translation quality of FlowSeq. ii) Compared to previous models, the beneﬁt of knowledge distillation for FlowSeq is less signiﬁcant, yielding less than 3 BLEU improvement on WMT2014 DE-EN corpus, and even no improvement on WMT2016 RO-EN corpus. We hypothesize that the reason for this is that FlowSeq’s stronger model is more robust against multi-modality, making it less necessary to rely on knowledge distillation.
Table 2 illustrates the BLEU scores of FlowSeq and baselines with advanced decoding methods such as iterative reﬁnement, IWD and NPD rescoring. The ﬁrst block in Table 2 includes the baseline results from autoregressive Transformer. For the sampling procedure in IWD and NPD, we sampled from a reduced-temperature model (Kingma and Dhariwal, 2018) to obtain high-quality samples. We vary the temperature within {0.1, 0.2, 0.3, 0.4, 0.5, 1.0} and select the best temperature based on the performance on development sets. The analysis of the impact of sampling temperature and other hyperparameters on samples is shown in § 4.4. For FlowSeq, NPD obtains better results than IWD, showing that FlowSeq still falls behind the autore-

gressive Transformer on modeling the distributions of target languages. Compared with CMLM (Ghazvininejad et al., 2019) with 10 iterations of reﬁnement, which is a contemporaneous work that achieves state-of-the-art translation performance, FlowSeq obtains competitive performance on both WMT2014 and WMT2016 corpora, with only slight degradation in translation quality. Notably we did not attempt to perform iterative reﬁnement, but there is nothing that makes FlowSeq inherently incompatible with reﬁnement – we leave connecting the two techniques to future work.
4.3 Analysis on Decoding Speed
In this section, we compare the decoding speed (measured in average time in seconds required to decode one sentence) of FlowSeq at test time with that of the autoregressive Transformer model. We use the test set of WMT14 EN-DE for evaluation and all experiments are conducted on a single NVIDIA TITAN X GPU.
How does batch size affect the decoding speed? First, we investigate how different decoding batch size can affect the decoding speed. We vary the decoding batch size within {1, 4, 8, 32, 64, 128}. Figure. 4a shows that for both FlowSeq and the autoregressive Transformer decoding is faster when using a larger batch size. However, FlowSeq has much larger gains in the decoding speed w.r.t. the increase in batch size, gaining a speed up of 594% of the base model and 403% of the large model when using a batch size of 128. We hypothesize that this is because the operations in FlowSeq are more friendly to batching while the incremental nature of left-to-right search in the autoregressive model is less efﬁcient in beneﬁting from batching.

BLEU Leave-one-out BLEU

29.0

28.5

28.0

27.5

27.0

26.5

l=1, r=15 l=1, r=30

26.0

l=2, r=8 l=2, r=15

25.5

l=3, r=5

l=3, r=10

25.0

0.2

0.4

0.6

0.8

1.0

Sampling Temperature

Figure 5: Impact of sampling hyperparameters on the rescoring BLEU on the dev set of WMT14 DE-EN. Experiments are performed with FlowSeq-base trained with distillation data. l is the number of length candidates. r is the number of samples for each length.

How does sentence length affect the decoding speed? Next, we examine if sentence length is a major factor affecting the decoding speed. We bucket the test data by the target sentence length. From Fig. 4b, we can see that as the sentence length increases, FlowSeq achieves almost a constant decoding time while the autoregressive Transformer has a linearly increasing decoding time. The relative decoding speed of FlowSeq versus the Transformer linearly increases as the sequence length increases. The potential of decoding long sequences with constant time is an attractive property of FlowSeq.

4.4 Analysis of Rescoring Candidates
In Fig. 5, we analyze how different sampling hyperparameters affect the performance of rescoring. First, we observe that the number of samples r for each length is the most important factor. The performance is always improved with a larger sample size. Second, a larger number of length candidates does not necessarily increase the rescoring performance. Third, we ﬁnd that a larger sampling temperature (0.3 - 0.5) can increase the diversity of translations and leads to better rescoring BLEU. However, the latent samples become noisy when a large temperature (1.0) is used.

4.5 Analysis of Translation Diversity
Following He et al. (2018) and Shen et al. (2019), we analyze the output diversity of FlowSeq. They proposed pairwise-BLEU and BLEU computed in a leave-one-out manner to calibrate the diversity and quality of translation hypotheses. A lower pairwise-BLEU score implies a more diverse hy-

75

70

65

60

0.1 0.2 0.30.4 0.5

55

0.1 0.20.30.40.5

1.0

50

human Beam search

1.0

45

Hard MoE

Sampling

40

FlowSeq-large, distill, l=3, r=4

FlowSeq-large, distill, l=2, r=5

3580

70

60

50

40

30

20

Pairwise BLEU

Figure 6: Comparisons of FlowSeq with human translations, beam search and sampling results of Transformer-base, and mixture-of-experts model (Hard MoE (Shen et al., 2019)) on the averaged leave-one-out BLEU score v.s pairwise-BLEU in descending order.

pothesis set. And a higher BLEU score implies a better translation quality. We experiment on a subset of the test set of WMT14-ENDE with ten references for each sentence (Ott et al., 2018). In Fig. 6, we compare FlowSeq with other multihypothesis generation methods (ten hypotheses each sentence) to analyze how well the generation outputs of FlowSeq are in terms of diversity and quality. The right corner area of the ﬁgure indicates the ideal generations: high diversity and high quality. While FlowSeq still lags behind the autoregressive generation, by increasing the sampling temperature it provides a way of generating more diverse outputs while keeping the translation quality almost unchanged. More analysis of translation outputs and detailed results are provided in the Appendix D and E.
5 Conclusion
We propose FlowSeq, an efﬁcient and effective model for non-autoregressive sequence generation by using generative ﬂows. One potential direction for future work is to leverage iterative reﬁnement techniques such as masked language models to further improve translation quality. Another exciting direction is to, theoretically and empirically, investigate the latent space in FlowSeq, hence providing deeper insights into the model, and allowing for additional applications such as controllable text generation.
Acknowledgments
Xuezhe MA was supported in part by DARPA grant FA8750-18-2-0018 funded under the AIDA program and Chunting Zhou was supported by

DARPA grant HR0011-15-C-0114 funded under the LORELEI program. Any opinions, ﬁndings, and conclusions expressed in this material are those of the authors and do not necessarily reﬂect the views of DARPA. The authors thank Amazon for their gift of AWS cloud credits and anonymous reviewers for their helpful suggestions.

References
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. 2015. Neural machine translation by jointly learning to align and translate. In International Conference on Learning Representations (ICLR).

Samuel R Bowman, Luke Vilnis, Oriol Vinyals, Andrew M Dai, Rafal Jozefowicz, and Samy Bengio. 2015. Generating sentences from a continuous space. arXiv preprint arXiv:1511.06349.

Yuri Burda, Roger Grosse, and Ruslan Salakhutdinov. 2015. Importance weighted autoencoders. arXiv preprint arXiv:1509.00519.

Mauro Cettolo, Christian Girardi, and Marcello Federico. 2012. Wit3: Web inventory of transcribed and translated talks. In Conference of European Association for Machine Translation, pages 261–268.

Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2018. Bert: Pre-training of deep bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805.

Laurent Dinh, Jascha Sohl-Dickstein, and Samy Bengio. 2016. Density estimation using real nvp. arXiv preprint arXiv:1605.08803.

Marjan Ghazvininejad, Omer Levy, Yinhan Liu, and Luke Zettlemoyer. 2019. Constant-time machine translation with conditional masked language models. arXiv preprint arXiv:1904.09324.

Jiatao Gu, James Bradbury, Caiming Xiong, Victor OK Li, and Richard Socher. 2018. Non-autoregressive neural machine translation. Proceedings of the 6th International Conference on Learning Representations (ICLR-2018).

Jiatao Gu, Qi Liu, and Kyunghyun Cho. 2019.

Insertion-based decoding with automatically

inferred generation order.

arXiv preprint

arXiv:1902.01370.

Xuanli He, Gholamreza Haffari, and Mohammad Norouzi. 2018. Sequence to sequence mixture model for diverse machine translation. In Proceedings of the 22nd Conference on Computational Natural Language Learning, pages 583–592.

Sergey Ioffe and Christian Szegedy. 2015. Batch normalization: Accelerating deep network training by reducing internal covariate shift. In International Conference on Machine Learning, pages 448–456.

Diederik P Kingma and Jimmy Ba. 2014. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980.
Diederik P Kingma, Tim Salimans, Rafal Jozefowicz, Xi Chen, Ilya Sutskever, and Max Welling. 2016. Improving variational inference with inverse autoregressive ﬂow. The 29th Conference on Neural Information Processing Systems.
Durk P Kingma and Prafulla Dhariwal. 2018. Glow: Generative ﬂow with invertible 1x1 convolutions. In Advances in Neural Information Processing Systems, pages 10215–10224.
Jason Lee, Elman Mansimov, and Kyunghyun Cho. 2018. Deterministic non-autoregressive neural sequence modeling by iterative reﬁnement. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 1173– 1182.
Jindˇrich Libovicky` and Jindˇrich Helcl. 2018. End-toend non-autoregressive neural machine translation with connectionist temporal classiﬁcation. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 3016– 3021.
Xuezhe Ma and Eduard Hovy. 2019. Macow: Masked convolutional generative ﬂow. arXiv preprint arXiv:1902.04208.
Xuezhe Ma, Zecong Hu, Jingzhou Liu, Nanyun Peng, Graham Neubig, and Eduard Hovy. 2018. Stackpointer networks for dependency parsing. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 1403–1414.
Xuezhe Ma, Chunting Zhou, and Eduard Hovy. 2019. Mae: Mutual posterior-divergence regularization for variational autoencoders. In Proceedings of the 7th International Conference on Learning Representations (ICLR-2019), New Orleans, Louisiana, USA.
Oren Melamud, Jacob Goldberger, and Ido Dagan. 2016. context2vec: Learning generic context embedding with bidirectional LSTM. In Proceedings of The 20th SIGNLL Conference on Computational Natural Language Learning, pages 51–61, Berlin, Germany. Association for Computational Linguistics.
Myle Ott, Michael Auli, David Grangier, et al. 2018. Analyzing uncertainty in neural machine translation. In International Conference on Machine Learning, pages 3953–3962.
Myle Ott, Sergey Edunov, Alexei Baevski, Angela Fan, Sam Gross, Nathan Ng, David Grangier, and Michael Auli. 2019. fairseq: A fast, extensible toolkit for sequence modeling. In Proceedings of NAACL-HLT 2019: Demonstrations.

George Papamakarios, Theo Pavlakou, and Iain Murray. 2017. Masked autoregressive ﬂow for density estimation. In Advances in Neural Information Processing Systems, pages 2338–2347.
Ryan Prenger, Rafael Valle, and Bryan Catanzaro. 2019. Waveglow: A ﬂow-based generative network for speech synthesis. In ICASSP 20192019 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), pages 3617–3621. IEEE.
Sashank J Reddi, Satyen Kale, and Sanjiv Kumar. 2018. On the convergence of adam and beyond. In Proceedings of the 6th International Conference on Learning Representations (ICLR-2018).
Danilo Jimenez Rezende and Shakir Mohamed. 2015. Variational inference with normalizing ﬂows. In Proceedings of the 32nd International Conference on International Conference on Machine LearningVolume 37, pages 1530–1538. JMLR. org.
Alexander M Rush, Sumit Chopra, and Jason Weston. 2015. A neural attention model for abstractive sentence summarization. In Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing, pages 379–389.
Tianxiao Shen, Myle Ott, Michael Auli, et al. 2019. Mixture models for diverse machine translation: Tricks of the trade. In International Conference on Machine Learning, pages 5719–5728.
Raphael Shu, Jason Lee, Hideki Nakayama, and Kyunghyun Cho. 2019. Latent-variable nonautoregressive neural machine translation with deterministic inference using a delta posterior. arXiv preprint arXiv:1908.07181.
Mitchell Stern, William Chan, Jamie Kiros, and Jakob Uszkoreit. 2019. Insertion transformer: Flexible sequence generation via insertion operations. arXiv preprint arXiv:1902.03249.
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In Advances in neural information processing systems, pages 5998–6008.
Oriol Vinyals, Alexander Toshev, Samy Bengio, and Dumitru Erhan. 2015. Show and tell: A neural image caption generator. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages 3156–3164.
Martin J Wainwright, Michael I Jordan, et al. 2008. Graphical models, exponential families, and variational inference. Foundations and Trends R in Machine Learning, 1(1–2):1–305.
Yiren Wang, Fei Tian, Di He, Tao Qin, ChengXiang Zhai, and Tie-Yan Liu. 2019. Non-autoregressive machine translation with auxiliary regularization. arXiv preprint arXiv:1902.10245.

Zachary Ziegler and Alexander Rush. 2019. Latent normalizing ﬂows for discrete sequences. In International Conference on Machine Learning, pages 7673–7682.

Appendix: FlowSeq

A Flow Layers
ActNorm
Log-determinant:

zt = s zt + b. T · sum(log |s|)

Invertible Linear Log-determinant:

zt = ztW, T · h · log |det(W)|

where h is the number of heads.

Afﬁne Coupling Log-determinant:

za, zb = split(z) za = za zb = s(za, x) zb + b(za, x) z = concat(za, zb),
sum(log |s|)

B Model Details

Model Transformer-base Transformer-large
FlowSeq-base FlowSeq=large

Dimensions (Model/Hidden) 512/2048 2014/4096
256/512 512/2014

#Params 65M 218M
73M 258M

Table 3: Comparison of model size in our experiments.

C Analysis of training dynamics

Dev Reconstruction Loss Train Reconstruction Loss
Dev KL loss Dev NLL loss
Train KL loss Dev BLEU

80

300

70

Reconstruction Loss KL loss

200

60

100

0 10 20 Epoch 30 40 50

(a) training loss

40

150 150

22.5

30

Reconstruction Loss KL loss

100

125

NLL loss 20.0
BLEU

20 50 100 1157..05 75

10 0 10 20 30 40 50

0

10

20

30

40

50

Epoch

Epoch

(b) dev loss

(c) dev BLEU

Figure 7: Training dynamics.

In Fig. 7, we plot the train and dev loss together with dev BLEU scores for the ﬁrst 50 epochs. We can see that the reconstruction loss is increasing at the initial stage of training, then starts to decrease when training with full KL loss. In addition, we observed that FlowSeq does not suffer the KL collapse problem (Bowman et al., 2015; Ma et al., 2019). This is because the decoder of FlowSeq is non-autogressive, with latent variable z as the only input.

D Analysis of Translation Results

Source Ground Truth Sample 1 Sample 2 Sample 3 Source
Ground Truth Sample 1 Sample 2 Sample 3 Source Ground Truth Sample 1 Sample 2 Sample 3 Source Ground Truth Sample 1 Sample 2 Sample 3

Grundnahrungsmittel gibt es schlielich berall und jeder Supermarkt hat mittlerweile Sojamilch und andere Produkte. There are basic foodstuffs available everywhere , and every supermarket now has soya milk and other products. After all, there are basic foods everywhere and every supermarket now has soya amch and other products. After all, the food are available everywhere everywhere and every supermarket has soya milk and other products. After all, basic foods exist everywhere and every supermarket has now had soy milk and other products.
Es kann nicht erkla¨ren, weshalb die National Security Agency Daten ber das Privatleben von Amerikanern sammelt und warum Whistleblower bestraft werden, die staatliches Fehlverhalten offenlegen. And, most recently, it cannot excuse the failure to design a simple website more than three years since the Affordable Care Act was signed into law. And recently, it cannot apologise for the inability to design a simple website in the more than three years since the adoption of Affordable Care Act. And recently, it cannot excuse the inability to design a simple website in more than three years since the adoption of Affordable Care Act. Recently, it cannot excuse the inability to design a simple website in more than three years since the Affordable Care Act has passed.
Doch wenn ich mir die oben genannten Beispiele ansehe, dann scheinen sie weitgehend von der Regierung selbst gewa¨hlt zu sein. Yet, of all of the examples that I have listed above, they largely seem to be of the administration’s own choosing. However, when I look at the above mentioned examples, they seem to be largely elected by the government itself. But if I look at the above mentioned examples, they seem to have been largely elected by the government itself. But when I look at the above examples, they seem to be largely chosen by the government itself.
Damit wollte sie auf die Gefahr von noch gro¨eren Ruinen auf der Schweizer Wiese hinweisen - sollte das Riesenprojekt eines Tages scheitern. In so doing they wanted to point out the danger of even bigger ruins on the Schweizer Wiese - should the huge project one day fail. In so doing, it wanted to highlight the risk of even greater ruins on the Swiss meadow - the giant project should fail one day. In so doing, it wanted to highlight the risk of even greater ruins on the Swiss meadow - if the giant project fail one day. In doing so, it wanted point out the risk of even greater ruins on the Swiss meadow - the giant project would fail one day.

Table 4: Examples of translation outputs from FlowSeq-base with sampling hyperparameters l = 3, r = 10, τ = 0.4 on WMT14-DEEN.
In Tab. 4, we present randomly picked translation outputs from the test set of WMT14-DEEN. For each German input sentence, we pick three hypotheses from 30 samples. We have the following observations: First, in most cases, it can accurately express the meaning of the source sentence, sometimes in a different way from the reference sentence, which cannot be precisely reﬂected by the BLEU score. Second, by

controlling the sampling hyper-parameters such as the length candidates l, the sampling temperature τ and the number of samples r under each length, FlowSeq is able to generate diverse translations expressing the same meaning. Third, repetition and broken translations also exist in some cases due to the lack of direct modeling of dependencies between target words.
E Results of Translation Diversity
Table 5 shows the detailed results of translation diversity.

Models

τ Pairwise BLEU LOO BLEU

Human

–

Sampling

–

Beam Search –

Hard-MoE –

35.48 24.10 73.00 50.02

69.07 37.80 69.90 63.80

0.1 0.2 FlowSeq 0.3 l=1, r=10 0.4 0.5 1.0

79.39 72.12 67.85 64.75 61.12 43.53

61.61 61.05 60.79 60.07 59.54 52.86

0.1 0.2 FlowSeq 0.3 l=2, r=5 0.4 0.5 1.0

70.32 66.45 63.72 61.29 58.49 42.93

60.54 60.21 59.81 59.47 58.80 52.58

0.1 0.2 FlowSeq 0.3 l=3, r=4 0.4 0.5 1.0

62.21 59.74 57.57 55.66 53.49 39.75

58.70 58.59 57.96 57.45 56.93 50.94

Table 5: Translation diversity results of FlowSeq-large model on WMT14 EN-DE with knowledge distillation.

