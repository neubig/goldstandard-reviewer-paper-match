JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

1

Control of Mobile Robots Using Barrier Functions Under Temporal Logic Speciﬁcations
Mohit Srinivasan, Student Member, IEEE, and Samuel Coogan, Member, IEEE

arXiv:1908.04903v2 [cs.RO] 29 Mar 2020

Abstract—In this paper, we propose a framework for the control of mobile robots subject to temporal logic speciﬁcations using barrier functions. Complex task speciﬁcations can be conveniently encoded using linear temporal logic. In particular, we consider a fragment of linear temporal logic which encompasses a large class of motion planning speciﬁcations for a robotic system. Control barrier functions have recently emerged as a convenient tool to guarantee reachability and safety for a system. In addition, they can be encoded as afﬁne constraints in a quadratic program. In this paper, a fully automatic framework which translates a user deﬁned speciﬁcation in temporal logic to a sequence of barrier function based quadratic programs is presented. In addition, with the aim of alleviating infeasibility scenarios, we propose methods for composition of barrier functions as well as a prioritization based control method to guarantee feasibility of the controller. We prove that the resulting system trajectory synthesized by the proposed controller satisﬁes the given speciﬁcation. Robotic simulation and experimental results are provided in addition to the theoretical framework.
Index Terms—Control Barrier Functions, Linear Temporal Logic, Mobile Robots, Quadratic Programs.
I. INTRODUCTION
System speciﬁcations to be satisﬁed by mobile robotic systems are increasing in complexity. For example, motion planning for systems such as robotic manipulators [1], personal assistants [2], and quadrotors [3] involves complex speciﬁcations to be satisﬁed by the system. Safety critical systems such as the power grid [4] and automation ﬂoors [5] rely on distributed controllers in order to function in the desired manner. These controllers are again tasked with satisfying complex speciﬁcations. Hence, failure of these controllers can lead to a collapse of the safety critical infrastructure [6]. To that end, synthesizing controllers with formal guarantees on their correct functioning is of key importance.
In this paper, we present a control architecture for the control of mobile robotic systems subject to linear temporal logic speciﬁcations using control barrier functions, which addresses some of the challenges in the previously discussed applications. In particular, we address the issue of situations where proposed methods in existing literature can render the controller infeasible. With the synthesis of the controller, we
This work was supported in part by DARPA under Grant N66001-17-24059 and the National Science Foundation under Grant 1749357
Mohit Srinivasan is with the School of Electrical and Computer Engineering, Georgia Institute of Technology, Atlanta, Georgia 30332 USA (e-mail: mohit.srinivasan@gatech.edu).
Samuel Coogan is with the School of Electrical and Computer Engineering and the School of Civil and Environmental Engineering, Georgia Institute of Technology, Atlanta, Georgia 30332 (email: sam.coogan@gatech.edu)
Manuscript received month day, 20xx; revised month day, 20xx.

then shift focus towards providing formal guarantees regarding the proposed controller framework. In particular, we prove that the system trajectory generated by the proposed controller satisﬁes the given speciﬁcation.
A. Background
Barrier functions were ﬁrst introduced in optimization. A historical account of their use can be found in Chapter 3 in [7]. Usage of barrier functions is now common throughout the control, veriﬁcation and robotics literature due to their natural relationship with Lyapunov-like functions. Control barrier function (CBF) based quadratic programs (QPs) were ﬁrst used in [8], [9] in the context of automotive applications such as adaptive cruise control (ACC). Recently, control barrier functions have been used in the context of multi-agent systems to guarantee collision avoidance between robots [3], [10], [11]. Given a minimum distance to be maintained between the robots, the safety set is encoded as the super zero level set of a zeroing control barrier function (ZCBF) [9]. The authors then use a QP based controller with the ZCBFs as afﬁne constraints in order to guarantee forward invariance of this safety set. This in turn implies that the robots never collide. Such a framework has also been applied to quadrotors [3] where the safety set is considered to be a super ellipsoid which allows quadrotors to avoid collisions with each other.
ZCBFs guarantee asymptotic convergence to desired sets [9]. However, since we focus on motion planning speciﬁcations, we require ﬁnite time reachability guarantees. Recently, [12], [13] have introduced ﬁnite time control barrier functions for ﬁnite time reachability speciﬁcations. In [12], ﬁnite time barrier functions were used to achieve smooth transitions between different behaviors in a multi-agent system. The key objective in [12] was to ensure composability of different formation behaviors by making sure that the multi-agent communication graph is appropriate for the next desired formation, whereas in [13], a method for the composition of multiple ﬁnite time barrier functions was introduced. Barrier functions have also been introduced in hybrid systems theory [14] to guarantee forward invariance of hybrid inclusions.
Finite and inﬁnite horizon speciﬁcations which are useful for mobile robotic systems can be conveniently encoded using linear temporal logic (LTL). The power of LTL originates from the wealth of tools available in the model checking literature [15] which allows for generating trajectories for the robots given a speciﬁcation in temporal logic. LTL based control of robotic systems has been well studied and standard methods ﬁrst create a ﬁnite abstraction of the original dynamical system

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

2

[16], [17], [18], [19]. This abstraction can informally be viewed as a labeled graph that represents possible behaviors of the system. Given such a ﬁnite abstraction, controllers can be automatically constructed using an automata-based approach [18], [15], [20], [21]. However, abstracting the state space is computationally expensive especially with complex system dynamics and speciﬁcations.
In our framework, we avoid the difﬁculties associated with computation of any automaton from the speciﬁcation or a discretization of the state space. Since CBFs can be conveniently encoded within a QP, the controller is amenable to real time implementations without the need for an abstraction of the state space or the system dynamics. Other authors have explored discretization free techniques as well. The authors in [22] discuss the use of time varying control barrier functions for signal temporal logic tasks (STL). In [23], the authors use time-varying barrier functions for control of coupled multiagent systems subject to STL tasks. In both [22] and [23], the authors do not allow for repetitive tasks, a speciﬁcation which can be captured by our proposed framework. The authors in [24], [25], [26] discuss control methods for STL tasks. However, the methods proposed result in computationally expensive mixed integer linear programs. Control methods in the discrete time non-deterministic setting have been explored by [27]. Learning based frameworks are discussed by the authors in [28], [29], [30]. Control techniques for continuoustime multi-agent systems given fragment of STL tasks has been presented in [31]. The authors in [32] discuss a similar continuous time method. However, a non-convex optimization problem may have to be solved.
B. Contributions
There are two primary contributions of this work. First, we propose a barrier function based controller framework to synthesize system trajectories that satisfy a given user deﬁned speciﬁcation. In particular, the proposed framework automatically translates the user deﬁned speciﬁcation formalized in a subset of linear temporal logic (LTL) to a sequence of barrier function based quadratic programs. The approach adopted in this paper is a discretization free approach which alleviates some of the computational issues arising from abstraction based control of mobile robots [16], [17], [18], [19], [20], [21]. Then, we provide formal guarantees that the proposed controller framework produces a system trajectory that satisﬁes the given speciﬁcation. The proposed family of LTL speciﬁcations in our work can capture more complex speciﬁcations than the fragment considered in [22], [23]. In addition, our guarantees are different from other papers on temporal logic based control using barrier functions [22], [23] in that we characterize the family of trajectories that satisfy the given speciﬁcation, and then prove that the proposed controller indeed produces a trajectory that belongs to the set of satisfying trajectories. The trajectory generated by the proposed CBF based controller is analyzed and the guarantees of CBFs translate to guarantees on the system trajectory.
Second, we address the issue of controller infeasibility for both reachability and safety objectives, a common difﬁculty

in CBF based real-time control [33], [34]. We ﬁrst illustrate a scenario where the method of encoding multiple ﬁnite time reachability objectives individually in a CBF based QP framework—as proposed in, e.g., [12]—fails. This is because encoding each reachability speciﬁcation as a separate constraint in the QP is restrictive when the reachability objective is deﬁned by multiple CBFs. We instead propose a method to compose multiple ﬁnite time control barrier functions as a single QP constraint which results in a larger feasible set while retaining the same guarantees as those established in [12]. Next, we consider the case when some safety speciﬁcations (captured using ZCBFs) are in conﬂict with others and propose a prioritization scheme, similar to the method discussed in [35], in order to relax the ZCBFs which characterize the safety constraints. We guarantee satisfaction of the reachability tasks while minimally violating the safety speciﬁcations. While not a main focus of this paper, this relaxation is a novel reformulation of ideas presented in [9] and [35] for use in motion planning problems with ﬁnite time reachability constraints.
A preliminary version of this work was presented in our conference paper [13] where we formulated the notion of composition of multiple ﬁnite time control barrier functions. In the present paper, we signiﬁcantly extend those results in order to synthesize an automated framework (full solution) to transition from a speciﬁcation belonging to a fragment of LTL, to the barrier function based controller.
This paper is organized as follows. Section II introduces control barrier functions, linear temporal logic and the quadratic program based controller used for trajectory generation of the system. In Section III, we discuss the problem statement that is addressed in this paper. Section IV introduces the idea of composite ﬁnite time control barrier functions [13] and the prioritization scheme for different zeroing barrier functions. In Section V, we propose the QP based controller and develop the theoretical framework which provides a formal guarantee that the proposed controller synthesizes a system trajectory that satisﬁes the given speciﬁcation. Section VI discusses a multi-agent system case study with simulation and experimental results. Section VII provides concluding remarks.
II. MATHEMATICAL BACKGROUND
In this section, we provide background on control barrier functions (CBFs) and the guarantees on invariance and reachability of sets obtained from them, linear temporal logic (LTL) which is the speciﬁcation language, and the quadratic program (QP) based controller with the CBFs as constraints which will be used to synthesize the trajectory for a control-afﬁne robotic system.

A. Control Barrier Functions (CBFs)

Consider a continuous time, control-afﬁne dynamical sys-

tem

x˙ = f (x) + g(x)u ,

(1)

where f : X → Rn and g : X → Rn×m are locally Lipschitz continuous, x ∈ X ⊆ Rn is the state of the system, and u ∈ Rm
is the control input applied to the system.

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

3

Before we introduce the notion of control barrier functions, we deﬁne an extended class K function [36] α : R → R as a function that is strictly increasing and α(0) = 0.
Deﬁnition 1 (Zeroing Control Barrier Function (ZCBF)). A continuously differentiable function h : X → R is a zeroing control barrier function (ZCBF) if there exists a locally Lipschitz extended class K function α such that for all x ∈ X ,

sup L f h(x) + Lgh(x)u + α(h(x)) ≥ 0

(2)

u∈Rm

where

L f h(x)

=

∂ h(x) ∂x

f (x)

and

Lgh(x)

=

∂ h∂(xx) g(x)

are

the

Lie

derivatives of h along f and g respectively.

Let Σ ⊆ X be a safety set deﬁned as Σ = {x ∈ X | h(x) ≥ 0} where h : X → R is a ZCBF. The set of control inputs that satisfy (2) at any given state x ∈ X is then deﬁned as

UΣ(x) = u ∈ Rm | L f h(x) + Lgh(x)u + α(h(x)) ≥ 0 . (3)

One can guarantee forward invariance of desired sets under the existence of a suitable ZCBF as formalized in the following proposition.

Proposition 1 (Corollary 1, [9]). If h is a ZCBF, then any continuous feedback controller satisfying u ∈ UΣ(x) renders the set Σ forward invariant for the system (1).

We now deﬁne ﬁnite time convergence control barrier functions, ﬁrst introduced in [12], which guarantee ﬁnite time convergence to desired sets in the state space.

Deﬁnition 2 (Finite Time Convergence Control Barrier Function (FCBF)). A continuously differentiable function h : X → R is a ﬁnite time convergence control barrier function if there exist parameters ρ ∈ [0, 1) and γ > 0 such that for all x ∈ X ,

sup L f h(x) + Lgh(x)u + γ · sign(h(x)) · |h(x)|ρ ≥ 0 (4)
u∈Rm

where

L f h(x)

=

∂ h(x) ∂x

f (x)

and

Lgh(x)

=

∂ h∂(xx) g(x).

Let Γ ⊆ X be a target set deﬁned as Γ = {x ∈ X | h(x) ≥ 0} where h : X → R. Let the set of control inputs that satisfy (4) at any state x ∈ X be given by

UΓ(x) = u ∈ Rm L f h(x)+Lgh(x)u+γ ·sign(h(x))·|h(x)|ρ ≥ 0
(5) If h is a FCBF, then there exists a control input u that drives the state of the system x to the target set {x ∈ X | h(x) ≥ 0} in ﬁnite time, as formalized next.
Proposition 2 (Proposition III.1, [12]). If h is a FCBF for (1), then, for any initial condition x0 ∈ X and any continuous feedback control u : X → Rm satisfying u ∈ UΓ(x) for all x ∈ X , the system will be driven to the set Γ in a ﬁnite time 0 < T < ∞ such that x(T ) ∈ Γ, where the time bound is given by T = |hγ((x10−)|1ρ−)ρ . Moreover, Γ is forward invariant so that the system remains in Γ for all t ≥ T .
ZCBFs and FCBFs will form the basis for our control synthesis methodology. Next, we discuss the temporal language used to specify complex robotic system speciﬁcations in our framework.

B. Linear Temporal Logic
Complex and rich system properties can be expressed succinctly using linear temporal logic (LTL). The power of LTL lies in the wealth of tools available in the model checking literature [15] which can be leveraged for the synthesis of controllers in the continuous domain. LTL formulas are developed using atomic propositions which label regions of interest within the state space. These formulas are built using a speciﬁc grammar. LTL formulas without the next operator are given by the following grammar [15]:

φ = π|¬φ |φ ∨ φ |φ Uφ

(6)

where π is a member of the set of atomic propositions denoted by Π, and φ is a propositional formula that represents an LTL speciﬁcation. Since we deal with continuous time systems in this work, the use of the “next” operator ( ) lacks meaningful interpretation, and hence, this operator is not included in our framework. Nonetheless, a large class of motion planning speciﬁcations (for example, the class of speciﬁcations proposed in [37] and characterized below in Deﬁnition 3 do not require the next operator. In particular, ﬁnite time reachability speciﬁcations can be encoded in our proposed work.
We use the standard graphical notation for the temporal operators including (“Always”), ♦ (“Eventually”), ♦ (“Persistence”) and ♦ (“Recurrence”). From the negation (¬) and the disjunction (∨) operators, we can deﬁne the conjunction (∧), implication (→), and equivalence (↔) operators. We can thus derive for example, the eventually (♦) and always ( ) operators as ♦φ = Uφ and φ = ¬♦¬φ respectively. Below we provide informal interpretations of these operators with respect to an LT L formula φ .
• ♦φ is satisﬁed if φ is satisﬁed sometime in the future. That is, φ is satisﬁed at some point of time in the future.
• φ is satisﬁed if φ is satisﬁed for all time. That is, φ is satisﬁed for all time.
• ♦ φ is satisﬁed if φ becomes satisﬁed at some point of time in the future and then remains satisﬁed for all time.
• ♦φ is satisﬁed if φ is satisﬁed inﬁnitely often at various points of time in the future.
Next we discuss the QP based controller which will be used for the synthesis of the system trajectory.

C. Quadratic Program (QP) based controller

Given a FCBF or ZCBF h, the constraints (3) and (5)

are afﬁne in the control input u, and hence they can be

conveniently encoded as afﬁne constraints in a QP. Hence

this formulation is amenable to efﬁcient online computation

of feasible control inputs. In particular, for ﬁxed x ∈ X , the

requirement that u ∈ UΓ(x) and/or u ∈ UΣ(x) becomes a linear

constraint and we deﬁne a minimum energy quadratic program

(QP) as

min ||u||22

u∈Rm

(7)

s.t u ∈ UΓ(x) and/or u ∈ UΣ(x).

We note that (7) can encode both ﬁnite time reachability as well as forward invariance requirements as constraints in

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

4

the QP. This QP when solved returns the pointwise minimum norm control law that drives the system to the goal set Γ in ﬁnite time and/or guarantees invariance of Σ. We will reference this idea of a QP based controller throughout this paper in the context of our theoretical framework.
Remark 1. We note that multiple ZCBFs and multiple FCBFs can be encoded as separate constraints in the QP. In this case, we solve a single QP with multiple barrier function constraints. For example, see [9], [12].

III. PROBLEM STATEMENT
In this paper, we consider a continuous time mobile robotic system in control afﬁne form as in (1). We assume that X contains regions of interest which are labeled by a set of atomic propositions Π = {π1, π2, π3, . . . , πn} with the labeling function L : X → 2Π so that π ∈ Π is true at x ∈ X if and only if π ∈ L(x). These regions may overlap and need not constitute a partition or cover of X . For each σ ∈ 2Π, we have L−1(σ ) = {x ∈ X |σ = L(x)}. Let Πaug = {π1, π2, . . . , πn, π1, π2, . . . , πn} be the augmented set of atomic propositions where we deﬁne πi = ¬πi for all i ∈ {1, 2, . . . , n}. The set Πaug is also called the set of literals [15]. Thus, we identify ¬πi = πi for all i ∈ {1, 2, . . . , n}. In addition, deﬁne

S(Πaug) = {J ⊂ Πaug |π ∈ J =⇒ ¬π ∈ J for all π ∈ Πaug} (8)

P(Πaug) = {J ⊂ Πaug | (πi ∈ J)⊕(πi ∈ J) for all i ∈ {1, 2, . . . , n}} (9)

where ⊕ is the exclusive disjunction operator. Observe that P(Πaug) ⊂ S(Πaug). A subset of Πaug belongs to the family S(Πaug) if it does not contain an atomic proposition and its negation simultaneously, and it further belongs to P(Πaug) if it contains each atomic proposition exclusive-or its negation.
We consider a fragment of LTL, denoted by LT Lrobotic, which is a modiﬁcation of the fragment considered in [38]. Our proposed fragment covers a large class of motion planning tasks, such as the ones discussed in [37], expected from a robotic system.

Deﬁnition 3 (Fragment of LTL). The fragment LT Lrobotic is deﬁned as the class of LTL speciﬁcations of the form

φ = φglobe ∧ φreach ∧ φrec ∧ φact

(10)

where φglobe = ψ1, φreach = ♦ψ2j, φrec =

j
♦ψ3

and

j∈I2

j∈I3

φact = ♦ ψ4. Here I2 and I3 are ﬁnite index sets and ψ1,

j
ψ2

for

all

j,

j
ψ3

for

all

j

and

ψ4

are

propositional

formulas

of the form ψi = π with Ji ∈ S(Πaug) for all i ∈ {1, 4},

∀π ∈Ji

j
ψi

=

π with Jij ∈ S(Πaug) for all i ∈ {2, 3} and for all

∀π ∈Jij

j ∈ Ii.

Below we provide informal deﬁnitions of the speciﬁcations appearing in the above deﬁnition.
• φglobe: This type of speciﬁcation captures properties that must hold throughout the execution of the system. For

example, collision avoidance with obstacles must hold at all times when a robot is navigating in the workspace. • φreach: Speciﬁcations of this form capture ﬁnite time reachability requirements for the system. For example, a robot must reach a region of interest within a ﬁnite time. • φrec: This recurrence speciﬁcation captures, for instance, scenarios where the system must visit regions inﬁnitely often. For example, a robot must visit room A and room B inﬁnitely often. • φact: This type of speciﬁcation captures persistence requirements. For example, a robot must reach a region and then stay within the region for all time.
As compared to [38], we additionally incorporate reachability speciﬁcations (♦) without increasing the system complexity due to the abstraction free nature of our proposed framework. We do not include response-to-environment speciﬁcations ( (A =⇒ ♦B)) since time-varying or reactive system speciﬁcations are not considered in the context of our proposed barrier function framework. With regard to other widely used fragments, our proposed fragment allows for persistence (♦ ) which cannot be expressed by the Generalized Reactivity (GR(1)) fragment or computation tree logic (CTL) [39]. Our proposed fragment also allows for repetitive tasks (φact and φrec) which cannot be captured by the fragment considered in very recent work on barrier function based control using temporal logic [22], [23].
For any propositional formula ψ omitting temporal operators (e.g., a conjunction of literals) we deﬁne the following.

Deﬁnition 4 (Proposition Set). The proposition set for a propositional formula ψ, denoted ψ , is the set of all states that satisfy ψ. That is,

ψ = {x ∈ X | L(x) |= ψ}

(11)

where L(x) |= ψ signiﬁes that ψ is true under the evaluation for which all and only propositions in L(x) ⊂ Π are true.

We assume that for each atomic proposition π ∈ Π, there exists a continuously differentiable function h : X → R such that π = {x ∈ X |hπ (x) ≥ 0}. In this paper, similar to the assumption in [9], we assume that Lghπ (x) = 0 for all x ∈ X . We ignore the measure-zero set {x ∈ X |hπ (x) = 0}, and identify π = {x ∈ X |hπ (x) < 0} for each π ∈ Π. Thus we deﬁne hπ (x) = −hπ (x) for all π ∈ Π.
The fragment LT Lrobotic encompasses a class of speciﬁcations which cover properties such as ﬁnite time reachability,
persistence, recurrence, and invariance. These properties are
useful to express a number of common robotic system speci-
ﬁcations. Recall that for any σ ∈ 2Π, L−1(σ ) = {x ∈ X |σ = L(x)}.
We deﬁne a trace as a sequence of sets of atomic propositions. The trace of a trajectory x(t) of a continuous time dynamical
system is deﬁned as the sequence of propositions satisﬁed by
the trajectory. This is formalized in the deﬁnition below.

Deﬁnition 5 (Trace of a trajectory [40]). An inﬁnite sequence σ = σ0σ1 . . . where σi ⊆ Π for all i ∈ N is the trace of a

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

5

trajectory x(t) if there exists an associated sequence t0t1t2 . . . of time instances such that t0 = 0, tk → ∞ as k → ∞ and for each m ∈ N, tm ∈ R≥0 satisﬁes the following conditions:
• tm < tm+1 • x(tm) ∈ L−1(σm) • If σm = σm+1, then for some tm ∈ [tm,tm+1], x(t) ∈
L−1(σm) for all t ∈ (tm,tm), x(t) ∈ L−1(σm+1) for all t ∈ (tm,tm+1), and either x(tm) ∈ L−1(σm) or x(tm) ∈ L−1(σm+1). • If σm = σm+1 for some m, then σm = σm+k for all k > 0 and x(t) ∈ L−1(σm) for all t ≥ tm.
The last condition of the above deﬁnition implies that a trace contains a repeated set of atomic propositions only if this set is then repeated inﬁnitely often. This is useful to capture for example, a stability condition of the system. By forbidding repetitions in other cases, we ensure that a particular trajectory possesses a unique trace. This exclusion is without loss of generality since we only consider LT Lrobotic speciﬁcations without the next operator.
We now deﬁne the problem statement that is addressed in this paper.
Problem Statement. Given a speciﬁcation in LT Lrobotic as in (10) which is to be satisﬁed by a mobile robotic system with dynamics as in (1), synthesize a point-wise minimum norm controller as in (7) which produces a system trajectory whose trace satisﬁes the given speciﬁcation.
In this paper, we are interested in generating system trajectories using controllers of the form (7), which guarantee satisfaction of the given LTLrobotic speciﬁcation. As a secondary objective, we are interested in achieving the stated task by expending minimum power, point-wise in time. These objectives are captured by the problem statement.
Before we detail the theoretical framework to address the above problem statement, we discuss scenarios where the QP based controller (7) could be infeasible and present approaches to alleviate infeasibility. This is important since infeasibility can lead to violation of the LTL speciﬁcation.
IV. FEASIBILITY OF QP BASED CONTROLLER
Given a speciﬁcation φ in LT Lrobotic, in this section, we focus on scenarios where using existing methods in literature [9], [12], [41] will render the controller infeasible, and provide solutions for the same. Subsection A discusses Theorem 1 which appeared in our conference paper [13], while subsection B proposes a relaxed formulation of the QP based controller.
A. Composite Finite Time Control Barrier Functions
Consider two robots R1 and R2 as shown in the workspace in Fig 1. Suppose R1 is sensing information from R2 and hence must always stay within the sensing radius of R2. Suppose we have two regions of interest A, B and the base C. Let D represent a corridor in the state space (denoted by the dotted lines in Fig 1) where R1 must maintain a very small distance of connectivity with R2. This could represent, for example, an area with very poor network connectivity and hence the

robots must resort to communication over small distances. Let

the speciﬁcation for the multi-agent system be given as φ =

♦(π1A

∧

π2B

)

∧

♦(π

C 1

∧

π

C 2

)

∧

πconn where π1A is the proposition

that is true when R1 is in A, π2B is the proposition that is

true when R2 is in B, and πconn is the proposition that is true

when the robots must maintain connectivity at all times. In

other words, R1 must visit A, R2 must visit B and then both

must return to the base C. In addition, R1 must always stay

connected with R2. The workspace is as shown in Fig 1.

Figure 1: Representative trajectories for R1 and R2 that satisfy the speciﬁcation φ = ♦(π1A ∧ π2B) ∧ ♦(π1C ∧ π2C) ∧ πconn. The area with less connectivity is the corridor D. Observe that R1 and R2 need to maintain a small distance of connectivity within the corridor D.
By following the method proposed in [12], the QP that is to be solved is as follows:
min ||u||22
u∈R4
s.t L f hA(x1) + LghA(x1)u ≥ −γ · sign(hA(x1)) · |hA(x1)|ρ L f hB(x2) + LghB(x2)u ≥ −γ · sign(hB(x2)) · |hB(x2)|ρ
L f hconn(x) + Lghconn(x)u ≥ −α(hconn(x)) (12)
where α is a locally Lipschitz extended class κ function, γ > 0, ρ ∈ [0, 1), x1 is the state of R1, x2 is the state of R2, x = x1 x2 T is the total state of the system, hA is the FCBF which represents A, hB is the FCBF which represents B, and hconn is the ZCBF which dictates the connectivity radius to be maintained by R1 with R2. Note that [12] considers only reachability tasks and not more general LTL tasks. In addition, [12] requires multiple reachability speciﬁcations to be encoded as separate constraints in a QP, as discussed above.
However, this QP becomes infeasible at the point when R1 and R2 reach the corridor D. This is because the ﬁrst constraint in (12) dictates that R1 make progress towards A, but the third constraint dictates that R1 move closer to R2 and hence move away from A. This leads to an empty solution space thus rendering the QP infeasible. This shows that the above formulation of encoding multiple reachability objectives as individual constraints is too restrictive.
In light of the above scenario, we propose a method in which we compose multiple FCBFs. By ensuring that the total sum of the ﬁnite time barrier functions is always increasing, we

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

6

can allow for decrease in the values of some of the individual barrier functions thereby allowing some robots to move away from their desired sets temporarily. This provides a larger solution space for the QP. This is formalized in the following theorem.
Theorem 1. Consider a dynamical system in control-afﬁne form as in (1). Given Γ ⊂ X deﬁned by a collection of q ≥
q
1 functions {hi(x)}qi=1 such that Γ = {x ∈ X | hi(x) ≥ 0}
i=1
and for i = {1, 2, 3, ..., q } with q < q, hi(x) is bounded i.e. hi(x) < Mi for all x ∈ X , for Mi > 0.1 If there exists a collection {αi}qi=1 with αi ∈ R>0, parameters γ > 0, ρ ∈ [0, 1) and a continuous controller u(x) where u : X → Rm, such that for all x ∈ X
q
∑ αi(L f hi(x) + Lghi(x)u(x)) +
i=1
γ · sign min h1(x), h2(x), . . . , hq (x) ≥ 0 (13)

L f hi(x) + Lghi(x)u(x) + γ · sign(hi(x)) · |hi(x)|ρ ≥ 0 ∀ i ∈ q + 1, . . . , q (14)

then under the feedback controller u(x), for all initial conditions x0 ∈ D, there exists 0 < T < ∞ such that x(T ) ∈ Γ.

Proof. By contradiction, suppose for some x0 ∈ X \Γ the control law u(x) that satisﬁes (13) and (14) is such that there does not exist a ﬁnite time 0 < T < ∞ so that x(T ) ∈ Γ. In particular,

then for all t > 0, min h1(x(t)), h2(x(t)), . . . , hq(x(t)) < 0,
where x(t) is the solution to (1) initialized at x(0) under the control law u(x). By (14) for all t > Ti = |hγi((x10−)|ρ1−) ρ , we have hi(x(t)) ≥ 0 for all i = {q + 1, . . . , q} by Proposition 1. To that end, if we deﬁne T = max {Ti}, then for all t > T we
i=q +1,...,q

have, min h1(x(t)), h2(x(t)), . . . , hq (x(t)) < 0. In particular, observe that

∑ ∑ d q

q

αihi(x(t)) = αi(L f hi(x) + Lghi(x)u(x)) (15)

dt i=1

i=1

so that by integration of (15) using the fundamental theorem of calculus and (13), we have

q

q

∑ ∑ αihi(x(t)) ≥ γ · (t − T ) + αihi(x(T )) .

i=1

i=1

q

We observe that as t → ∞, ∑ αihi(x(t)) → ∞. But this is a

i=1

contradiction since hi(x(t)) for i = {1, 2 . . . , q } is bounded i.e.

q

q

∑ αihi(x(t)) < ∑ αiMi. Thus, there exists a 0 < T < ∞

i=1

i=1

q

such that x(T ) ∈ {x ∈ X | hi(x) ≥ 0}.

i=1

1If all the functions are bounded, then q = q and so we will have only (13) as a constraint in the QP ∀i ∈ {1, 2, . . . , q}

Theorem 1 allows a system to reach an intersection of multiple regions in the state space using a single barrier certiﬁcate constraint. In contrast, [12] proposes a more restrictive solution to the constrained reachability problem with desired level sets being individually deﬁned by multiple FCBFs in a QP. In particular, [12] proposes the set of control laws U given by

U(x) = {u ∈ Rm | L f hi(x) + Lghi(x)u + γ · sign(hi(x)) ≥ 0
∀i ∈ {1, . . . , q}}. (16)

Note that this is equivalent to taking q = 0 in Theorem 1. Deﬁne
U(x) = {u ∈ Rm | (13) and (14) are satisﬁed}, (17)
q
and Γ = {x ∈ X | hi(x) ≥ 0}. We then formulate the follow-
i=1
ing corollary.
q
Corollary 1. Under the hypotheses of Theorem 1 with ∑ αi ≥
i=1
1, the set U(x) deﬁned in (17) is a superset to the set U(x) deﬁned in (16). That is, U(x) ⊆ U(x) for all x ∈ X \Γ.

Proof. Note that for q = 0 and q = 1, it follows that U(x) = U(x). For any q ∈ {2, . . . , q − 1}, consider any u(x) ∈ U(x) applied to the system (1). Hence, we have that

L f hi(x) + Lghi(x)u(x) ≥ −γ · sign(hi(x(t))) ≥ γ αi(L f hi(x) + Lghi(x)u(x)) ≥ αi · γ

for all i ∈ {1, 2, . . . , q} since x ∈ X \Γ. Summing the inequalities for the barrier functions from i = 1, 2, . . . , q , we get

q

q

∑ ∑ αi(L f hi(x) + Lghi(x)u(x)) ≥ αi · γ ≥ γ

i=1

i=1

where the last inequality follows by assumption that
q
∑ αi ≥ 1. This implies u(x) satisﬁes (13) since
i=1

sign min h1(x), h2(x), . . . , hq (x) < 0 for all x ∈ X \Γ,

and L f hi(x) + Lghi(x)u(x) ≥ −γ · sign(hi(x(t))) for all i ∈ {q + 1, . . . , q} which implies u(x) also satisﬁes (14). Hence, u(x) ∈ U(x). Thus the corollary follows.

Theorem 1 allows for additional directions of evolution for the system state thereby resulting in a more relaxed approach to the ﬁnite time reachability problem. Corollary 1 provides an intuition regarding the key take-away from Theorem 1.

B. Prioritization of Zeroing Control Barrier Functions
In this subsection, we introduce a methodology for prioritizing different ZCBFs. In particular, our proposed formulation is similar to [35] where different tasks represented by multiple ZCBFs are prioritized for a multi-agent system. In particular, we stipulate that the performance objective dictated by the FCBFs must never be relaxed, and hence, they are encoded as hard constraints (i.e. constraints which must never be violated), whereas the ZCBFs can be relaxed and hence, they

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

7

are encoded as soft constraints (i.e. constraints which could potentially be violated). Our proposed method is different from [35] in the sense that, in addition to the ZCBFs, we also incorporate FCBFs which are treated as hard constraints in the QP based controller.
Consider the following motivating example. Suppose we have a goal region G = {x ∈ X |hG(x) ≥ 0} where hG : X → R is a FCBF, encapsulated by an obstacle O = {x ∈ X |hO(x) ≤ 0} where hO : X → R is a ZCBF. Suppose the speciﬁcation for the robot is φ = ♦G ∧ ¬O. By following the method proposed in existing works such as [10], [11], [3], [12], the QP that is to be solved is as follows:
min ||u||22
u∈Rm
s.t L f hG(x) + LghG(x)u ≥ −γ · sign(hG(x)) · |hG(x)|ρ (18)
L f hO(x) + LghO(x)u ≥ −α(hO(x))

where γ > 0, ρ ∈ [0, 1) and α is a locally Lipschitz extended class κ function.
However, since the goal is encapsulated by the obstacle, the two constraints are in conﬂict and hence the QP will be infeasible. In order to tackle scenarios such as the one above, we propose a relaxed formulation of the QP similar to the one in [9], [35].
Consider p ZCBFs and n FCBFs. Let P be the index sets for the zeroing barrier functions. Some or all of the ZCBFs may be in conﬂict with the composite FCBF. The generalized relaxed QP is of the form,

min

||u||2+ 1 ΞTW Ξ

v=

uT , ε1, . . . , εp

T
∈Rm+p

22

(19)

s.t (13) holds

L f hi(x) + Lghi(x)u(x) ≥ −αi(hi(x)) − εi , ∀i ∈ P

where Ξ = ε1, ε2, . . . , εp T ∈ Rp, W ∈ Rp×p is a diagonal matrix with the diagonal elements as (w1, w2, . . . , wp) where wi ∈ R>0 is a weight associated with the the slack variable εi for all i ∈ {1, 2, . . . , p}, and αi is a locally Lipschitz extended class κ function. The weight matrix W allows one to encode
the notion of “priority” for the barrier functions. For example,
if the weight wi corresponding to the slack variable εi is large, then then ith ZCBF has higher priority over other constraints.

Remark 2. Similar to the discussion in Remark 2 in [9], if the reachability and invariance constraints are not in conﬂict, then with an appropriate choice of the weight matrix W , we will have εi ≈ 0 for some i ∈ {1, 2, . . . , q}. Also, note that we extend the formulation provided in [9] from two constraints to multiple constraints.

The relaxed QP returns a control law that allows the system to reach the desired level set in a ﬁnite time while minimally violating the invariance constraints if there is a conﬂict with the FCBF. We present the following case study which uses the relaxation based controller (19).
1) Example: Consider an omnidirectional robot with dynamics x˙ = u where x ∈ X ⊂ R2, and u ∈ R2. Let D ⊂ X be a compact domain in the state space. The workspace is as shown in Fig 2. Suppose we have two unsafe regions

Figure 2: A family of trajectories for the robot generated by the relaxed QP (19). By changing the values of the entries in the weight matrix W , one can encode the notion of priority for different regions in the state space as can be seen from the various trajectories.
A and B and a goal region C. Let C be contained within A and B. Suppose the speciﬁcation to be satisﬁed by the robot is φ = ♦C ∧ (¬A ∧ ¬B). From Fig 2, we observe that satisfaction of φ is impossible without entering the regions A or B. However, suppose that region A has greater priority than region B and hence violation of B is allowed to some extent.
With this additional ﬂexibility, we can employ the proposed QP as in (19) with the weights wA ∈ R>0 set to be a large value and wB ∈ R>0 set to be a small value. We then solve (19) which gives us a family of trajectories (depending on the values of the weights wA and wB) of the robot as shown in Fig 2. Observe that with different weights wA and wB for the regions in the QP, we obtain a different trajectory. This allows one to also encode the notion of priority in the QP.
V. SYNTHESIS AND ANALYSIS OF QUADRATIC PROGRAM BASED CONTROLLER
In this section, we detail the theoretical framework which provides formal guarantees that the quadratic program (QP) based controller indeed produces a system trajectory that satisﬁes the given speciﬁcation. We also describe the methodology to synthesize the barrier funtion based QP controller given an LT Lrobotic speciﬁcation.
A. Lasso Type Constrained Reachability Objectives
It is well established that if there exists a trace that satisﬁes a speciﬁcation belonging to the fragment LT Lrobotic, then there exists a trace which satisﬁes the speciﬁcation in lasso or preﬁxsufﬁx form ( [15], pp 272), where a trace σ is in lasso form if it is comprised of a ﬁnite horizon preﬁx σpre and a ﬁnite horizon sufﬁx σsuff that is repeated inﬁnitely often. Both σpre and σsuff are ﬁnite sequences of sets of atomic propositions such that the trace σ is equal to the preﬁx followed by an inﬁnite repetition of the sufﬁx. Such a lasso-type trace is denoted as σ = σpre(σsuff)ω , where ω denotes inﬁnite repetition. Atomic propositions of a continuous time dynamical system are subsets of the domain, and, hence, it is possible to interpret such lasso traces as sequences of constrained reachability problems

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

8

in lasso form, which forms the basis of our control synthesis methodology. This is formalized in the following deﬁnitions.
Deﬁnition 6 (Constrained reachability objective). Given a target set Γ ⊂ X and a safety set Σ ⊂ X , the constrained reachability objective, denoted by R(Σ, Γ), is deﬁned as the reachability problem to be solved so that the state of the system reaches the set Γ in ﬁnite time while remaining in Σ until it reaches Γ.
The constrained reachability objective for a system (1) is solved from a given initial condition in Σ if a control policy is found which drives the state of the system to Γ while remaining in Σ until it reaches Γ. For example, a reachability objective denoted by R(B, A) signiﬁes that the system must reach region A in ﬁnite time while staying in region B until it reaches region A. The constrained reachability objective implies ﬁnding a control policy that solves the above objective successfully.
Deﬁnition 7 (Lasso Type Constrained Reachability Sequence). A lasso-type constrained reachability sequence is a sequence of constrained reachability objectives in lasso form such that each subsequent safety set is compatible with the prior goal set. That is, a lasso-type constrained reachability sequence has the form
ω
Rlasso = R1R2 . . . Rp Rp+1, Rp+2 . . . Rp+ , (20)

where p > 0, ≥ 1, and each R j = R(Σ j, Γ j) for some Γ j, Σ j ⊂ X satisfying Γ j ⊆ Σ j+1 for all j ∈ {1, 2, . . . , p + − 1} and Γp+ ⊆ Σp+1. The sequence (R1R2 . . . Rp) is a ﬁnite horizon preﬁx objective and (Rp+1, Rp+2 . . . Rp+ ) is a ﬁnite horizon sufﬁx objective that is repeated inﬁnitely often.

The lasso-type constrained reachability sequence is considered feasible if each constituent reachability objective is solved successfully in sequence. For example, consider the task speciﬁcation, “The robot must ﬁrst visit region A, then region B, while avoiding the obstacle C. The lasso-type reachability sequence that satisﬁes this task is given by

Rlasso = R1R2

ω
R3

where R1 = R(C, A), R2 = R(C, B) and R3 = R(C, 0/ ). Note that if p = 0, then the ﬁnite preﬁx has length zero and the lasso sequence is then given by

ω

Rlasso = R1, R2 . . . R .

(21)

By the preceding discussion, if there exists a trace that satisﬁes a given LT Lrobotic speciﬁcation, then there exists a lasso-type constrained reachability sequence which, if feasible, guarantees that the system satisﬁes the LT Lrobotic speciﬁcation. One can view the lasso type reachability sequence as a bridge between the LT Lrobotic speciﬁcation and the set based approach of our proposed controller.

B. Construction Of Lasso-type Reachability Sequence
Consider a LT Lrobotic speciﬁcation φ as in (10). Given φ , our ﬁrst objective is to generate the lasso-type constrained reachability sequence of the form (20).

Deﬁnition 8 (Lasso Template). Given a LT Lrobotic speciﬁcation φ , a lasso template is an enumeration of the form

O2 : {1, 2, . . . , k} → I2

(22)

O3 : {1, 2, . . . , } → I3

(23)

where the index sets I2 and I3 are as per Deﬁnition 3 and k = |I2| and = max{|I3|, 1}.

Note that it is computationally straightforward to obtain some lasso template simply by arbitrarily enumerating the elements of the index sets I2 and I3.
A lasso-type reachability sequence of the form (20) or (21) is constructed using Algorithm 1. The LT Lrobotic speciﬁcation, and the lasso template O2 and O3 are the inputs to Algorithm 1. The output is a lasso-type constrained reachability sequence of the form (20) or (21).

C. Synthesis of Quadratic Program based Controller
We next encode the reachability objectives as ﬁnite time and zeroing control barrier functions in a QP. This is described in Algorithm 2. Each Γi is encoded with FCBFs with (5) or (17) as constraint(s) whereas each Σi is encoded with ZCBFs with (3) as constraint(s) in the QP. The designer is free to choose a locally Lipschitz α function for (3). In order to solve a particular reachability objective Ri(Σi, Γi) where i ∈ {1, 2, . . . , n}, we solve a QP as in (7). Note that solving a QP in real time is typically done in a few milliseconds, and hence Algorithm 2 is amenable to real time implementation on robotic platforms.

D. Analysis Of Trajectory Generated by QP Controller
Observe that there is a one-to-one correspondence between elements of P(Πaug) and subsets of Π. Let ι : 2Π → P(Πaug) ⊂ 2Πaug be the canonical bijective mapping for a subset σ ∈ 2Π with the corresponding mapping ι(σ ) ∈ P(Πaug) given by,
π ∈ σ ⇐⇒ π ∈ ι(σ ) and π ∈ σ ⇐⇒ π ∈ ι(σ ). (24)
For notational convenience, we do not explicitly differentiate between a subset σ ⊂ Π and its mapping ι(σ ) ∈ P(Πaug).
Given Algorithm 2, we now provide formal guarantees which prove that the QP from Algorithm 2 indeed produces a system trajectory which satisﬁes the system speciﬁcation.
Deﬁnition 9 (Descendant). Given a LT Lrobotic speciﬁcation φ with a lasso template O2 and O3 as in Deﬁnition 8, a descendant of the lasso template is any inﬁnite length sequence of the form

σ = σ1,1σ1,2 . . . σ1,n1

σ2,1σ2,2 . . . σ2,n2 . . . σp,1σp,2 . . . σp,np . . . , (25)

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

Algorithm 1 Lasso-type Reachability Sequence Generator

Input : φ , O2, O3 Output: Rlasso

1: if J4 = 0/ then 2: p ← k + 1

3: if k = 0 then

4:

Γi = ψ2O2(i) for all i = 1, 2, . . . , p − 1

5:

Σi = ψ1 for all i = 1, 2, . . . , p − 1

6: end if

7: Γp = ψ4

8: Σp = ψ1

9: Γp+i = ψ3O3(i) for all i = 1, 2, . . . ,

10: if J1 = 0/ then

11:

Σp+i = ψ4 for all i = 1, 2, . . . ,

12: else

13:

Σp+i = ψ1 ∩ ψ4 for all i = 1, 2, . . . ,

14: end if

15: Ri = Ri(Σi, Γi) for all i = 1, 2, . . . , p + 16: return Rlasso as in (20) 17: else

18: p ← k

19: if p = 0 then

20:

Γi = ψ2O2(i) for all i = 1, 2, . . . , p

21:

Γp+i = ψ3O3(i) for all i = 1, 2, . . . ,

22:

Σi = ψ1 for all i = 1, 2, . . . , p +

23:

Ri = Ri(Σi, Γi) for all i = 1, 2, . . . , p +

24:

return Rlasso as in (20)

25: else

26:

Γp+i = ψ3O3(i) for all i = 1, 2, . . . ,

27:

Σp+i = ψ1 for all i = 1, 2, . . . ,

28:

Ri = Ri(Σi, Γi) for all i = 1, 2, . . . , p +

29:

return Rlasso as in (21)

30: end if

31: end if

Algorithm 2 Quadratic Program based Controller

Input : Rlasso

1: if p = 0 then

2: for i = 1, 2, . . . , p do

3:

Encode Γi with FCBFs

4:

Encode Σi with ZCBFs

5:

while x ∈/ Γi do

6:

Solve R(Σi, Γi) as in (7)

7:

end while

8: end for

9: end if

10: while true do

11: for i = p + 1, . . . , p + do

12:

Encode Γi with FCBFs

13:

Encode Σi with ZCBFs

14:

while x ∈/ Γi do

15:

Solve R(Σi, Γi) as in (7)

16:

end while

17: end for

18: end while

9
where σi, j ∈ P(Πaug) for all i = 1, 2, . . . , j = 1, 2, . . . , ni and
1) J1 ⊆ σi, j for all i ∈ {1, 2, . . . , p} and for all j ∈ {1, 2, . . . , ni}
2) J2O2(i) ⊆ σO2(i),nO2(i) for all i ∈ {1, 2, . . . , k} 3) J4 ⊆ σp,np 4) J3O3(i) ⊆ σm,nm where m = p + d + O3(i) for all d ∈
{0, 1, 2 . . . } and for all i ∈ {1, 2, . . . , } 5) J1 ∪ J4 ⊆ σi, j for all i ∈ {p + 1, . . . } and for all j ∈
{1, 2, . . . , ni}.
Intuitively, a descendant σ of a given template is a sequence of atomic propositions visited by the system such that it respects the safety sets Σi and also reaches the target sets Γi in a ﬁnite time for all i ∈ {1, 2, . . . , p + l}. Consider the example discussed before, where a robot must ﬁrst visit region A, then region B while avoiding the obstacle C. The lasso template for this task is O2(1) = A, O2(2) = B. Given this template, one valid instantiation of the descendant (25) is
ω
σ = {A¯, B¯,C¯}{A, B¯,C¯} {A¯, B¯,C¯}{A¯, B,C¯} {A¯, B,C¯} ,
which satisﬁes the conditions of Deﬁnition 9. In (25), each set σi = {σi,1σi,2 . . . σi,ni } corresponds to the
ith constrained reachability objective in the lasso sequence (20) or (21) and the set σp = {σp,1σp,2 . . . σp,np } is the last constrained reachability objective in the ﬁnite preﬁx part of the lasso sequence after which the sequence switches to the sufﬁx.
Proposition 3. Given a lasso template as in Deﬁnition 8 for a LT Lrobotic speciﬁcation φ as in (10), any descendant σ of this template is such that σ |= φ .
Proof. Let φ = φglobe ∧ φreach ∧ φrec ∧ φact be a speciﬁcation as in (10). Let O2 and O3 be a lasso template for the speciﬁcation. Let σ be a descendant of the lasso template as in Deﬁnition 9.
We provide a proof by construction by considering four individual cases for the speciﬁcation φ . Then, since conjunction preserves the results from these cases (Fig 5.2, pp 236 [15]), we combine them to provide a proof for the entire fragment of LTL. n
Case 1: Suppose φ = φglobe = ψ1 for ψ1 = πm, where
m=1
πm ∈ Πaug. Thus we have J1 = {π1, . . . , πn}, J2O2(i) = {0/ } for all i ∈ {1, 2, . . . , k}, J3O3(i) = {0/ } for all i ∈ {1, 2, . . . , } and J4 = {0/ }. A descendant trace of the template is as per Deﬁnition 9. Thus, from condition 1 in Deﬁnition 9 , we observe that J1 = {π1, . . . , πn} ⊆ σi, j for all i ∈ {1, 2, . . . } and for all j ∈ {1, 2, . . . , ni}. Hence, we can conclude that σ |= φglobe.
n
Case 2: Suppose φ = φact = ♦ ψ4 for ψ4 = πm where
m=1
πm ∈ Πaug. Thus we have J1 = {0/ }, J2O2(i) = {0/ } for all i ∈ {1, 2, . . . , k}, J3O3(i) = {0/ } for all i ∈ {1, 2, . . . , } and J4 = {π1, . . . , πn}. A descendant trace of the template has a closed form expression as in Deﬁnition 9. Thus, from condition 3 in Deﬁnition 9, we have J4 ⊆ σp,np , and from condition 5 in Deﬁnition 9, we observe that J4 = {π1, . . . , πn} ⊆ σi, j for all

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

10

i ∈ {p + 1, p + 2, . . . } and for all j ∈ {1, 2, . . . , ni}. Hence, we

can conclude that σ |= φact . Case 3: Suppose φ = φreach = ♦ψ2j. Thus we have
j∈I2
J1 = {0/ }, J3O3(i) = {0/ } for all i ∈ {1, 2, . . . , } and J4 = {0/ }. A
descendant trace of the template has a closed form expression

as in Deﬁnition 9. Thus, from condition 2 in the deﬁnition,

we observe that J2O2(m) = {π1, . . . , πn} ⊆ σO2(m),nO2(m) for all

m ∈ {1, 2, . . . , k}. Hence, we can conclude that σ |= φreach.

Case 4: Suppose φ = φrec =

♦ψ3j. Thus we have

j∈I3

J1 = {0/ }, J2O2(i) = {0/ } for all i ∈ {1, 2, . . . , k} and J4 = {0/ }.

A descendant trace of the template has a closed form ex-

pression as in Deﬁnition 9. Thus, from condition 4 in the deﬁnition, we observe that J3O3(q) = {π1, . . . , πn} ⊆ σm,nm for all m = p + dl + O3(q), for all d ∈ {0, 1, 2 . . . } and for all

q ∈ {1, 2, . . . , }. Hence, we can conclude that σ |= φrec.

Thus, by combining the results from Cases 1, 2, 3 and 4 with

conjunction [15] (Fig 5.2, pp 236 [15]), we can conclude that

σ satisﬁes φ = φglobe ∧ φreach ∧ φrec ∧ φact . That is, σ |= φ .

Next we state Theorem 2 which provides a theoretical guarantee that if Algorithm 2 is feasible, then the trace of the resulting system trajectory satisﬁes the speciﬁcation.

Theorem 2. Given a LT Lrobotic speciﬁcation φ and a lasso template O2 and O3 as in Deﬁnition 8, let Rlasso be the lassotype constrained reachability sequence as in (20) generated from Algorithm 1. If Algorithm 2 is feasible, then the trace of the system trajectory x(t) satisﬁes φ .

Proof. As per Algorithm 2, each Σi is encoded as constraint(s) with ZCBFs for all i ∈ {1, 2, . . . , p + }. From Proposition 1, this guarantees forward invariance of the atomic propositions that need to remain true or need to remain false. Since the QP from Algorithm 2 is feasible, conditions 1 and 5 from Deﬁnition 9 are satisﬁed. Since each Γi is encoded as constraint(s) with FCBFs for all i ∈ {1, 2, . . . , p + }, from Theorem 1 we can guarantee ﬁnite time convergence to atomic propositions that need to be reached in ﬁnite time. This satisﬁes conditions 2, 3 and 4 of Deﬁnition 9. Thus, all conditions in Deﬁnition 9 are satisﬁed. Since the QP is feasible, we conclude that Algorithm 2 generates a descendant σ of the lasso template.
From Proposition 3, we know that given a lasso template, any descendant σ of the lasso template is such that it satisﬁes the speciﬁcation. From the previous analysis, we know that the QP from Algorithm 2 produces a descendant of the lasso template. The mapping ι being bijective and combining Proposition 3 with the previous analysis, we can conclude that QP from Algorithm 2 produces a trace of the trajectory of the system that satisﬁes the given speciﬁcation. That is, ι−1(σ ) = σ |= φ .

Note that while Algorithm 2 and Theorem 2 assume that the QP (7) is feasible, one can always use the relaxed QP (19) for feasibility. In that case, although feasibility of the controller is more likely, Theorem 2 may no longer hold since the relaxation parameters ε can be non-zero so that the corresponding atomic propositions are no longer satisﬁed. However, such a situation is not considered in this paper.

VI. CASE STUDY
In this section, we provide a case study that details the barrier functions based QP framework which synthesizes a system trajectory that satisﬁes the speciﬁcation. This case study was implemented in the Robotarium multi-robot testbed at Georgia Tech [42]. The Robotarium consists of differential drive mobile robots which can be programmed using either MATLAB or Python.
Consider a team of three robots: one surveillance robot (R3) and two attack robots (R1 and R2). The surveillance robot needs to collect information regarding the position of two targets, and then return back to the base. Once the information has been relayed to the base by the surveillance robot, the attack robots must visit the targets inﬁnitely often. In addition to this, the attack robots must stay connected with each other at all times, and all the robots must avoid a danger zone where they can be attacked.
Let D ⊂ R2 be the workspace for each robot and let D ×D × D ⊂ R6 be the domain of the three robot system with regions A = {A, B, C, O}. The dynamics for each agent i ∈ {1, 2, 3} is

p˙1i  cos(φi)

p˙2i  = sin(φi)

φ˙i

0

0 0 vi , 1 ωi

where p1i ∈ R and p2i ∈ R represent the position of the robot, φi ∈ (−π, π] represents its orientation, vi ∈ R and ωi ∈ R are the linear and angular velocity inputs to the robot respectively. Denote xi = p1i pi2 φi T , and x¯i = p1i pi2 T . For implementation purposes in the Robotarium and theoretical reasons
associated with the unicycle robot as discussed in [43], we use
the NID technique discussed in [44] to control the differential
drive robots as a single integrator model. The NID technique
allows for control over both input to a differential drive robots
as discussed in [43].
Target 1 is labelled as A, target 2 is labelled as B the base is
labelled as C, and O is the danger zone (obstacle). The set of atomic propositions is given by Π = {πir, πri } ∪ {πconn, πconn} for all i ∈ {1, 2, 3} and r ∈ {A, B,C, O}. The regions A, B, C are deﬁned as πir = x ∈ D3|hr(xi) ≥ 0 for all r ∈ {A, B,C, O} and for all i ∈ {1, 2, 3}. For each πir with i ∈ {1, 2, 3}, r ∈ {A, B,C, O}, let

πir = 10 iofthx¯ei r∈wrise. (26)
This means πir = 1 if and only if agent i is in region r. The additional connectivity constraint that must be maintained by R1 and R2 is given as hconn(x) ≥ 0 where

hconn(x) = dc2onn(x) − ||x¯2 − x¯1||2,

(27)

where dconn : D × D × D → R is the connectivity distance between the two agents that needs to be maintained, and ||x¯2 − x¯1|| is the inter-agent distance. We consider

dc2onn(x) = (p12 + δ1)2 + δ2,

(28)

where δ1 and δ2 are constants. The connectivity set corresponding to the proposition πconn is deﬁned as πconn =
{x ∈ D3|hconn(x) ≥ 0}. Such a constraint captures a situation

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

11

in which the robots have poor connectivity in certain areas of the workspace, which requires them to maintain a closer distance with each other. In areas where the robots have strong connectivity, they are free to maintain a larger distance from each other.
The LT Lrobotic speciﬁcation for the task described previously is
φ = (♦π3A ∧ ♦π3B ∧ ♦π3C) ∧ ♦(π1A ∧ π2B) ∧ ♦(π1C ∧ π2C) ∧ (πconn ∧ ¬π1O ∧ ¬π2O ∧ ¬π3O). (29)
From the formalism in Deﬁnition 7 and Algorithm 1, we obtain the lasso-type constrained reachability objective,

As is discussed in [43], the computation complexity of strongly convex QPs, a class to which the proposed controller belongs to, is O((m + d)3) where m is the number of decision variables, and d is the number of constraints in the QP. This is the complexity of most commonly used solvers. In our experiments, we observed computation times in the order of 10-15 milliseconds for each QP. At all times, R1 and R2 stay connected as per the distance dictated by (27) and avoid the danger zone, as seen in Fig 3. Thus, we see that by solving this sequence of constrained reachability objectives, the multiagent system satisﬁes the speciﬁcation. Fig 3 is a still shot of the experiment conducted on the Robotarium testbed at Georgia Tech [42] 2 3

Rlasso = R1(Σ1, Γ1)R2(Σ2, Γ2)R3(Σ3, Γ3)

ω

R4(Σ4, Γ4)R5(Σ5, Γ5)

(30)

where Σi = πconn Γ1 = π3A , Γ2 = π1C ∩ π2C .

∩ π1O ∩ π2O ∩ π3O π3B , Γ3 = π3C , Γ4 =

for i = 1, 2, 3, 4, 5, π1A ∩ π2B , Γ5 =

R3

R1

P

Q

M

VII. CONCLUDING REMARKS
In this paper, we provided a framework for the control of mobile robotic systems with control afﬁne dynamics. In particular, we used control barrier functions and temporal logic as the tools to develop this framework. First, we discussed issues regarding feasibility of the QP based controller. We provided a new method to compose multiple FCBFs in order to obtain a larger feasible solution set as compared to existing methods in literature. We also proposed a modiﬁed QP based controller which prioritizes different ZCBFs. Second, we developed a fully automated framework which synthesizes a barrier function based controller given a speciﬁcation. Last, we provided formal guarantees that the QP based controller generates a system trajectory that satisﬁes the given speciﬁcation.

R2

Figure 3: A still shot of the trajectories for the robots R1, R2 and R3 for the speciﬁcation φ as in (29). Observe that R1 moves temporarily away from target 1 temporarily in order to satisfy the connectivity constraint dictated by (27) and (28), but Theorem 1 results in feasible solutions at those points. From the ﬁgure, we observe that the robots maintain connectivity and avoid the danger zone at all times.

Next, we use Algorithm 2 to generate the pointwise con-

troller for the system. Each reachability objective Ri(Σi, Γi)

for all i ∈ {1, 2, 3, 4, 5} is encoded as a QP and is solved

sequentially. In particular, if Ui(x) is the set of feasible control

laws that satisﬁes all the constraints for each reachability

objective, then for all i = {1, 2, 3, 4, 5} the QP solved is given

by,

min ||u||22

u∈R6

(31)

s.t u ∈ Ui(x).

From Theorem 2 we conclude that these trajectories indeed satisfy the speciﬁcation φ . The switching between the current reachability objective to the next is automatic. It occurs when the state of the system reaches the desired set of states. That is, the switching from reachability objective i to objective i + 1 occurs when x ∈ Γi for all i ∈ {1, 2, 3, 4}.

REFERENCES

[1] S. Chinchali, S. C. Livingston, U. Topcu, J. W. Burdick, and R. M.

Murray, “Towards formal synthesis of reactive controllers for dexter-

ous robotic manipulation,” in 2012 IEEE International Conference on

Robotics and Automation, May 2012, pp. 5183–5189.

[2] L. P. Kaelbling and T. Lozano-Pe´rez, “Hierarchical task and motion

planning in the now,” in 2011 IEEE International Conference on

Robotics and Automation, May 2011, pp. 1470–1477.

[3] L. Wang, A. D. Ames, and M. Egerstedt, “Safe certiﬁcate-based ma-

neuvers for teams of quadrotors using differential ﬂatness,” in 2017

IEEE International Conference on Robotics and Automation (ICRA),

May 2017, pp. 3293–3298.

[4] “Trustworthy cyber infrastructure for the power grid (tcip-g),” Mar

2019. [Online]. Available: https://www.dhs.gov/science-and-technology/

trustworthy-cyber-infrastructure-power-grid-tcip-g

[5] M. Simon, “Your ﬁrst look inside amazon’s robot warehouse of

tomorrow,” Jun 2019. [Online]. Available: https://www.wired.com/story/

amazon-warehouse-robots/

[6] [Online].

Available:

https://www.dhs.gov/cisa/

critical-infrastructure-sectors

[7] A. Forsgren, P. E. Gill, and M. H. Wright, “Interior methods for

nonlinear optimization,” SIAM review, vol. 44, no. 4, pp. 525–597, 2002.

[8] A. D. Ames, J. W. Grizzle, and P. Tabuada, “Control barrier function

based quadratic programs with application to adaptive cruise control,” in

53rd IEEE Conference on Decision and Control, Dec 2014, pp. 6271–

6278.

[9] X. Xu, P. Tabuada, J. W. Grizzle, and A. D. Ames, “Robustness of

control barrier functions for safety critical control,” arXiv preprint

arXiv:1612.01554, 2016.

[10] L. Wang, A. D. Ames, and M. Egerstedt, “Safety barrier certiﬁcates

for collisions-free multirobot systems,” IEEE Transactions on Robotics,

vol. 33, no. 3, pp. 661–674, June 2017.

2Video of Robotarium experiment -https://youtu.be/EK1Zxcg-eSE 3Code for Robotarium experiment- https://bit.ly/37QkOBS

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

12

[11] L. Wang, A. Ames, and M. Egerstedt, “Safety barrier certiﬁcates for heterogeneous multi-robot systems,” in 2016 American Control Conference (ACC), July 2016, pp. 5213–5218.
[12] A. Li, L. Wang, P. Pierpaoli, and M. Egerstedt, “Formally correct composition of coordinated behaviors using control barrier certiﬁcates,” in 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS). IEEE, 2018, pp. 3723–3729.
[13] M. Srinivasan, S. Coogan, and M. Egerstedt, “Control of multi-agent systems with ﬁnite time control barrier certiﬁcates and temporal logic,” in 2018 IEEE Conference on Decision and Control (CDC), Dec 2018, pp. 1991–1996.
[14] M. Maghenem and R. G. Sanfelice, “Barrier function certiﬁcates for forward invariance in hybrid inclusions,” in 2018 IEEE Conference on Decision and Control (CDC), Dec 2018, pp. 759–764.
[15] C. Baier and J.-P. Katoen, Principles of model checking, 2008.
[16] R. Alur, T. A. Henzinger, G. Lafferriere, and G. J. Pappas, “Discrete abstractions of hybrid systems,” Proceedings of the IEEE, vol. 88, no. 7, pp. 971–984, July 2000.
[17] C. Belta and L. C. G. J. M. Habets, “Controlling a class of nonlinear systems on rectangles,” IEEE Transactions on Automatic Control, vol. 51, no. 11, pp. 1749–1759, Nov 2006.
[18] M. Kloetzer and C. Belta, “A fully automated framework for control of linear systems from temporal logic speciﬁcations,” IEEE Transactions on Automatic Control, vol. 53, no. 1, pp. 287–297, Feb 2008.
[19] T. Wongpiromsarn, U. Topcu, and R. M. Murray, “Receding horizon temporal logic planning,” IEEE Transactions on Automatic Control, vol. 57, no. 11, pp. 2817–2830, Nov 2012.
[20] A. Bhatia, M. R. Maly, L. E. Kavraki, and M. Y. Vardi, “Motion planning with complex goals,” IEEE Robotics Automation Magazine, vol. 18, no. 3, pp. 55–64, Sep. 2011.
[21] G. E. Fainekos, A. Girard, H. Kress-Gazit, and G. J. Pappas, “Temporal logic motion planning for dynamic robots,” Automatica, vol. 45, no. 2, pp. 343–352, 2009.
[22] L. Lindemann and D. V. Dimarogonas, “Control barrier functions for signal temporal logic tasks,” IEEE control systems letters, vol. 3, no. 1, pp. 96–101, 2019.
[23] L. Lindemann and D. V. Dimarogonas, “Decentralized control barrier functions for coupled multi-agent systems under signal temporal logic tasks,” in 2019 18th European Control Conference (ECC), June 2019, pp. 89–94.
[24] V. Raman, A. Donze´, M. Maasoumy, R. M. Murray, A. SangiovanniVincentelli, and S. A. Seshia, “Model predictive control with signal temporal logic speciﬁcations,” in 53rd IEEE Conference on Decision and Control, Dec 2014, pp. 81–87.
[25] C. Belta and S. Sadraddini, “Formal methods for control synthesis: An optimization perspective,” Annual Review of Control, Robotics, and Autonomous Systems, 2019.
[26] Z. Liu, B. Wu, J. Dai, and H. Lin, “Distributed communicationaware motion planning for multi-agent systems from stl and spatel speciﬁcations,” in 2017 IEEE 56th Annual Conference on Decision and Control (CDC), Dec 2017, pp. 4452–4457.
[27] S. S. Farahani, R. Majumdar, V. S. Prabhu, and S. E. Z. Soudjani, “Shrinking horizon model predictive control with chance-constrained signal temporal logic speciﬁcations,” in 2017 American Control Conference (ACC), May 2017, pp. 1740–1746.
[28] D. Aksaray, A. Jones, Z. Kong, M. Schwager, and C. Belta, “Q-learning for robust satisfaction of signal temporal logic speciﬁcations,” in 2016 IEEE 55th Conference on Decision and Control (CDC), Dec 2016, pp. 6565–6570.
[29] D. Muniraj, K. G. Vamvoudakis, and M. Farhood, “Enforcing signal temporal logic speciﬁcations in multi-agent adversarial environments: A deep q-learning approach,” in 2018 IEEE Conference on Decision and Control (CDC). IEEE, 2018, pp. 4141–4146.
[30] P. Va´rnai and D. V. Dimarogonas, “Prescribed performance control guided policy improvement for satisfying signal temporal logic tasks,” CoRR, vol. abs/1903.04340, 2019. [Online]. Available: http: //arxiv.org/abs/1903.04340
[31] L. Lindemann and D. V. Dimarogonas, “Decentralized robust control of coupled multi-agent systems under local signal temporal logic tasks,” in 2018 Annual American Control Conference (ACC). IEEE, 2018, pp. 1567–1573.
[32] Y. V. Pant, H. Abbas, R. A. Quaye, and R. Mangharam, “Fly-by-logic: Control of multi-drone ﬂeets with temporal logic objectives,” in 2018 ACM/IEEE 9th International Conference on Cyber-Physical Systems (ICCPS), April 2018, pp. 186–197.

[33] Q. Nguyen and K. Sreenath, “Exponential control barrier functions for enforcing high relative-degree safety-critical constraints,” in 2016 American Control Conference (ACC), July 2016, pp. 322–328.
[34] W. Xiao and C. Belta, “Control barrier functions for systems with high relative degree,” 2019.
[35] G. Notomista, S. Mayya, S. Hutchinson, and M. Egerstedt, “An optimal task allocation strategy for heterogeneous multi-robot systems,” arXiv preprint arXiv:1903.08641, 2019.
[36] H. K. Khalil, Nonlinear systems, vol. 3. [37] Meng Guo, K. H. Johansson, and D. V. Dimarogonas, “Revising motion
planning under linear temporal logic speciﬁcations in partially known workspaces,” in 2013 IEEE International Conference on Robotics and Automation, May 2013, pp. 5025–5032. [38] E. M. Wolff, U. Topcu, and R. M. Murray, “Efﬁcient reactive controller synthesis for a fragment of linear temporal logic,” in 2013 IEEE International Conference on Robotics and Automation, May 2013, pp. 5033–5040. [39] H. Kress-Gazit, G. E. Fainekos, and G. J. Pappas, “Temporal-logic-based reactive mission and motion planning,” IEEE Transactions on Robotics, vol. 25, no. 6, pp. 1370–1381, Dec 2009. [40] T. Wongpiromsarn, U. Topcu, and A. Lamperski, “Automata theory meets barrier certiﬁcates: Temporal logic veriﬁcation of nonlinear systems,” IEEE Transactions on Automatic Control, vol. 61, no. 11, pp. 3344–3355, 2016. [41] A. D. Ames, X. Xu, J. W. Grizzle, and P. Tabuada, “Control barrier function based quadratic programs for safety critical systems,” IEEE Transactions on Automatic Control, vol. 62, no. 8, pp. 3861–3876, Aug 2017. [42] D. Pickem, P. Glotfelter, L. Wang, M. Mote, A. Ames, E. Feron, and M. Egerstedt, “The robotarium: A remotely accessible swarm robotics research testbed,” in 2017 IEEE International Conference on Robotics and Automation (ICRA), May 2017, pp. 1699–1706. [43] P. Glotfelter, I. Buckley, and M. Egerstedt, “Hybrid nonsmooth barrier functions with applications to provably safe and composable collision avoidance for robotic systems,” IEEE Robotics and Automation Letters, vol. 4, no. 2, pp. 1303–1310, April 2019. [44] R. Olfati-Saber, “Near-identity diffeomorphisms and exponential εtracking and ε-stabilization of ﬁrst-order nonholonomic SE(2) vehicles,” in Proceedings of the 2002 American Control Conference (IEEE Cat. No.CH37301), vol. 6, May 2002, pp. 4690–4695 vol.6.
Mohit Srinivasan is currently pursuing his PhD degree in Electrical and Computer Engineering (ECE) from Georgia Institute of Technology, Atlanta, Georgia, USA. He earned his Master of Science in Electrical and Computer Engineering from Georgia Tech and Bachelor of Technology in Electrial Engineering from Veermata Jijabai Technological Institute (V.J.T.I), Mumbai, India. He was previously a research intern at Landis+Gyr, Atlanta. His research interests are primarily in multi-agent systems, control theory, and robotics.
Samuel Coogan is an Assistant Professor at Georgia Tech in the School of Electrical and Computer Engineering and the School of Civil and Environmental Engineering. Prior to joining Georgia Tech in July 2017, he was an assistant professor in the Electrical Engineering Department at UCLA from 2015-2017. He received the B.S. degree in Electrical Engineering from Georgia Tech and the M.S. and Ph.D. degrees in Electrical Engineering from the University of California, Berkeley. His research is in the area of dynamical systems and autonomy and focuses on developing scalable tools for veriﬁcation and control of networked, cyber-physical systems with an emphasis on transportation systems. He received a CAREER award from NSF in 2018, a Young Investigator Award from the Air Force Ofﬁce of Scientiﬁc Research in 2018, and the Outstanding Paper Award for the IEEE Transactions on Control of Network Systems in 2017.

