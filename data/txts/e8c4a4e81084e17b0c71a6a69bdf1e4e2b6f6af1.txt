arXiv:2006.14150v1 [eess.AS] 25 Jun 2020

Sequence to Multi-Sequence Learning via Conditional Chain Mapping for Mixture Signals
Jing Shi1,2,∗, Xuankai Chang1,∗, Pengcheng Guo1,3,∗, Shinji Watanabe1†, Yusuke Fujita4, Jiaming Xu2, Bo Xu2, Lei Xie3
1Center for Language and Speech Processing, Johns Hopkins University 2Institute of Automation, Chinese Academy of Sciences (CASIA), Beijing, China 3ASLP@NPU, School of Computer Science, Northwestern Polytechnical University, Xi’an, China
4Hitachi, Ltd. Research & Development Group shijing2014@ia.ac.cn, xchang14@jhu.edu, pcguo@nwpu-aslp.org,
shinjiw@ieee.org , yusuke.fujita.su@hitachi.com
Abstract
Neural sequence-to-sequence models are well established for applications which can be cast as mapping a single input sequence into a single output sequence. In this work, we focus on one-to-many sequence transduction problems, such as extracting multiple sequential sources from a mixture sequence. We extend the standard sequence-to-sequence model to a conditional multi-sequence model, which explicitly models the relevance between multiple output sequences with the probabilistic chain rule. Based on this extension, our model can conditionally infer output sequences one-by-one by making use of both input and previously-estimated contextual output sequences. This model additionally has a simple and efﬁcient stop criterion for the end of the transduction, making it able to infer the variable number of output sequences. We take speech data as a primary test ﬁeld to evaluate our methods since the observed speech data is often composed of multiple sources due to the nature of the superposition principle of sound waves. Experiments on several different tasks including speech separation and multi-speaker speech recognition show that our conditional multi-sequence models lead to consistent improvements over the conventional non-conditional models.
1 Introduction
Many machine learning tasks can be formulated as a sequence transduction problem, where a system provides an output sequence given the corresponding input sequence. Examples of such tasks include machine translation, which maps text from one language to another, automatic speech recognition (ASR), which receives a speech waveform and produces a transcription, and video captioning, which generates the descriptions of given video scenes. In recent years, the development of neural sequenceto-sequence (seq2seq) models [8, 38] with attention mechanisms has led to signiﬁcant progress in such tasks [2, 49, 42, 46, 9, 5].
In reality, the observed data contains various entangled components, making the one-to-many sequence transduction for mixture signals a common problem in machine learning [35, 16, 30]. This problem often happens in audio and speech processing due to the sequential properties and superposition principle of sound waves. For example, given the overlapped speech signal, speech separation is a problem of extracting individual speech sources, and multi-speaker speech recognition is a problem
∗equal contribution †corresponding author
Preprint. Under review.

of decoding transcriptions of individual speakers. This type of problem is called the cocktail party problem [7, 3]. The existing methods to tackle this common sequence-to-multi-sequence problem can be roughly divided into two categories according to the correlation strength of multiple output sequences: serial mapping and parallel mapping. Serial mapping aims to learn the mappings through

(a) Serial Mapping
e.g., wav  speech recognition  machine translation  text

Input Sequence

Output Sequence 1

Output Sequence 2

(b) Parallel Mapping e.g., mixture wav  separated sources

Input Sequence

Output Sequence 1
Output Sequence 2

(c) Conditional Chain Mapping

Input Sequence

Output Sequence 1
Output Sequence 2

Figure 1: Sequence-to-multi-sequence mapping approaches. (a) and (b) shows the serial mapping and parallel mapping used by existing methods respectively, and (c) refers to our Conditional Chain mapping strategy.

a forward pipeline, as shown in Figure 1(a). With the serial form, the output sequence of the ﬁrst seq2seq model is fed into the following seq2seq model to output another sequence. This method is quite common when the logic and relationship between different output sequences are straightforward. For example, a cross-lingual speech translation system contains two components: speech recognition and machine translation. Serial mapping ﬁrst recognizes the speech into the source language text and then use another model to translate it into the target language text. However, serial mapping methods usually suffer from some drawbacks. First, many of them need to be trained separately for different components, without taking advantage of the raw input information in the latter components. And the error accumulation through the pipeline will make the system suboptimal. The other category is parallel mapping, as shown in Figure 1(b), which simultaneously outputs multiple sequences. This method is often used when the outputs are from the same domain. Speech separation and multi-speaker ASR are typical examples following this paradigm. Similar to serial mapping, parallel mapping could not effectively model the inherent relationship that exists between different outputs, and usually assumes the number of the output sequence is ﬁxed (e.g., the ﬁxed number of speakers in speech separation tasks), which limits its application scenarios.
In this paper, we propose a new uniﬁed framework aiming at the sequence-to-multi-sequence (seq2Mseq) transduction task, which can address the disadvantages of both the serial mapping and parallel mapping methods. For clarity, we refer to our methods as Conditional Chain (CondChain) model, combining both the serial mapping and parallel mapping with the probabilistic chain rule. Simultaneous modeling for these two methods not only makes the framework more ﬂexible but also encourages the model to automatically learn the efﬁcient relationship between multiple outputs.
To instantiate the idea, as shown in Figure 1(c), we assume that the input sequence O can be mapped into N different sequences si, i ∈ {1, .., N }. We take sequence O as the primary input for every output sequence. Meanwhile, the outputs will be generated one-by-one with the previous output sequence as a conditional input. We consider that the multiple outputs from the same input have some relevance at the information level. By combining both the serial and parallel connection, our model learns the mapping from the input to each output sequence as well as the relationship between the output sequences.
In this paper, we introduce the general framework in Section 2, and present a speciﬁc implementation for the tasks of speech separation and recognition in Section 3. We discuss some related work in Section 4 and describe our experiments in Section 5, and ﬁnally conclude in Section 6. Our source code will be available on our webpage: https://demotoshow.github.io/.

2 General framework
We assume that the input sequence O ∈ O with length of T can be mapped into N different sequences si, i ∈ {1, .., N }, where the output index i represents a particular domain Di. All the output sequences form a set S = {si | i ∈ {1, ..., N }}. The basic formulation of our strategy is to estimate the joint probability of multiple output sequences, i.e., p(S|O). The joint probability is factorized into the product of conditional probabilities by using the probabilistic chain rule with/without the conditional

2

independence assumption (denoted by ·), as follows:

 p(s1|O)

N i=2

p(si

|si−1

,

O,

si−2

,

...,

s1

)

serial mapping



p(S|O) =

N i=1

p(si

|O

,

si−1

,

...,

s1

)

parallel mapping

(1)

 

N i=1

p(si

|O

,

si−1

,

...,

s1

)

conditional chain mapping

where, we also present the formulation of serial mapping and parallel mapping for comparison. As

shown in Eq. 1, the serial mapping methods adopt a ﬁxed order and the conditional distributions

are only constructed with sequence from the previous step, i.e., p(S|O) = p(s1|O)

N i=2

p(si

|si−1

).

As a contrast, parallel mapping simpliﬁes the joint distribution by the conditional independence

assumption, which means all the output sequences are only conditioned on the raw input, i.e.,

p(S|O) = p(si|O). For our conditional chain mapping, we manage to explicitly model the

inherent relevance from the data, even if it seems very independent intuitively. To achieve this, we

depart from the conditional independence assumption in parallel mapping or the Markov assumption

in serial mapping. Instead, with the probabilistic chain rule, our method models the joint distribution

of output sequences over an input sequence O as a product of conditional distributions. We can also

apply the same methodology to the non-probabilistic regression output (e.g., speech separation).

In our model, each distribution p(si|O, si−1, ..., s1) in Eq. 1 is represented with a conditional encoderdecoder structure. Different from the conventional one-to-one sequence transduction for learning the mapping O → Di, additional module in our model preserves the information from previous target sequences and takes it as a condition for the following targets. This process is formulated as follows:

Ei

=

Encoderi(O)

∈

R

DiE

×T

E i

,

(2)

Hi = CondChain(Ei, ˆsi−1) ∈ RDiH×T H ,

(3)

ˆsi = Decoderi(Hi) ∈ DiTi ,

(4)

where, all the Di symbols are the number of dimensions for the features, and TiE, TiH , Ti represent the size of temporal dimension. In the above equations, Encoderi and Decoderi refer to the speciﬁc networks designed for learning the mapping for the reference sequence si. Note that the Encoderi and Decoderi here may also consist of linear layers, attention mechanism or other neural networks besides the standard RNN layer, so the lengths of the hidden embeddings Ei and the estimation sequence ˆsi may vary from the input, i.e., TiE, TiH , Ti may not equal the T . For the i-th output, the Ei in Encoder gets a length of TiE while the ˆsi should get the same length with the reference si ∈ DiTi , where Ti is the length of the sequence si from domain Di. Different from the conventional seq2seq model, we utilize a conditional chain (CondChain in Eq. 3) to store the information from
the previous sequences and regard them as conditions. This conditional chain is analogous to the
design of memory cell in the LSTM model and the key component to realize Figure 1(c). Similarly,
the conditional chain in Eq. 3 does not serve a speciﬁc target domain alone, it models some uniﬁed
information for multi-sequence outputs. In other words, the encoder-decoder is specialized for each target sequence, but the conditional chain is shared by all the transduction steps i.

For most situations, when the logic and relationship between different output sequences is straightforward, we could set a ﬁxed ordering of the outputted sequence, like the cross-lingual speech translation showed in Figure 1(a). Differently, for the outputs from the same domain, i.e., Di = Dj, i = j, the Encoder and Decoder for each step could be shared with the same architecture and parameters, which yields less model parameters and better efﬁciency for training.

3 Implementation for speech processing
This section describes our implementation of the proposed conditional chain model by using speciﬁc multi-speaker speech separation / recognition tasks as examples. Both of them are typical examples of seq2Mseq tasks with input from mixture signals.
3.1 Basic model
Multi-speaker speech separation / recognition aims at isolating individual speaker’s voices from a recording with overlapped speech. Figure 2 shows the network structure under our conditional chain mapping for these two tasks. For both of them, the input sequence is from the speech domain. Let us

3

𝒔𝒔0 𝑺�𝑺1 Prediction 1 𝑺�𝑺2 Prediction 2 Silent Wav

Prediction 3 𝑺�𝑺3

𝒔𝒔0

Prediction 1

<blank> Seq 𝑺�𝑺1 Token Seq 1

Prediction 2 𝑺�𝑺2
Token Seq 2

Prediction 3 𝑺�𝑺3 <blank> Seq

Dec

Dec

Dec
STOP

Dec

Dec

Dec STOP

Enc

Enc

𝐇𝐇𝟏𝟏

𝐇𝐇𝟐𝟐

LSTM

LSTM

Enc 𝐇𝐇𝟑𝟑
LSTM

Embed

𝐇𝐇𝟏𝟏 LSTM

Embed

𝐇𝐇𝟐𝟐 LSTM

Embed

𝐇𝐇𝟑𝟑 LSTM

Fusion

Fusion

Fusion

Fusion

Fusion

Fusion

𝑂𝑂

Mixture Wav

Enc

𝐄𝐄
Separator

Conditional Connection

(a) Conditional Chain Model for speech separation

CondChain

𝐄𝐄

𝑂𝑂

Mixture Wav

Enc

(b) Conditional Chain Model for multi-speaker recognition

Figure 2: Sequence-to-multi-sequence mapping with conditional model for multi speaker speech separation or recognition. In each sub-ﬁgure, the block with same name are all shared.

ﬁrst assume this to be an audio waveform O ∈ RT . Another common feature for these two tasks lies in that the output sequences are from the same domain (Di = Dj, i = j), which means we could use a shared model at each step, i.e., Encoderi in Eq. 2 and Decoderi in Eq. 4 are respectively the same networks with different i.
For speech separation, the target sequences si ∈ RT are all from the same domain as the input, i.e., Di = O, and with the same length of the input mixture. Thus, we could use an identical basic Encoder (Enc in Figure 2(a)) to extract acoustic features from the input waveform O and predicted waveform sˆi. As a contrast, multi-speaker speech recognition outputs a predicted token sequence si ∈ VT with token vocabulary V. We introduce an additional embedding layer, Embed, to map these predicted tokens as continuous representations, which is used for conditional representation. In speech separation, as illustrated in Figure 2(a), both the mixed audio and the predicted source will go through an Encoder (Enc) to extract some basic auditory features. For the mixture waveform O, another separator (Separator) will also be used as the function to learn some hidden representation which is suitable for separation. And both the Enc and the Separator form the process in Eq. 2. For the Fusion block, due to the same lengths from input and output, a simple concatenation operation is used to stack the feature dimension for each frame. For the CondChain in Eq. 3, we use a unidirectional LSTM. At each source step i, the Decoder (Dec) is used to map the hidden state Hi into the ﬁnal separated speech source. Multi-speaker ASR is also performed in a similar form, as illustrated in Figure 2(b). Note that we use connectionist temporal classiﬁcation (CTC) [12] as a multi-speaker ASR network, since CTC is simple but yet powerful end-to-end ASR, and also the CTC output tokens without removing blank and repetition symbols can have the same length with the auditory feature sequence. Thus, we can realize the Fusion processing with a simple concatenation operation, similarly to speech separation.
3.2 Stop criterion
One beneﬁt of the conventional seq2seq model is the ability to output a variable-length sequence by predicting the end of the sequence ( EOS symbol) as a stop criterion. This advantage is inherited in our model to tackle the variable numbers of multiple sequences. For example, current speech separation or recognition models are heavily depending on a ﬁxed number of speakers [19] or require extra clustering steps [13]. Thanks to the introduction of the above stop criterion, we can utilize the mixture data with various numbers of speakers during training, and can be applied to the case of unknown numbers of speakers during inference.
In our implementation, when we have the total number of output sequences as N , we attach an extra sequence to reach the stop condition during training. The target of this last sequence prediction for both speech separation and recognition tasks must be the silence, and we use the silent waveform and silent symbol (an entire blank label sequence in CTC), respectively.
4

3.3 Training strategy with teacher-forcing and ordering
Like the conventional seq2seq approach [2], we use a popular teacher-forcing [45] technique by exploiting the ground-truth reference as a conditional source si−1. Teacher-forcing provides proper guidance and makes training more efﬁcient, especially at the beginning of the training, when the model is not good enough to produce reasonable estimation. Considering the unordered nature of multiple sources in multi-speaker speech separation or recognition, we adopt a greedy search method to choose the appropriate permutation of the reference sequences. This method achieves good performance in practice while maintaining high efﬁciency. More details about teacher-forcing and reference permutation search could be found in Section B in the Appendix.
4 Related Work
Speech Separation As the core part of the cocktail party problem [7], speech separation draws much attention recently [13, 15, 51, 19, 23, 20, 21, 24]. The common design of this task is to disentangle overlapped speech signals from a mixture speech with a ﬁxed number of speakers, which is a typical example of the sequence-to-multi-sequence problem. Most existing approaches in this area follow the Parallel-mapping paradigm mentioned in Section 1, trained with permutation invariant training (PIT) technique [51]. This design should know the number of speakers in advance and could only tackle the data with the same number of speakers [34]. These constraints limit their application to real scenes, while our proposed structure can provide a solution to the variable and unknown speaker number issues. This study is inspired by recurrent selective attention networks (RSAN) [18], which has been proposed to tackle the above variable number of speakers in speech separation by iteratively subtracting a source spectrogram from a residual spectrogram. Similar ideas have also been proposed in time-domain speech separation [39] and speaker diarization [10]. However, the RSAN is based on the strong assumption of acoustic spectral subtraction in the time-frequency domain, and its application is quite limited. On the other hand, our conditional chain model reformulates it as a general sequence to multi-sequence transduction problem based on the probabilistic chain rule, which is applicable to the other problems including multi-speaker ASR than time-frequency domain speech separation. In addition, the relevance between current estimation and the former is learned by a conditional chain network in Eq. 3, which is more ﬂexible and even applied to time-domain speech separation, making it totally end-to-end transduction from waveform to waveforms.
Multi-speaker speech recognition Multi-speaker speech recognition [44, 50, 31, 33], which aims to directly recognize the texts of each individual speaker from the mixture speech, has recently become a hot topic. Similar to the speech separation task, most of the previous methods follow the parallel mapping paradigm mentioned in Section 1. These methods could only tackle the data with the ﬁxed number of speakers and require external speaker counting modules (e.g., speaker diarization [40, 1, 32]), which lose an end-to-end transduction function, unlike our proposed method.
5 Experiments
We tested the effectiveness of our framework with speech data as our primary testing ground, where the sequence mapping problem is quite common and important. To be speciﬁc, the following sections describe the performance of our conditional chain model towards multi-speaker speech separation and speech recognition tasks, compared to other baselines. Furthermore, we also evaluated a joint model of speech separation and recognition, using multiple conditions from both waveform and text domains. In the Section A of Appendix, we provide the implementation details about all our experiments, and we also extend our model to one iterative speech denoising task in Section 5.5.
5.1 Datasets
For the speech mixtures, i.e., the input O for our tasks, with different numbers of speakers, data from the Wall Street Journal (WSJ) corpus is used by us. In the two-speaker scenario, we use the common benchmark called WSJ0-2mix dataset introduced by [13]. The 30 h training set and the 10 h validation set contains two-speaker mixtures generated by randomly selecting speakers and utterances from the WSJ0 training set si_tr_s, and mixing them at various signal-to-noise ratios (SNRs) uniformly chosen between 0 dB and 10 dB. The 5 h test set was similarly generated using utterances from 18 speakers
5

Frequency Amplitude Frequency Amplitude Frequency Frequency Frequency Frequency Frequency Frequency Frequency Frequency

(a) Mixture Sample 1 of Four Speakers

Spk1

Spk2

Spk3

Spk4

(b) Spectrogram of Mixture Sample 1

(mix1-1) Estimation of Spk1 from Mixture Sample 1

(mix1-2) Estimation of Spk2 from Mixture Sample 1

(mix1-3) Estimation of Spk3 from Mixture Sample 1

(mix1-4) Estimation of Spk4 from Mixture Sample 1

(c) Mixture Sample 2 of Four Speakers

Spk1

Spk2

Spk3

Spk4

(d) Spectrogram of Mixture Sample 2

(mix2-1) Estimation of Spk1 from Mixture Sample 2

(mix2-2) Estimation of Spk2 from Mixture Sample 2

(mix2-3) Estimation of Spk3 from Mixture Sample 2

(mix2-4) Estimation of Spk4 from Mixture Sample 2

Time

Time

Time

Figure 3: Visualization of two examples (mix1&mix2) with 4-speaker mixture from our WSJ0-4mix testset. For the mixture, both the waveform and spectrogram are showed. More examples and audios are available on our webpage: https://demotoshow.github.io

Table 1: Performance for speech separation on WSJ0-mix dataset, compared with the same base model and SOTA methods. The ∗ means the same base model with identical settings and hyper-
parameters. The N in WSJ0-N mix means the dataset with ﬁxed N speakers. All the "multiple
architectures" based methods are trained speciﬁcally towards each speciﬁc N .

Methods
RSAN [18] OR-PIT [39] TasNet [21] Our implemented TasNet∗ [48] ConvTasNet [27]
Conditional TasNet∗
DPRNN [27] Voice Separation [27]

Training Data
WSJ0-2mix WSJ0-2&3mix WSJ0-N mix WSJ0-N mix WSJ0-N mix
WSJ0-2mix WSJ0-3mix WSJ0-2&3mix WSJ0 2-5 mix
WSJ0-N mix WSJ0-N mix

Training with variable number
of speakers ×
× × × × ×
× ×

Single architecture or
multiple architectures
single single multiple multiple multiple single single single single
multiple multiple

Eval (OC) SI-SNRi in WSJ0-Nmix
2mix 3mix 4mix 5mix

8.8

-

-

-

14.8 12.6 10.2 -

14.6 11.6 -

-

15.4 12.8 -

-

15.3 12.7 8.5 6.8

15.6 -

-

-

12.7 13.3 -

-

16.3 13.4 -

-

16.7 14.2 12.5 11.7

18.8 14.7 10.4 8.4 20.1 16.9 12.9 10.6

from the WSJ0 validation set si_dt_05 and evaluation set si_et_05. For three-speaker experiments, similar methods are adopted except the number of speakers is three. The WSJ0-2mix and WSJ0-3mix datasets have become the de-facto benchmarks for multi-speaker source separation, and we compare our results to alternative methods. Besides the separation task, we also instantiate our conditional chain model on multi-speaker speech recognition with the same WSJ0-2mix dataset.
5.2 Multi-speaker speech separation
First, we investigate the application of our conditional chain model to speech separation benchmarks. We take TasNet as the main base model in Figure 2(a), which is a simple but powerful de-factostandard method in speech separation. Table 1 reports the results with different training settings (the number of speakers), compared with the same base model. By following the convention of this benchmark, we use the downsampled 8 kHz WSJ0-2mix set to reduce the memory consumption of separation. We retrained the TasNet with the same settings and hyper-parameters from an open

Table 2: The estimation counting results on WSJ0-mix test set with variable number of speakers (2 to
5 in our experiments). The overall accuracy of the counting is 94.8%. Here we set the threshold of the energy value per frame in the estimated speech as 3 × 10−4 to judge whether to stop the iteration.

Ref Est 2 3 4 5 6 Sum Acc (%)

2

2961 39

0

0 0 3000 98.7

3

12 2884 104 0 0 3000 96.1

4

0

42 2658 300 0 3000 88.6

5

0

0 125 2875 0 3000 95.2

6

Table 3: WER (%) for multi-speaker speech recognition on WSJ0-N mix-16 kHz dataset.

Methods
(1) DPCL + GMM-HMM [15] (2) PIT-DNN-HMM [28]
(3) DPCL + DNN-HMM [26] (4) PIT-RNN [6]
(5) PIT-Transformer
(6) PIT-Transformer (7) Conditional-Chain-Transformer (8) Conditional-Chain-Transformer

System
HMM HMM HMM Attention-based Attention-based
CTC CTC CTC

Training Data
WSJ0-2mix WSJ0-2mix WSJ0-2mix WSJ0-2mix WSJ0-2mix
WSJ0-2mix WSJ0-2mix WSJ0-1&2&3mix

WER WSJ0-2mix WSJ0-3mix

30.8%

-

28.2%

-

16.5%

-

25.4%

-

17.7%

-

31.2% 24.7% 14.9%

37.9%

source implementation [48]. It should be noticed that the TasNet and most speech separation methods could only be trained and used in the same number of speakers, while our conditional chain model removes this limitation. In terms of the architecture of the model, we only added a single layer of LSTM compared with the base model, resulting in a negligible increase in the number of parameters.
The scale-invariant source-to-noise ratio improvement (SI-SNRi) results from Table 1 show that our conditional strategy achieves better performance than the base model (TasNet) under the same conﬁguration. For the ﬁxed number of speakers (2 or 3), our model improves on the original results, especially when there are more speakers (0.2 dB gains in WSJ0-2mix while 0.5 dB in WSJ0-3mix). Moreover, thanks to the chain strategy in our model, the WSJ0-2&3 mix datasets could be concurrently taken to train the model, and the performance is better than the training with each dataset. Compared with the RSAN [18] and OR-PIT [39] as mentioned in Section 4, which also could handle variable number of sources, our model achieves signiﬁcant performance improvements as a result of our end-to-end speech transduction in time domain. To further verify the upper limit that our model can reach with more speakers in speech separation task, we remixed two datasets, which we refer to as WSJ0-4mix and WSJ0-5mix, by simply concatenating the given mixture list from the standard WSJ0-2&3mix. As we expect, without adding any additional speech sources, the performance trained with WSJ0-2to5mix gains further improvement in WSJ0-2&3 mix and get reasonable SI-SNRi results in even 4 and 5 speaker mixtures.
Besides the baseline models related to our methods, we also report the results from two strong works, i.e., DPRNN[24] and Voice Separation [27], which two upgrade the model architecture from the TasNet. Especially, Voice Separation [27] achieves the SOTA results in speech separation. However, their methods require multiple models (or multiple submodels in [27]) for each number of speakers in advance, which import additional model complexities or training procedures, and also cannot be applied to more speakers than the training setup. Even though, with the suboptimal base model (TasNet), our conditional chain model gets better results in 5 speaker mixtures. And we could clearly observe that as the number of speakers increases, our model achieves less performance degradation. We expect to realize further gains with our conditional chain model by improving the base models to DPRNN or Vocice Separation, which will be a part of our future work.
Furthermore, Table 2 reports the estimation counting accuracy with the trained WSJ0 2-5mix datasets. Here, we set the threshold of the energy value per frame in the estimated speech as 3 × 10−4 to judge whether to stop the iteration, resulting in the overall accuracy of 94.8%, which is signiﬁcantly better than the Voice Separation [27] (≤ 62%). It is worth mentioning that the upper bound of speaker number was set as 5 in our trained model, so there is a strong tendency to predict silence at the 6-th step (similar with the observation from RSAN [18]), leading to higher accuracy for 5-speaker mixtures than the 4-speaker ones. We also visualize two examples from the WSJ0-4mix test set in Figure 3, where we observe clear spectrograms with the estimated sources from pretty tangled mixtures.

5.3 Multi-speaker speech recognition
Second, we evaluate our proposed method on the multi-speaker speech recognition task with the same WSJ0-mix corpus. We use the Transformer [41] as the basic Enc architecture block in Figure 2(b) to build speech recognition models, optimized with the CTC criterion [12]. Unlike the separation experiment in Section 5.2, which used 8 kHz, this section used the sampling rate as 16 kHz, which is the default setup for ASR to achieve better performance like most other previous works. An LSTMbased word-level language model with shallow fusion is used during decoding [14]. We compare our

7

Table 4: SI-SNRi (dB) and WER (%) for multi-speaker joint training on WSJ0-mix-8 kHz dataset.

Methods
Conditional TasNet + Pre-trained ASR + With Multiple Condition + With Joint Training + With Multiple Condition

Finetune Part
Separation Separation, ASR Separation, ASR

Condition
Wave Wave + CTC
Wave Wave + CTC

Training Data
WSJ0-2mix WSJ0-2mix WSJ0-2mix WSJ0-2mix

WSJ0-2mix SI-SNRi WER

15.2 dB 15.5 dB 12.0 dB 10.3 dB

25.1% 17.2% 15.3% 14.4%

conditional chain Transformer-based CTC with the other systems including the HMM systems (1): deep clustering (DPCL)+GMM-HMM [15], (2): PIT-DNN-HMM [28] , and (3): DPCL+DNN-HMM [26], and the attention-based systems (4): PIT-RNN [6] and (5): PIT-Transformer. Note that all the PIT based methods correspond to the parallel mapping method in Figure 1(b), and they cannot deal with variable numbers of speakers.
We compare the effectiveness of the proposed conditional chain models with the same CTC architecture based on PIT in Table 3. Our conditional-chain Transformer (7) is signiﬁcantly better than the corresponding PIT based system (6). Furthermore, the proposed conditional chain model can straightforwardly utilize the mixture speech data that has a variable number of speakers. To show this beneﬁt, we train our model using the combination of the single and multi-speaker mixture WSJ0 training data. It can be seen that the conditional chain model trained with the combination of 1, 2 and 3-speaker speech (8) achieves the best WERs, 14.9%, on the 2-speaker mixture evaluation set among all the other systems including (1) – (7). Also, the proposed method can be applied to the 3-speaker mixture evaluation set and achieves reasonable performance (37.9%) in this very challenging condition. This result is consistent with the observation in the speech separation experiment in Section 5.2. Interestingly, by analyzing the hypothesis generation process, we found that the speaker with the longest text is predicted ﬁrst generally, described in Section C in the Appendix.

5.4 Cross-domain condition in joint separation and recognition

𝒔𝒔0
Silent Wav

<blank> Seq

ASR
Prediction Wav 1
𝑺�𝑺1

Dec

Token Seq 1

ASR
Prediction Wav 2
𝑺�𝑺2

Dec

Token Seq 2

Prediction Wav 3
𝑺�𝑺3

STOP

Embed
Enc

𝐇𝐇𝟏𝟏 Enc Embed

𝐇𝐇𝟐𝟐 Enc

Embed

Dec
𝐇𝐇𝟑𝟑

LSTM

LSTM

LSTM

Fusion

Fusion

Fusion

𝑂𝑂

Mixture Wav

Enc

𝐄𝐄 Separator

Conditional Connection

CondChain

Figure 4: Conditional Chain Model for multi-speaker joint speech separation and recognition.

In previous experiments of separation and multi-speaker speech recognition tasks, we explore the effectiveness of our conditional chain model with output sequences from the same domain, as depicted in Figure 2. In contrast, in this subsection, we evaluate a combination of cross-domain conditions by using the ASR output to guide separation learning. This direction is motivated by the so-called informational masking effect in the cocktail party problem [4, 17], where the linguistic clue may exert a strong inﬂuence on the outcome of speech-to-speech perception.
Speciﬁcally, as illustrated in Figure 4, in each step of our conditional chain model, both the separated waveform and the CTC alignment from the ASR model are utilized as the conditions for the next step, encouraging CondChain in Eq. 3 to jointly capture the information spanning multiple sources. The baseline conditional TasNet is trained using utterance-level waveform instead of chunk-level as in Section 5.2. In addition, unlike Section 5.3, we use a pre-trained ASR based on a single speaker Transformer-based CTC ASR system trained on the WSJ training set SI284 without overlap with

8

WSJ0-2mix test set to stabilize our joint model training. We also use the downsampled 8 kHz data for the reduction of the memory consumption in separation and non-truncation of the speech mixture for appropriate ASR evaluation. Details of framework are explained in the Appendix A.3.
The results are shown in Table 4. Note that the numbers listed in this experiment cannot be strictly compared with those in Sections 5.2 and 5.3 due to the above different conﬁguration requirements between separation and recognition. When directly feeding the separated waveform from the baseline conditional TasNet to the pre-trained ASR, we get 25.1% WER. Finetuning of the TasNet with both waveform and CTC alignment conditions achieved 0.3dB improvement of SI-SNRi. The improvement shows that the semantic condition, such as CTC alignment, provides a good guide to the separation learning. Finetuning of both TasNet and ASR models with both waveform and CTC alignment conditions yields the best WER of 14.4%, while waveform-only conditioning obtains the WER of 15.3%. Note that this joint training severely degraded the SI-SNRi result, but the WER result gets a signiﬁcant improvement. This intriguing phenomenon demonstrates that the separation evaluation metric (SI-SNRi) does not always give a good indication of ASR performance, as studied in [36, 37].

5.5 Implementation for iterative speech denoising

Former experiments on multi-speaker speech separation and recognition show the effectiveness of our conditional chain to disentangle the input mixture signals into several components. For our proposed tasks above, actually, there is a mutually exclusive relationship between the outputs. However, the seq2Mseq tasks also cover some instances that the output sequences get a positive correlation. In this section, we manage to verify the ability to model this positive correlation, besides the proposed tasks above.
In the speech domain, the problem of a positive correlation between multiple outputs is also reﬂected in some problems. In this section, we take the speech denoising task as an example to verify the effectiveness of our conditional chain model in the case of positive correlation between iterative steps. The iterative estimation of some signals is an effective technique in speech processing, which could be used in speech enhancement [11], i-vector estimation [25], speech separation [19]. Similar to this technique for speech denoising, we implement our conditional chain model with two iteration in the chain to denoise the noisy input speech. This formulation is very similar to the iterative re-estimation of the clean signal. That is to say that our conditional chain method is trained with two identical references as objects, i.e., s1 = s2 = s. And the output of the second step is conditioned on the estimation from the ﬁrst step, similar to the structure shown in Figure 2(a).
To evaluate this, we conduct the speech denoising task based on a recently published dataset from the DNS-Challenge 2020 [29], which consists of 60,000 no-reverberant noisy clips in training and 300 in evaluation set.

Table 5: The SDR performance on no-reverberant testset in DNS-challenge 2020.

Methods

SDR SDRi

Ofﬁcial baseline[47]

13.4 4.2

Our implementation for [47] 14.6 5.5

TasNet

17.3 8.2

Conditional TasNet (1st step) 17.8 8.7

Conditional TasNet (2nd step) 18.0 8.9

Here, we compare the results with the ofﬁcial baseline model [47] and our implemented baseline based on TasNet. And, we also report the performance of our conditional chain model with the same architecture and hyper-parameters with the base TasNet model.
From the results in Table 5, we could see that, with the iterative estimation of the clean speech signal in our conditional chain model, the performance gets obvious improvement over the same base model (TasNet). And, the estimation of the second step is better than the ﬁrst step. These results show that our conditional chain learns to reﬁne the condition from former steps, which further proves that our model has good adaptability and generalization performance when learning the relationship between multiple output sequences.
9

6 Conclusions
In this work, we introduced conditional chain model, a uniﬁed method to tackle a one-to-many sequence transduction problem for mixture signals. With the probabilistic chain rule, the standard sequence-to-sequence model is extended to output multiple sequences with explicit modeling of the relevance between multiple output sequences. Our experiments on speech separation and multispeaker speech recognition show that our model led to consistent improvements with negligible increase in the model size compared with the conventional non-conditional methods,
In terms of the application scope, although we verify the proposed method with two speciﬁc tasks, speech separation and recognition, this conditional chain model can be ﬂexibly extended to other sequence-to-multi-sequence problems for mixture signals, as a general machine learning framework. Therefore, as a future work, it might be interesting to adopt this method to other sequential tasks including natural language processing and video analysis. Another exciting direction would be introducing the attention mechanism into the fusion and conditional chain part, which could ﬂexibly capture the implicit relationship between input and output from variable domains.
References
[1] Xavier Anguera, Simon Bozonnet, Nicholas Evans, Corinne Fredouille, Gerald Friedland, and Oriol Vinyals. Speaker diarization: a review of recent research. IEEE/ACM Transactions on Audio, Speech, and Language Processing, 20(2):356–370, 2012.
[2] Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly learning to align and translate. In Proc. ICLR, 2015.
[3] Albert S Bregman. Auditory scene analysis: the perceptual organization of sound. MIT press, 1994.
[4] Douglas S Brungart. Informational and energetic masking effects in the perception of two simultaneous talkers. The Journal of the Acoustical Society of America, 109(3):1101–1109, 2001.
[5] William Chan, Navdeep Jaitly, Quoc Le, and Oriol Vinyals. Listen, attend and spell: a neural network for large vocabulary conversational speech recognition. In Proc. ICASSP, pages 4960–4964. IEEE, 2016.
[6] Xuankai Chang, Yanmin Qian, Kai Yu, and Shinji Watanabe. End-to-end monaural multispeaker asr system without pretraining. In Proc. ICASSP, pages 6256–6260. IEEE, 2019.
[7] E. Colin Cherry. Some experiments on the recognition of speech, with one and with two ears. Journal of the Acoustical Society of America, 25(5):975–979, 1953.
[8] Kyunghyun Cho, Bart van Merriënboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. Learning phrase representations using rnn encoderdecoder for statistical machine translation. In Proc. EMNLP, pages 1724–1734. ACL, 2014.
[9] Jan K Chorowski, Dzmitry Bahdanau, Dmitriy Serdyuk, Kyunghyun Cho, and Yoshua Bengio. Attention-based models for speech recognition. In Proc. NeurIPS, pages 577–585, 2015.
[10] Yusuke Fujita, Shinji Watanabe, Shota Horiguchi, Yawen Xue, Jing Shi, and Kenji Nagamatsu. Neural speaker diarization with speaker-wise chain rule. arXiv preprint arXiv:2006.01796, 2020.
[11] Sharon Gannot, David Burshtein, and Ehud Weinstein. Iterative and sequential kalman ﬁlterbased speech enhancement algorithms. IEEE/ACM Transactions on Audio, Speech, and Language Processing, 6(4):373–385, 1998.
[12] Alex Graves, Santiago Fernández, Faustino Gomez, and Jürgen Schmidhuber. Connectionist temporal classiﬁcation: labelling unsegmented sequence data with recurrent neural networks. In Proc. ICML, pages 369–376. JMLR.org, 2006.
10

[13] John R Hershey, Zhuo Chen, Jonathan Le Roux, and Shinji Watanabe. Deep clustering: discriminative embeddings for segmentation and separation. In Proc. ICASSP, pages 31–35. IEEE, 2016.
[14] Takaaki Hori, Jaejin Cho, and Shinji Watanabe. End-to-end speech recognition with word-based rnn language models. In Proc. SLT, pages 389–396, 2018.
[15] Yusuf Isik, Jonathan Le Roux, Zhuo Chen, Shinji Watanabe, and John R. Hershey. Singlechannel multi-speaker separation using deep clustering. In Proc. INTERSPEECH, 2016.
[16] Tzyy-Ping Jung, Colin Humphries, Te-Won Lee, Scott Makeig, Martin J McKeown, Vicente Iragui, and Terrence J Sejnowski. Extended ICA removes artifacts from electroencephalographic recordings. In Proc. NeurIPS, pages 894–900, 1998.
[17] Gerald Kidd and H Steven Colburn. Informational masking in speech recognition. In The Auditory System at the Cocktail Party, pages 75–109. Springer, 2017.
[18] Keisuke Kinoshita, Lukas Drude, Marc Delcroix, and Tomohiro Nakatani. Listening to each speaker one by one with recurrent selective hearing networks. In Proc. ICASSP, pages 5064– 5068. IEEE, 2018.
[19] Morten Kolbaek, Dong Yu, Zheng Hua Tan, Jesper Jensen, Morten Kolbaek, Dong Yu, Zheng Hua Tan, and Jesper Jensen. Multitalker speech separation with utterance-level permutation invariant training of deep recurrent neural networks. IEEE/ACM Transactions on Audio, Speech, and Language Processing, 25(10):1901–1913, 2017.
[20] Yi Luo and Nima Mesgarani. Real-time single-channel dereverberation and separation with time-domain audio separation network. In Proc. INTERSPEECH, pages 342–346, 2018.
[21] Yi Luo and Nima Mesgarani. Tasnet: time-domain audio separation network for real-time, single-channel speech separation. In Proc. ICASSP, pages 696–700. IEEE, 2018.
[22] Yi Luo and Nima Mesgarani. Conv-tasnet: Surpassing ideal time–frequency magnitude masking for speech separation. IEEE/ACM Transactions on Audio, Speech, and Language Processing, 27(8):1256–1266, 2019.
[23] Yi Luo, Zhuo Chen, and Nima Mesgarani. Speaker-independent speech separation with deep attractor network. IEEE/ACM Transactions on Audio, Speech, and Language Processing, 26(4): 787–796, 2018.
[24] Yi Luo, Zhuo Chen, and Takuya Yoshioka. Dual-path rnn: efﬁcient long sequence modeling for time-domain single-channel speech separation. In Proc. ICASSP, pages 46–50. IEEE, 2020.
[25] Ivan Medennikov, Maxim Korenevsky, Tatiana Prisyach, Yuri Khokhlov, Mariya Korenevskaya, Ivan Sorokin, Tatiana Timofeeva, Anton Mitrofanov, Andrei Andrusenko, Ivan Podluzhny, et al. Target-speaker voice activity detection: a novel approach for multi-speaker diarization in a dinner party scenario. arXiv preprint arXiv:2005.07272, 2020.
[26] Tobias Menne, Ilya Sklyar, Ralf Schlüter, and Hermann Ney. Analysis of deep clustering as preprocessing for automatic speech recognition of sparsely overlapping speech. In Proc. INTERSPEECH, pages 2638–2642, 2019.
[27] Eliya Nachmani, Yossi Adi, and Lior Wolf. Voice separation with an unknown number of multiple speakers. arXiv preprint arXiv:2003.01531, 2020.
[28] Yanmin Qian, Xuankai Chang, and Dong Yu. Single-channel multi-talker speech recognition with permutation invariant training. Speech Communication, 104:1–11, 2018.
[29] Chandan KA Reddy, Ebrahim Beyrami, Harishchandra Dubey, Vishak Gopal, Roger Cheng, Ross Cutler, Sergiy Matusevych, Robert Aichner, Ashkan Aazami, Sebastian Braun, et al. The interspeech 2020 deep noise suppression challenge: Datasets, subjective speech quality and testing framework. arXiv preprint arXiv:2001.08662, 2020.
[30] Sam T Roweis. One microphone source separation. In Proc. NeurIPS, pages 793–799, 2001.
11

[31] Hiroshi Seki, Takaaki Hori, Shinji Watanabe, Jonathan Le Roux, and John R Hershey. A purely end-to-end system for multi-speaker speech recognition. In Proc. ACL, pages 2620–2630. ACL, 2018.
[32] Gregory Sell, David Snyder, Alan McCree, Daniel Garcia-Romero, Jesús Villalba, Matthew Maciejewski, Vimal Manohar, Najim Dehak, Daniel Povey, Shinji Watanabe, and Sanjeev Khudanpur. Diarization is hard: some experiences and lessons learned for the JHU team in the inaugural DIHARD challenge. In Proc. INTERSPEECH, pages 2808–2812, 2018.
[33] Shane Settle, Jonathan Le Roux, Takaaki Hori, Shinji Watanabe, and John R Hershey. End-toend multi-speaker speech recognition. In Proc. ICASSP, pages 4819–4823. IEEE, 2018.
[34] Jing Shi, Jiaming Xu, Guangcan Liu, and Bo Xu. Listen, think and listen again: capturing top-down auditory attention for speaker-independent speech separation. In Proc. IJCAI, 2018.
[35] Shun-Ichi Amari and J.-F. Cardoso. Blind source separation-semiparametric statistical approach. IEEE Transactions on Signal Processing, 45(11):2692–2700, 1997.
[36] Aswin Shanmugam Subramanian, Xiaofei Wang, Murali Karthick Baskar, Shinji Watanabe, Toru Taniguchi, Dung Tran, and Yuya Fujita. Speech enhancement using end-to-end speech recognition objectives. In Proc. WASPAA, pages 234–238. IEEE, 2019.
[37] Aswin Shanmugam Subramanian, Chao Weng, Meng Yu, Shi-Xiong Zhang, Yong Xu, Shinji Watanabe, and Dong Yu. Far-ﬁeld location guided target speech extraction using end-to-end speech recognition objectives. In Proc. ICASSP, pages 7299–7303. IEEE, 2020.
[38] Ilya Sutskever, Oriol Vinyals, and Quoc V. Le. Sequence to sequence learning with neural networks. In Proc. NeurIPS, pages 3104–3112, 2014.
[39] Naoya Takahashi, Sudarsanam Parthasaarathy, Nabarun Goswami, and Yuki Mitsufuji. Recursive Speech Separation for Unknown Number of Speakers. In Proc. INTERSPEECH, pages 1348–1352, 2019.
[40] Sue E Tranter and Douglas A Reynolds. An overview of automatic speaker diarization systems. IEEE/ACM Transactions on Audio, Speech, and Language Processing, 14(5):1557–1565, 2006.
[41] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz Kaiser, and Illia Polosukhin. Attention is all you need. In Proc. NeurIPS, pages 5998–6008, 2017.
[42] Subhashini Venugopalan, Marcus Rohrbach, Jeffrey Donahue, Raymond Mooney, Trevor Darrell, and Kate Saenko. Sequence to sequence-video to text. In Proc. ICCV, pages 4534– 4542. IEEE, 2015.
[43] Shinji Watanabe, Takaaki Hori, Shigeki Karita, Tomoki Hayashi, Jiro Nishitoba, Yuya Unno, Nelson Enrique Yalta Soplin, Jahn Heymann, Matthew Wiesner, Nanxin Chen, et al. Espnet: end-to-end speech processing toolkit. In Proc. INTERSPEECH, 2018.
[44] Chao Weng, Dong Yu, Michael L Seltzer, and Jasha Droppo. Deep neural networks for singlechannel multi-talker speech recognition. IEEE/ACM Transactions on Audio, Speech, and Language Processing, 23(10):1670–1679, 2015.
[45] Ronald J. Williams and David Zipser. A learning algorithm for continually running fully recurrent neural networks. Neural Computation, 1(2):270–280, 1989.
[46] Yonghui Wu, Mike Schuster, Zhifeng Chen, Quoc V. Le, Mohammad Norouzi, Wolfgang Macherey, Maxim Krikun, Yuan Cao, Qin Gao, Klaus Macherey, et al. Google’s neural machine translation system: bridging the gap between human and machine translation. arXiv preprint arXiv:1609.08144, 2016.
[47] Yangyang Xia, Sebastian Braun, Chandan K. A. Reddy, Harishchandra Dubey, Ross Cutler, and Ivan Tashev. Weighted speech distortion losses for neural-network-based real-time speech enhancement. In Proc. ICASSP, pages 871–875. IEEE, 2020.
12

[48] Kaituo Xu. Project webpage. https://github.com/kaituoxu/Conv-TasNet.
[49] Li Yao, Atousa Torabi, Kyunghyun Cho, Nicolas Ballas, Christopher Pal, Hugo Larochelle, and Aaron Courville. Describing videos by exploiting temporal structure. In Proc. ICCV, pages 4507–4515. IEEE, 2015.
[50] Dong Yu, Xuankai Chang, and Yanmin Qian. Recognizing multi-talker speech with permutation invariant training. In Proc. INTERSPEECH, pages 2456–2460, 2017.
[51] Dong Yu, Morten Kolbæk, Zheng-Hua Tan, and Jesper Jensen. Permutation invariant training of deep models for speaker-independent multi-talker speech separation. In Proc. ICASSP, pages 241–245, 2017.
A Implementation Details
A.1 Speech separation experiments
For our conditional TasNet, we used the original conﬁgure from TasNet [21] with N = 256, L = 20, B = 256, H = 512, P = 3, X = 8, R = 4. More speciﬁcally, TasNet contains three parts: (1) a linear 1-D convolutional encoder that encapsulates the input mixture waveform into an adaptive 2-D front-end representation, (2) a separator that estimates a ﬁxed number of masking matrices, and (3) a linear 1-D transposed convolutional decoder that converts the masked 2-D representations back to waveforms. We use the same encoder and decoder design as in [21], referring to the Enc and Dec in Figure 2(a) respectively. For separator, we set the channel number of the last 1 × 1 Conv as one, making it outputs single speech sˆi at each step. And we move the last 1 × 1 Conv into the Dec part. For the Fusion and LSTM, E ∈ RDE×T E is concatenated with the conditional state from the previous step Enc(sˆi−1) ∈ RDE×T E at the feature’s dimension. Then, a single layer of LSTM(2DE→DH) is carried out to mapping the fused feature into DH dimension at each frame.
Also, we noticed the update of the base model could further improve the performance like the same tendency in [22, 24]. In this paper, we mainly focus on the relative performance over the original TasNet. For separation-related tasks, all the speeches are re-sampled to 8 kHz to make a fair comparison with other works.
For the training loss calculation, the negative SI-SNR metric is widely used in [48, 21, 22, 24, 27] and achieves satisfying performance. However, the SI-SNR will lead the predicted sources as a scaled signal compared with the ground-truth, making it totally mismatch in inference phase. To address this problem, we change the training loss from negative SI-SNR to negative SDR, forcing the prediction of speech signals as similar as possible with the ground-truth. For the training strategy, we set the initial learning rate of 1 × 10−3, which is multiplying by 0.9 every 8 epochs. In practice, we ﬁnd the original ground-truth signals used as condition result in faster training speed, but a decrease in generalization ability. Therefore, to make the separation more robust, we add Gaussian noise with a standard deviation of 0.25 on these ground-truth source vectors (waveforms) during training.
A.2 Multi-speaker speech recognition experiments
We basically use the open source package ESPnet [43] for the implementation of our ASR model. In the conditional Transformer-based CTC ASR model, there is a total of 16 Transformer layers, 8 before and 8 after the conditional chain LSTM. For the baseline Transformer-based CTC with PIT, there is a total of 12 Transformer layers in the acoustic model. The conﬁguration of each Transformer layer is as follows: the dimension of attention is datt = 256, the dimension of feed-forward is dff = 2048, number of heads is dhead = 4. Before feeding the input to the Transformers, the log mel-ﬁlterbank features are encoded by two CNN blocks. The CNN layers have a kernel size of 3 × 3 and the number of feature maps is 64 in the ﬁrst block and 128 in the second block.
A.3 Multi-speaker joint speech separation and recognition
In the joint training experiments, we ﬁrst pre-train two models for both separation and ASR tasks. The parameters of conditional TasNet are the same as our previous setup. For the pre-trained ASR,
13

we train a single speaker Transformer-based CTC ASR model on the WSJ training set, which is a clean close-mic read speech corpus with about 80h. When jointly ﬁnetuning these two parts, we use the separated wave of TasNet as the input of ASR model and feedback the predicted CTC alignments of ASR into TasNet as an additional condition. Figure 4 shows an overview of our joint model.
Besides, we also introduce two extra teacher-forcing hyperparameters to control the optimization part of the joint model, which are sswav and ssctc. The parameter sswav is the probability of feeding separated wave to ASR, while ssctc is the probability of inputting predicted CTC alignments as the condition. When aiming to optimize TasNet with multiple conditions, we ﬁxed the parameters of ASR and set sswav = 0 and ssctc = 1, which means we only feed ground-truth wave to ASR and use the generated CTC alignments to guide the separation learning. When joint training both part to improve the performance of ASR, we set sswav = 0.5 and ssctc = 0.3. All experiments only have access to the predicted wave and CTC alignments during inference.
B Training strategy with teacher-forcing and ordering

S

Input Model

𝒔𝒔1

𝒔𝒔2

𝒔𝒔3

𝒔𝒔4

Step=1 𝑺�𝑺1

Step=2 𝑺�𝑺2 Step=3 𝑺�𝑺3

Available Option Optimal Option

Step=4 𝑺�𝑺4

STOP

𝑆𝑆𝜃𝜃 = [𝑆𝑆2, 𝑆𝑆3, 𝑆𝑆1, 𝑆𝑆4]

Figure 5: The procedure of selecting and sorting the target sequences using a greedy algorithm in our
proposed methods. At each step i, the ground-truth sequence s∗i is selected from all the available references. In this example, the ﬁnal order θ is s2 → s3 → s1 → s4.

In Eq. 3, the neural network accepts the hidden state of the previous sequence that is estimated at the previous iteration. However, the estimation error at the previous iteration hurts the performance at the next iteration. To reduce the error, we use the teacher-forcing [45] technique, which boosts the performance by exploiting ground-truth reference. During training, Eq. 3 is replaced with as follows:

Hi = CondChain(Ei, s∗i−1),

(5)

Here, s∗i−1 is a ground-truth sequence of index i − 1. The teach-forcing technique is commonly used in conventional seq2seq methods. However, target sequence in seq2seq is determined and has an
immutable order, so the previous approaches also generate the sequence through a ﬁxed order, either
from the beginning to the end, or the reverse order. But for many seq2MSeq problems, the multiple reference sequences are unordered. There arises a problem about how to select the s∗i from the S to process the next iteration, which is also how to determine the best order θ of target sequences.

One most straightforward method is to use the permutation invariant training (PIT) strategy to traverse all the permutations and select the optimal one to update the parameters. However, with the teacherforcing technique attending each step of the output, we must go through the whole feedforward process for each permutation, which takes too much computational complexity. To alleviate this problem, we examine one simple greedy search strategy. As shown in Figure 5, for each output iteration i, the optimal target index is selected by minimizing the difference (distance) with sˆi among a set of the remaining target set, and the selected ground-truth sequence s∗i is fed into the next decoding iteration. With this greedy strategy, the repetitive computation only occurs at the calculation of distance, and there is no need to re-run the feedforward process. In addition, the total number of repetitive computation is i = N (N + 1)/2, compared with the N ! in PIT based strategy.

14

C Analysis on Speech Recognition Outputs
Our method is trained in a greedy fashion, which does not address the label permutation problem from the formulation as other methods do, such as permutation invariant training (PIT) or deep clustering (DPCL), etc. We further look into the speech recognition results in terms of the order following which our model generates the hypotheses. In Table 6, we show the confusion matrix of the prediction order and the text length ranking for the two-speaker scenario. We observe that the order is somehow correlated to the length of the text. In 88% of evaluation samples, the generation order is consistent with the length ranking. By considering two texts sequences that may have very close lengths or some words are much simpler than the others, we loosen the constraint for the length ranking. If we simply accept those cases where the reference text of the ﬁrst hypothesis is shorter than the second, but within a range, the pattern is more obvious. For example, the result is shown in Table 7 when the range is 5. In 99% evaluation samples, the generation order is consistent with the length ranking. In the three-speaker scenario, we ﬁnd a similar pattern: the ﬁrst hypothesis is signiﬁcantly longer than the other two, 98% when the range is 5. We also have the same conclusion on the Transformer-based CTC ASR system trained with PIT in two speaker scenario. It is a Parallel-mapping framework without such conditional dependency. However, we found that the output of each head is highly dependent on the lengths. In our model, 87% of output from one head is longer than that from the other. If we further consider the range of 5, the ratio becomes 99%. Perhaps this can be the heuristic information to address the label permutation problem.

Table 6: Confusion matrix between the hypothesis (Hyp.) generation order and the order of reference (Ref.) text length in 2-speaker case.

Ref. long short Hyp.

1st output 2nd output

2627 373 373 2627

Table 7: Confusion matrix between the hypothesis (Hyp.) generation order and the order of reference (Ref.) text length in 2-speaker case with loosing range 5.

Ref. long short Hyp.

1st output 2nd output

2965 35 35 2965

15

