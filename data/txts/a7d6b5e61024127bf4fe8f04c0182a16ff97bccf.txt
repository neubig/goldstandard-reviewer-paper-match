arXiv:0906.4431v4 [cs.CC] 26 Feb 2011

The Complexity of Probabilistic Lobbying∗

Daniel Binkele-Raible,† Ga´bor Erde´lyi,‡ Nicholas Mattei,

Henning Fernau,§ Jo¨rg Rothe∗∗

February 21, 2011

Judy Goldsmith,¶

Abstract
We propose models for lobbying in a probabilistic environment, in which an actor (called “The Lobby”) seeks to inﬂuence voters’ preferences of voting for or against multiple issues when the voters’ preferences are represented in terms of probabilities. In particular, we provide two evaluation criteria and two bribery methods to formally describe these models, and we consider the resulting forms of lobbying with and without issue weighting. We provide a formal analysis for these problems of lobbying in a stochastic environment, and determine their classical and parameterized complexity depending on the given bribery/evaluation criteria and on various natural parameterizations. Speciﬁcally, we show that some of these problems can be solved in polynomial time, some are NP-complete but ﬁxed-parameter tractable, and some are W[2]-complete. Finally, we provide approximability and inapproximability results for these problems and several variants.
Key words: Computational Complexity, Parameterized Complexity, Computational Social Choice
∗A preliminary version of this paper appears in the proceedings of the 1st International Conference on Algorithmic Decision Theory, October 2009 [EFG+09]. This work was supported in part by DFG grants RO 1202/11-1 and RO 1202/12-1, the European Science Foundation’s EUROCORES program LogICCC, the Alexander von Humboldt Foundation’s TransCoop program, and by NSF grants EAGER-CCF-1049360 and ITR-0325063. This work was done in part while the second author was afﬁliated to Heinrich-Heine-Universita¨t Du¨sseldorf and visiting Universita¨t Trier, while the ﬁrst and the fourth author were visiting Heinrich-Heine-Universita¨t Du¨sseldorf, and while the sixth author was visiting the University of Rochester.
†URL: www.informatik.uni-trier.de/˜raible. Universita¨t Trier, FB 4—Abteilung Informatik, 54286 Trier, Germany. ‡URL: ccc.cs.uni-duesseldorf.de/˜erdelyi. Nanyang Technological University, Division of Mathematical Science, Singapore 639798. §URL: www.informatik.uni-trier.de/˜fernau. Universita¨t Trier, FB 4—Abteilung Informatik, 54286 Trier, Germany. ¶URL: www.cs.uky.edu/˜goldsmit. University of Kentucky, Dept. of Computer Science, Lexington, KY 40506, USA. URL: www.cs.uky.edu/˜nsmatt2. University of Kentucky, Dept. of Computer Science, Lexington, KY 40506, USA. ∗∗URL: ccc.cs.uni-duesseldorf.de/˜rothe. Heinrich-Heine-Universita¨t Du¨sseldorf, Institut fu¨r Informatik, 40225 Du¨sseldorf, Germany.

1

1 Introduction
1.1 Motivation and Informal Description of Probabilistic Lobbying Models
In most democratic political systems, laws are passed by elected ofﬁcials who are supposed to represent their constituency. Individual entities such as citizens or corporations are not supposed to have undue inﬂuence in the wording or passage of a law. However, they are allowed to make contributions to representatives, and it is common to include an indication that the contribution carries an expectation that the representative will vote a certain way on a particular issue.
Many factors can affect a representative’s vote on a particular issue. There are the representative’s personal beliefs about the issue, which presumably were part of the reason that the constituency elected them. There are also the campaign contributions, communications from constituents, communications from potential donors, and the representative’s own expectations of further contributions and political support.
It is a complicated process to reason about. Earlier work considered the problem of meting out contributions to representatives in order to pass a set of laws or inﬂuence a set of votes. However, the earlier computational complexity work on this problem made the assumption that a politician who accepts a contribution will in fact—if the contribution meets a given threshold—vote according to the wishes of the donor.
It is said that “An honest politician is one who stays bought,” but that does not take into account the ongoing pressures from personal convictions and opposing lobbyists and donors. We consider the problem of inﬂuencing a set of votes under the assumption that we can inﬂuence only the probability that the politician votes as we desire.
There are several axes along which we complicate the picture. The ﬁrst is the notion of sufﬁciency: What does it mean to say we have donated enough to inﬂuence the vote? Does it mean that the probability that a single vote will go our way is greater than some threshold? That the probability that all the votes go our way is greater than that threshold? We formally deﬁne and discuss these and other criteria in the section on evaluation criteria (Section 2.3). In particular, we consider two methods for evaluating the outcome of a vote:
1. strict majority, where a vote on an issue is won by a strict majority of voters having a probability of accepting this issue that exceeds a given threshold, and
2. average majority, where a vote on an issue is won exactly when the voters’ average probability of accepting this issue exceeds a given threshold.
How does one donate money to a campaign? In the United States there are several laws that inﬂuence how, when, and how much a particular person or organization can donate to a particular candidate. We examine ways in which money can be channeled into the political process in the section on bribery methods (Section 2.2). In particular, we consider two methods that an actor (called “The Lobby”) can use to inﬂuence the voters’ preferences of voting for or against multiple issues:
1. microbribery, where The Lobby may choose which voter to bribe on which issue in order to inﬂuence the outcome of the vote according to the evaluation criterion used and
2

2. voter bribery, where The Lobby may choose which voters to bribe and for each voter bribed the funds are equally distributed over all the issues, again aiming at changing the outcome of the vote according to the evaluation criterion used.
The voter bribery method is due to Christian et al. [CFRS07], who were the ﬁrst to study lobbying in the context of direct democracy where voters vote on multiple referenda. Their “Optimal Lobbying” problem (denoted OL) is a deterministic and unweighted variant of the lobbying problems that we present in this paper. We state this problem in the standard format for parameterized complexity:
Name: OPTIMAL LOBBYING.
Given: An m×n 0/1 matrix E and a 0/1 vector Z of length n. Each row of E represents a voter and each column represents an issue. An entry of E is 1 if this voter votes “yes” for this issue, and is 0 otherwise. Z represents The Lobby’s target outcome.
Parameter: A positive integer b (representing the number of voters to be inﬂuenced).
Question: Is there a choice of b rows of the matrix (i.e., of b voters) that can be changed such that in each column of the resulting matrix (i.e., for each issue) a strict majority vote yields the outcome targeted by The Lobby?
Christian et al. [CFRS07] proved that OL is W[2]-complete. Sandholm noted that the “Optimal Weighted Lobbying” (OWL) problem, which allows different voters to have different prices and so generalizes OL, can be expressed as and solved via the “binary multi-unit combinatorial reverse auction winner-determination problem” (see [SSGL02]).
The microbribery method in the context of lobbying—though inspired by the different notion of microbribery that Faliszewski et al. [FHHR07, FHHR08, FHHR09a] introduced in the context of bribery in voting—is new to this paper.
1.2 Organization of This Paper and a Brief Overview of Results
Christian et al. [CFRS07] show that OL is complete for the (parameterized) complexity class W[2]. We extend their model of lobbying as mentioned above (see Section 2 for a formal description), and provide algorithms and analysis for these extended models in terms of classical and parameterized complexity. All complexity-theoretic notions needed will be presented in Section 3.
Our classical complexity results (presented in Section 4) are shown via either polynomial-time algorithms for or reductions showing NP-completeness of the problems studied. For the parameterized complexity results (presented in Section 5), we choose natural parameters such as The Lobby’s budget, the budget per referendum, and the “discretization level” used in formalizing our probabilistic lobbying problems (see Section 2.1). We also consider the concept of issue weighting, modeling that certain issues will be of more importance to The Lobby than others. Our classical and parameterized complexity results are summarized in Table 1 (see page 13) for problems without and in Table 2 (see page 17) for problems with issue weighting.
3

In Section 6, we provide approximability and inapproximability results for probabilistic lobbying problems. In this way we add breadth and depth to not only the models but also the understanding of lobbying behavior. We conclude by summarizing our main results and stating some open problems in Section 7.
1.3 Related Work
Lobbying has been studied formally by economists, computer scientists, and special interest groups since at least 1983 [Rei83] and as an extension to formal game theory since 1944 [vNM44]. The different disciplines have considered mostly disjoint aspects of the process while seeking to accomplish distinct goals with their respective formal models. Economists study lobbying as “economic games,” as deﬁned by von Neumann and Morgenstern [vNM44]. This analysis is focused on learning how these complex systems work and deducing optimal strategies for winning the competitions [Rei83, BKdV93, BKdV96]. This work has also focused on how to “rig” a vote and how to optimally dispense the funds among the various individuals [BKdV93]. Economists are interested in ﬁnding effective and efﬁcient bribery schemes [BKdV93] as well as determining strategies for instances of two or more players [BKdV93, Rei83, BKdV96]. Generally, they reduce the problem of ﬁnding an effective lobbying strategy to one of ﬁnding a winning strategy for the speciﬁc type of game. Economists have also formalized this problem for bribery systems in both the United States [Rei83] and the European Union [Cro02].
The study of lobbying from a computational perspective that was initiated by Christian et al. [CFRS07] falls into the emerging ﬁeld of computational social choice, which stimulates a bidirectional transfer between social choice theory (in particular, voting and preference aggregation) and computer science. For example, voting systems have been applied in various areas of artiﬁcial intelligence, most notably in the design of multiagent systems (see, e.g., [ER97]), for developing recommender systems [GMHS99], for designing a meta-search engine that aggregates the website rankings generated by several search engines [DKNS01], etc. Applications of voting systems in such automated settings (not restricted only to political elections in human societies) requires a better understanding of the computational properties of the problems related to voting. In particular, many papers have focused on the complexity of
• winner determination (see, e.g., [BTT89b, HHR97, RSV03, HSV05]),
• manipulation (see, e.g., [BTT89a, BO91, CS03, EL05, CSL07, HH07, PR07, BFH+08, MPRZ08, ZPR08, FHH09, FHHR09c]),
• procedural control (see, e.g., [BTT92, HHR07, FHHR09a, HHR09, FHHR09c, ENR09, ER10, EPR11]), and
• bribery in elections (see, e.g., [FHH09, FHHR09a]).
For more details, the reader is referred to the surveys by Faliszewski et al. [FHHR09b] and Baumeister et al. [BEH+10] and the references cited therein. In comparison, much less work has been done on lobbying in voting on multiple referenda that we are concerned with here ([CFRS07], see also [SSGL02]).
4

2 Models for Probabilistic Lobbying
2.1 Initial Model
We begin with a simplistic version of the PROBABILISTIC LOBBYING PROBLEM (PLP, for short), in which voters start with initial probabilities of voting for an issue and are assigned known costs for increasing their probabilities of voting according to “The Lobby’s” agenda by each of a ﬁnite set of increments. The question, for this class of problems, is: Given the above information, along with an agenda and a ﬁxed budget B, can The Lobby target its bribes in order to achieve its agenda?
The complexity of the problem seems to hinge on the evaluation criterion for what it means to “win a vote” or “achieve an agenda.” We discuss the possible interpretations of evaluation and bribery later in this section.1 First, however, we will formalize the problem by deﬁning data objects needed to represent the problem instances. (A similar model was ﬁrst discussed by Reinganum [Rei83] in the continuous case and we translate it here to the discrete case. This will allow us to present algorithms for, and a complexity analysis of, the problem.)
Let Qm[0×,1n] denote the set of m×n matrices over Q[0,1] (the rational numbers in the interval [0, 1]). We say P ∈ Q[m0×,1n] is a probability matrix (of size m×n), where each entry pi, j of P gives the probability that voter vi will vote “yes” for referendum (synonymously, for issue) r j. The result of a vote is either a “yes” (represented by 1) or a “no” (represented by 0). Thus, we represent the result of any vote on all issues as a 0/1 vector X = (x1, x2, . . . , xn), which is sometimes also denoted as a string in {0, 1}n.
We now associate with each voter/issue pair (vi, r j) a discrete price function ci, j for changing vi’s probability of voting “yes” for issue r j. Intuitively, ci, j gives the cost for The Lobby of raising or lowering (in discrete steps) the ith voter’s probability of voting “yes” on the jth issue. A formal description is as follows.
Given the entries pi, j = / ai,j bi,j of a probability matrix P ∈ Qm[0×,1n] , where ai, j ∈ N = {0, 1, . . .} and bi, j ∈ N>0 = {1, 2, . . .}, choose some k ∈ N such that k + 1 is a common multiple of all bi, j, where 1 ≤ i ≤ m and 1 ≤ j ≤ n, and partition the probability interval [0, 1] into k + 1 steps of size 1/(k+1) each.2 The integer k will be called the discretization level of the problem instance, and each integer κ, 0 ≤ κ ≤ k + 1 might be called a (conﬁdence) step. For each i ∈ {1, 2, . . . , m} and j ∈ {1, 2, . . . , n}, ci, j : {0, 1/(k+1), 2/(k+1), . . . , k/(k+1), 1} → N is the (discrete) price function for pi, j, i.e., ci, j(ℓ/(k+1)) is the price for changing the probability of the ith voter voting “yes” on the jth issue from pi, j to ℓ/(k+1), where 0 ≤ ℓ ≤ k + 1. Note that the domain of ci, j consists of k + 2 elements of Q[0,1] including 0, pi, j, and 1. In particular, we require ci, j(pi, j) = 0, i.e., a cost of zero is associated with leaving the initial probability of voter vi voting on issue r j unchanged. Note that k = 0 means pi, j ∈ {0, 1}, i.e., in this case each voter either accepts or rejects each issue with certainty and The Lobby can only ﬂip these
1We stress that when we use the term “bribery” in this paper, it is meant in the sense of lobbying [CFRS07], not in the sense Faliszewski et al. [FHH09] have in mind when deﬁning bribery in elections (see also, e.g., [FHHR07, FHHR08, FHHR09a]).
2There is some arbitrariness in this choice of k. One might think of more ﬂexible ways of partitioning [0, 1]. We have chosen this way for the sake of simplifying the representation, but we mention that all that matters is that for each i and j, the discrete price function ci, j is deﬁned on the value pi, j, and is set to zero for this value.
5

results.3 The image of ci, j consists of k + 2 nonnegative integers including 0 (the conﬁdence steps), and we require that, for any two elements a, b in the domain of ci, j, if pi, j ≤ a ≤ b or pi, j ≥ a ≥ b, then ci, j(a) ≤ ci, j(b). This guarantees monotonicity on the prices in both directions.
We represent the list of price functions associated with a probability matrix P as a table CP, called cost matrix in the following, whose m · n rows give the price functions ci, j and whose k + 2 columns give the costs ci, j(ℓ/(k+1)), where 0 ≤ ℓ ≤ k + 1. Occasionally, we use ci, j[ℓ] to denote ci, j(ℓ/(k+1)), for ℓ ∈ {0, 1, . . . , k + 1}. Note that we choose the same k for each ci, j, so we have the same number of columns in each row of CP. The entries of CP can be thought of as “price tags” indicating what The Lobby must pay in order to change the probabilities of voting.
The Lobby also has an integer-valued budget B and an “agenda,” which we will denote as a vector Z ∈ {0, 1}n for n issues, containing the outcomes The Lobby would like to see on these issues. For The Lobby, the prices for a bribery that moves the outcomes of a referendum into the wrong direction do not matter. Hence, if Z is zero at position j, then we set ci, j(a) = −− (indicating an unimportant entry) for a > pi, j, and if Z is one at position j, then we set ci, j(a) = −− (indicating an unimportant entry) for a < pi, j. Without loss of generality, we may also assume that ci, j(a) = 0 if and only if a = pi, j.
For simplicity, we may assume that The Lobby’s agenda is all “yes” votes, so the target vector is Z = 1n. This assumption can be made without loss of generality, since if there is a zero in Z at position j, we can ﬂip this zero to one and also change the corresponding probabilities p1, j, p2, j, . . . , pm, j in the jth column of P to 1 − p1, j, 1 − p2, j, . . . , 1 − pm, j. (See the evaluation criteria in Section 2.3 for how to determine the result of voting on a referendum.) Moreover, the rows of the cost matrix CP that correspond to issue j have to be mirrored.
Example 2.1 Consider the following problem instance with k = 9 (so there are k + 1 = 10 steps), m = 2 voters, and n = 3 issues. We will use this as a running example for the rest of this paper. In addition to the above deﬁnitions for k, m, and n, we also give the following probability matrix P and cost matrix CP for P. (Note that this example is normalized for an agenda of Z = 13, which is why The Lobby has no incentive for lowering the acceptance probabilities, so those costs are omitted below.)
Our example consists of a probability matrix P:
r1 r2 r3 v1 0.8 0.3 0.5 v2 0.4 0.7 0.4
and the corresponding cost matrix CP:
ci, j 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 c1,1 −− −− −− −− −− −− −− −− 0 100 140 c1,2 −− −− −− 0 10 70 100 140 310 520 600 c1,3 −− −− −− −− −− 0 15 25 70 90 150 c2,1 −− −− −− −− 0 30 40 70 120 200 270 c2,2 −− −− −− −− −− −− −− 0 10 40 90 c2,3 −− −− −− −− 0 70 90 100 180 300 450
3This is the special case of OL [CFRS07].
6

In Section 2.2, we describe two bribery methods, i.e., two speciﬁc ways in which The Lobby can inﬂuence the voters. These will be referred to as microbribery (MB) and voter bribery (VB). In Section 2.3, we deﬁne two ways in which The Lobby can win a set of votes. These evaluation criteria will be referred to as strict majority (SM) and average majority (AM). The four basic probabilistic lobbying problems we will study (each a combination of MB/VB bribery under SM/AM evaluation) are deﬁned in Section 2.4, and a modiﬁcation of these basic problems with additional issue weighting is introduced in Section 2.5.

2.2 Bribery Methods
We begin by ﬁrst formalizing the bribery methods by which The Lobby can inﬂuence votes on issues. We will deﬁne two methods for donating this money.

2.2.1 Microbribery (MB)
The ﬁrst method at the disposal of The Lobby is what we will call microbribery.4 We deﬁne microbribery to be the editing of individual elements of the P matrix according to the costs in the CP matrix. Thus The Lobby picks not only which voter to inﬂuence but also which issue to inﬂuence for that voter. This bribery method allows a very ﬂexible version of bribery, and models private donations made to politicians or voters in support of speciﬁc issues.
More formally, if voter i is bribed with d dollars on issue j, then all entries ci, j[ℓ], 0 ≤ ℓ ≤ k + 1, of CP are updated as follows:

ci, j[ℓ] :=

−−

if(ci, j[ℓ] = −−) ∨ ((ci, j[ℓ] − d) ≤ 0)

ci, j[ℓ] − d if(ci, j[ℓ] − d) > 0.

Moreover, assuming The Lobby’s target vector is 1n, let T = argmax{ℓ | ci, j[ℓ] = −−}. Replace ci, j[T ] := 0 and update pi, j := T/(k+1).

Example 2.2 (continuing Example 2.1) To make this concrete, reconsidering our Example 2.1: Suppose we give $100 to the second voter and ask her to change her opinion on the third issue. This would lead to the following update of CP:
ci, j 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 c1,1 −− −− −− −− −− −− −− −− 0 100 140 c1,2 −− −− −− 0 10 70 100 140 310 520 600 c1,3 −− −− −− −− −− 0 15 25 70 90 150 c2,1 −− −− −− −− 0 30 40 70 120 200 270 c2,2 −− −− −− −− −− −− −− 0 10 40 90 c2,3 −− −− −− −− −− −− −− 0 80 200 350
4Although our notion was inspired by theirs, we stress that it should not be confused with the term “microbribery” used by Faliszewski et al. [FHHR07, FHHR08, FHHR09a] in the different context of bribing “irrational” voters in Llull/Copeland elections via ﬂipping single entries in their preference tables.

7

Accordingly, the matrix P is updated as follows:
r1 r2 r3 v1 0.8 0.3 0.5 v2 0.4 0.7 0.7
2.2.2 Voter Bribery (VB)
The second method at the disposal of The Lobby is voter bribery. We can see from the P matrix that each row represents what an individual voter thinks about all the issues on the docket. In this method of bribery, The Lobby picks a voter and then pays to edit the entire row at once with the funds being equally distributed over all the issues. So, for d dollars a fraction of d/n is spent on each issue, and the probabilities change accordingly. The cost of moving the voter is given by the CP matrix as before. This method of bribery is analogous to “buying” or pushing a single politician or voter. The Lobby seeks to donate so much money to some individual voters that they have no choice but to move all of their votes toward The Lobby’s agenda.
Let us be more precise. To avoid problems with fractions of dollars, we will assume that the bribery money is donated in multiples of n, the number of issues. Hence, whole dollars will be donated per referendum. So, if we bribe voter i by giving her x·n dollars, this results in microbribing every issue by giving x dollars to voter i to raise her conﬁdence on issue j; in other words, all the entries of ci, j (in CP), 1 ≤ j ≤ n, will be edited (and accordingly P).
Example 2.3 (continuing Example 2.1) Let us reconsider our running example: What happens if we give $300 to the second voter? The update of CP would be as follows:
ci, j 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 c1,1 −− −− −− −− −− −− −− −− 0 100 140 c1,2 −− −− −− 0 10 70 100 140 310 520 600 c1,3 −− −− −− −− −− 0 15 25 70 90 150 c2,1 −− −− −− −− −− −− −− 0 20 100 170 c2,2 −− −− −− −− −− −− −− −− −− −− 0 c2,3 −− −− −− −− −− −− −− 0 80 200 350
Accordingly, the matrix P is updated as follows:
r1 r2 r3 v1 0.8 0.3 0.5 v2 0.7 1.0 0.7
Simple Observation
Note that microbribery is equivalent to voter bribery if there is only one referendum.
8

2.3 Evaluation Criteria
Deﬁning criteria for how an issue is won is the next important step in formalizing our models. Here we deﬁne two methods that one could use to evaluate the eventual outcome of a vote. Since we are focusing on problems that are probabilistic in nature, it is important to note that no evaluation criterion will guarantee a win. The criteria below yield different outcomes depending on the model and problem instance.
2.3.1 Strict Majority (SM)
For each issue, a strict majority of the individual voters have probability greater than some threshold, t, of voting according to the agenda. In our running example (see Example 2.1), with t = 50%, the result of the votes would be X = (0, 0, 0), because none of the issues has a strict majority of voters with above 50% likelihood of voting “yes.” The bribery action described in Example 2.2 results in the same vector, (0, 0, 0). However, the bribery action described in Example 2.3 results in the vector (1, 0, 0).
2.3.2 Average Majority (AM) For each issue r j of a given probability matrix P, we deﬁne the average probability p j = (∑mi=1 pi,j)/m of voting “yes” for r j. We now evaluate the vote to say that r j is accepted if and only if p j > t where t is some threshold. In our running example with t = 50%, this would give us a result vector of X = (1, 0, 0). However, the bribery action described in Example 2.2 results in the vector (1, 0, 1), while the bribery action described in Example 2.3 results in the vector (1, 1, 1).
Simple Observation
Note that the ﬁrst two criteria coincide if there is only one voter or if the discretization level equals zero.
2.4 Basic Probabilistic Lobbying Problems
We now introduce the four basic problems that we will study. Recalling that, without loss of generality, The Lobby’s target vector may assumed to be all ones, we deﬁne the following problem for X ∈ {MB, VB} and Y ∈ {SM, AM}.
Name: X-Y PROBABILISTIC LOBBYING PROBLEM. Given: A probability matrix P ∈ Q[m0×,1n] with a cost matrix CP (with integer entries), a budget B, and
some threshold t ∈ Q[0,1[.
Question: Is there a way for The Lobby to inﬂuence CP and hence P (using bribery method X and evaluation criterion Y, without exceeding budget B) such that the result of the votes on all issues equals 1n?
9

We abbreviate this problem name as X-Y-PLP.
Example 2.4 (continuing Example 2.1) Consider voter bribery and the average majority criterion with our running example and suppose The Lobby has a budget of $75, i.e., our instance of VB-AM-PLP is (P,CP, 75) with P and CP as given in Example 2.1. Giving $75 to the ﬁrst voter would sufﬁce to lift all issues above the threshold of 50% on average according to the wishes of The Lobby. The updated cost matrix CP′ would be:
ci, j 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 c1,1 −− −− −− −− −− −− −− −− 0 75 115 c1,2 −− −− −− −− 0 45 75 115 285 495 575 c1,3 −− −− −− −− −− −− −− 0 45 65 125 c2,1 −− −− −− −− 0 30 40 70 120 200 270 c2,2 −− −− −− −− −− −− −− 0 10 40 90 c2,3 −− −− −− −− 0 70 90 100 180 300 450
This leads to the following updated probability matrix P′, enriched with the average probabilities:
r1 r2 r3 v1 0.8 0.4 0.7 v2 0.4 0.7 0.4 p j 0.6 0.55 0.55
Since each referendum passes the evaluation test, as desired by The Lobby, (P,CP, 75) ∈ VB-AM-PLP.
Notice that the discretization level is an implicit (unary) parameter of the problem that is indirectly speciﬁed through the cost matrix CP.
2.5 Probabilistic Lobbying with Issue Weighting
We now augment the model to include the concept of issue weighting. It is reasonable to surmise that certain issues will be of more importance to The Lobby than others. For this reason we will allow The Lobby to specify higher weights to the issues that they deem more important. These positive integer weights will be deﬁned for each issue.
We will specify these weights as a vector W ∈ Nn>0 with size n equal to the total number of issues in our problem instance. The higher the weight, the more important that particular issue is to The Lobby. Along with the weights for each issue we are also given an objective value O ∈ N>0, which is the minimum weight The Lobby wants to see passed. Since this is a partial ordering, it is possible for The Lobby to have an ordering such as
w1 = w2 = · · · = wn.
If this is the case, we see that we are left with an instance of X-Y-PLP, where X ∈ {MB, VB} and Y ∈ {SM, AM}.
We now introduce the four probabilistic lobbying problems with issue weighting. For X ∈ {MB, VB} and Y ∈ {SM, AM}, we deﬁne the following problem.
10

Name: X-Y PROBABILISTIC LOBBYING PROBLEM WITH ISSUE WEIGHTING.
Given: A probability matrix P ∈ Qm[0×,1n] with cost matrix CP, an issue weight vector W ∈ Nn>0, an objective value O ∈ N>0, a budget B, and some threshold t ∈ Q[0,1[.
Question: Is there a way for The Lobby to inﬂuence CP and hence P (using bribery method X and evaluation criterion Y, without exceeding budget B) such that the total weight of all issues for which the result coincides with The Lobby’s target vector 1n is at least O?
We abbreviate this problem name as X-Y-PLP-WIW.
3 Complexity-Theoretic Notions
We assume the reader is familiar with standard notions of (classical) complexity theory, such as P, NP, and NP-completeness. Since we analyze the problems stated in Section 2 not only in terms of their classical complexity, but also with regard to their parameterized complexity, we provide some basic notions here (see, e.g., the text books by Downey and Fellows [DF99], Flum and Grohe [FG06], and Niedermeier [Nie06] for more background). As we derive our results in a rather speciﬁc fashion, we will employ the “Turing way” as proposed by Cesati [Ces03].
A parameterized problem P is a subset of Σ∗×N, where Σ is a ﬁxed alphabet and Σ∗ is the set of strings over Σ. Each instance of the parameterized problem P is a pair (I, p), where the second component p is called the parameter. The language L(P) is the set of all YES instances of P. The parameterized problem P is ﬁxed-parameter tractable if there is an algorithm (realizable by a deterministic Turing machine) that decides whether an input (I, p) is a member of L(P) in time f (p)|I|c, where c is a ﬁxed constant and f is a function of the parameter p, but is independent of the overall input length, |I|. The class of all ﬁxed-parameter tractable problems is denoted by FPT.
The O∗(·) notation has by now become standard in exact algorithms. It neglects not only constants (as the more familiar O(·) notation does) but also polynomial factors in the function estimates. Thus, a problem is in FPT if and only if an instance (with parameter p) can be solved in time O∗( f (p)) for some function f .
Sometimes, more than one parameter (e.g., two parameters (p1, p2)) are associated with a (classical) problem. This is formally captured in the deﬁnition above by coding those parameters into one number p via a so-called pairing function through diagonalization. As is standard, we assume our pairing function to be a polynomial-time computable bijection from N×N onto N that has polynomial-time computable inverses.
For a given classical decision or optimization problem, there are various ways to deﬁne parameters. With minimization problems, the standard parameterization is a bound on the entity to be minimized. For instance, the problems studied in this paper have, as a natural minimization objective, the goal to minimize costs (i.e., to use a budget B as small as possible). If one can assume that the parameter p is small in practice, or in practical situations involving humans, we can argue that an algorithm offering a run time of O∗(2p) behaves reasonably well in practice. A related natural parameter choice would be the budget that can be spent per issue, i.e., the entity B/n. If the voters are actual human beings, one can also argue that the discretization level k would not be too large.
11

One of the current trends in parameterized complexity analysis is to study multiple parameterizations for each problem, including combining multiple parameters for a problem instance. This trend is highlighted by two recent invited talks given by Fellows [Fel09] and Niedermeier [Nie10]. Notice that the study of different and multiple parameterizations can also be seen from another angle: Apart from identifying the hard parts of the problem instance, such research represents a natural mathematical counterpart of the more practically oriented quest for good parameters that may lead to the most competitive algorithm frameworks for hard problems, as exempliﬁed most notably by SATzilla and ParamILS in the areas of algorithms for Satisﬁability and Integer Linear Programming, respectively, see [XHHLB08, HHLBS09].
There is also a theory of parameterized complexity, as exhibited in [DF99, FG06, Nie06], where parameterized complexity is expressed via hardness for or completeness in the levels W[t], t ≥ 1, of the W-hierarchy, which complement ﬁxed-parameter tractability:
FPT = W[0] ⊆ W[1] ⊆ W[2] ⊆ · · · .
It is commonly believed that this hierarchy is strict. Since only the second level, W[2], will be of interest to us in this paper, we will deﬁne only this class below.
Deﬁnition 3.1 Let P and P′ be two parameterized problems. A parameterized reduction from P to P′ is a function r that, for some polynomial q and some function g, is computable in time O(g(p)q(|I|)) and maps an instance (I, p) of P to an instance r(I, p) = (I′, p′) of P′ such that
1. (I, p) is a YES instance of P if and only if (I′, p′) is a YES instance of P′, and 2. p′ ≤ g(p). We then say that P parameterized reduces to P′ (via r). Parameterized hardness for and completeness in a parameterized complexity class is deﬁned via parameterized reductions. We will show only W[2]-completeness results. A parameterized problem P′ is said to be W[2]-hard if every parameterized problem P in W[2] parameterized reduces to P′. P′ is said to be W[2]-complete if P′ is in W[2] and is W[2]-hard.
W[2] can be characterized by the following problem on Turing machines:
Name: SHORT MULTI-TAPE NONDETERMINISTIC TURING MACHINE COMPUTATION.
Given: A multi-tape nondeterministic Turing machine M (with two-way inﬁnite tapes) and an input string x (both M and x are given in some standard encoding).
Parameter: A positive integer k.
Question: Is there an accepting computation of M on input x that reaches a ﬁnal accepting state in at most k steps?
12

Problem
MB-SM-PLP MB-AM-PLP VB-SM-PLP VB-AM-PLP

Classical Complexity
P P NP-complete NP-complete

Parameterized Complexity, parameterized by

Budget

Budget per Issue

Budget & Discretiz. Level

(FPT) (FPT) FPT
?

(FPT) (FPT) W[2]-complete W[2]-hard

(FPT) (FPT) FPT FPT

Stated in or implied by Thm./Cor.
4.1 4.4 4.5, 5.2, 5.3, 5.1 4.5, 5.4, 5.1

Table 1: Complexity results for X-Y-PLP, where X ∈ {MB, VB} and Y ∈ {SM, AM}

We abbreviate this problem name as SMNTMC. More speciﬁcally, a parameterized problem P is in W[2] if and only if it can be reduced to SMNTMC via a parameterized reduction [Ces03]. This can be accomplished by giving an appropriate multi-tape nondeterministic Turing machine for solving P. Hardness for W[2] can be shown by giving a parameterized reduction in the opposite direction, from SMNTMC to P. For other applications of ﬁxed-parameter tractability and parameterized complexity to problems from computational social choice, see, e.g., [LR08].

4 Classical Complexity Results
We now provide a formal complexity analysis of the probabilistic lobbying problems for all combinations of bribery methods X ∈ {MB, VB} and evaluation criteria Y ∈ {SM, AM}. Table 1 summarizes some of our (classical and parameterized) complexity results for the problems X-Y-PLP; note that Table 1 does not cover Theorem 5.5 (which considers a combination of two parameters, namely of budget per issue and discretization level).
Some of these results are known from previous work by Christian et al. [CFRS07], as will be mentioned below. Our results generalize theirs by extending the model to probabilistic settings. The listed FPT results might look peculiar at ﬁrst glance, since Christian et al. [CFRS07] derived W[2]hardness results, but this is due to the chosen parameterization, as will be discussed later in more detail. We put parentheses around some classes in Table 1 to indicate that these results are trivially inherited from others. For example, if some problem is solvable in polynomial time, then it is in FPT for any parameterization. The table mainly provides results on the containment of problems in certain complexity classes; if known, additional hardness results are also listed.
In Section 4.1 we present our results on microbribery (i.e., we study the problems MB-Y-PLP for Y ∈ {SM, AM}), and in Section 4.2 we are concerned with voter bribery (i.e., we study the problems VB-Y-PLP for Y ∈ {SM, AM}). In addition, in Section 4.3 we study probabilistic lobbying with issue weighting.
4.1 Microbribery
Theorem 4.1 MB-SM-PLP is in P.
Proof. The aim is to win all referenda. For each voter vi and referendum r j, 1 ≤ i ≤ m and 1 ≤ j ≤ n, we compute in polynomial time the amount b(vi, r j) The Lobby has to spend to turn the favor
13

of vi in the direction of The Lobby (beyond the given threshold t). In particular, set b(vi, r j) = 0 if

voter vi would already vote according to the agenda of The Lobby. For each issue r j, sort {b(vi, r j) |

1 ≤ i ≤ m} nondecreasingly, yielding a sequence b1(r j), . . . , bm(r j) such that bk(r j) ≤ bℓ(r j) for

k < ℓ. To win referendum r j, The Lobby must spend at least B(r j) = ∑⌈i=(m1+1)/2⌉ bi(r j) dollars. Hence,

all referenda are won if and only if ∑nj=1 B(r j) is at most the given bribery budget B.

❑

Note that the time needed to implement the algorithm given in the previous proof can be bounded by a polynomial of low order. More precisely, if the input consists of m voters, n referenda, and discretization level k, then O(n · m · k) time is needed to compute the b(vi, r j). Having these values, O(n · m · log m) time is needed for the sorting phase. The sums can be computed in time O(n · m).
Similarly, the other problems that we show to belong to P admit solution algorithms bounded by polynomials of low order.
The complexity of microbribery with evaluation criterion AM is somewhat harder to determine. We use the following auxiliary problem. First we need a deﬁnition.

Deﬁnition 4.2 • Given a directed graph G consisting of path components P1, . . . , Pπ with vertex set V = {J1, . . . , Jn} representing jobs, a schedule S of q ≤ n jobs (on a single machine) is a sequence Ji(1), . . . , Ji(q) such that Ji(r) = Ji(s) implies r = s (i.e., no job appears twice).
• Assigning cost c(Jk) to job Jk for each k, 1 ≤ k ≤ n, the cost of schedule S is
q
∑ c(S) = c(Ji(k)). k=1

• The mapping φ we use in the following takes two arguments: the index of a path and the number of the job on that path, and it returns the correct index of the job. S is said to respect the precedence constraints of G if for every path-component Pi = (Jφ(i,1), . . . , Jφ(i,p(i))) of G (with V = πi=1{Jφ(i,ℓ) | 1 ≤ ℓ ≤ p(i)}) and for each ℓ with 2 ≤ ℓ ≤ p(i), we have: If Jφ(i,ℓ) occurs in schedule S then Jφ(i,ℓ−1) occurs in S before Jφ(i,ℓ).
Name: PATH SCHEDULE
Given: A set V = {J1, . . . , Jn} of jobs, a directed graph G = (V, A) consisting of pairwise disjoint paths P1, . . . , Pπ, two numbers C, q ∈ N, and a cost function c : V → N.
Question: Does there exist a schedule Ji(1), . . . , Ji(q) of q jobs of cost at most C respecting the precedence constraints of G?

We ﬁrst show, as Lemma 4.3, that the minimization version of PATH SCHEDULE is polynomialtime computable, so the decision problem PATH SCHEDULE is in P. Then we will show, as Theorem 4.4, how to reduce MB-AM-PLP to PATH SCHEDULE, which implies that MB-AM-PLP is in P as well.

Lemma 4.3 PATH SCHEDULE is in P.

14

Proof. Given an instance of PATH SCHEDULE as in the problem description above, the following

dynamic programming approach calculates T [{P1, . . . , Pπ}, q], which gives the minimum cost to

solve the problem.

We build up a table T [{P1, . . . , Pℓ}, j] storing the minimum cost of scheduling j jobs out of the

jobs contained in the paths P1, . . . , Pℓ. Let Pi = (Jφ(i,1), . . . , Jφ(i,p(i))) be a path, 1 ≤ i ≤ π. For k ≤

p(1),

set

T [{P1}, k]

=

∑

k s=

1

c(Jφ

(

1,s

)

).

For

k

>

p(1),

set

T [{P1}, k] =

∞.

If

ℓ>

1,

T [{P1, . . . , Pℓ},

j]

equals

k

∑ min T [{P1, . . . , Pℓ−1}, j − k] + c(Jφ(ℓ,s)).

0≤k≤min{ j,p(ℓ)}

s=1

Consider each possible scheduling of the ﬁrst k jobs of Pℓ. For the remaining j − k jobs, look

up a solution in the table. Note that we can re-order each schedule S so that all jobs from one

path contiguously appear in S, without violating the precedence constraints by this re-ordering nor

changing the cost of the schedule. Hence, T [{P1, . . . , Pπ}, q] gives the minimum schedule cost. The number of entries in the table is π · q, and computing each entry T [{P1, . . . , Pℓ}, ·] is linear in p(ℓ)

(for each ℓ, 1 ≤ ℓ ≤ π), which leads to a run time of the dynamic programming algorithm that is

polynomially bounded in the input size.

❑

Theorem 4.4 MB-AM-PLP is in P.

Proof. Let (P,CP, B,t) be a given MB-AM-PLP instance, where P ∈ Q[m0×,1n] , CP is a cost matrix, B is The Lobby’s budget, and t is a given threshold. Let k be the discretization level of P, i.e., the
interval is divided into k + 1 steps of size 1/(k+1) each. For j ∈ {1, 2, . . . , n}, let d j be the minimum cost for The Lobby to bring referendum r j into line with the jth entry of its target vector 1n. If ∑nj=1 d j ≤ B, then The Lobby can achieve its goal that the votes on all issues pass.
For every r j, create an equivalent PATH SCHEDULING instance. First, compute for r j the min-
imum number b j of bribery steps needed to achieve The Lobby’s goal on r j. That is, choose the
smallest b j ∈ N such that p j + bj/(k+1)m > t. Now, given r j, derive a path Pi from the price function ci, j for every voter vi, 1 ≤ i ≤ m, as follows.

1. Let s, 0 ≤ s ≤ k + 1, be minimum with the property ci, j(s/(k+1)) ∈ N>0.

2. Create a path Pi = ((ps, i), . . . , (pk+1, i)), where ph = h/(k+1).

3. Assign the cost cˆ((ph, i)) = ci, j(ph) − ci, j(p(h−1)) to (ph, i), where s + 1 ≤ h ≤ k + 1.

Note that cˆ((ph, i)) represents the cost of raising the probability of voting “yes” from (h−1)/(k+1)

to h/(k+1). In order to do so, we must have reached an acceptance probability of (h−1)/(k+1) ﬁrst.

Now, let the number of jobs to be scheduled be b j. Note that one can take b j bribery steps at the

cost of d j dollars if and only if one can schedule b j jobs with a cost of d j. Hence, we can decide

whether or not (P,CP, B) is in MB-AM-PLP by using the dynamic program given in the proof of

Lemma 4.3.

❑

15

4.2 Voter Bribery
Recall the OPTIMAL LOBBYING problem (OL) deﬁned in Section 1.1. Again, The Lobby’s target vector Z may assumed to be all ones, without loss of generality, so Z may be dropped from the input.
Christian et al. [CFRS07] proved that this problem is W[2]-complete by reducing from the W[2]complete problem k-DOMINATING SET to OL (showing the lower bound) and from OL to the W[2]complete problem INDEPENDENT-k-DOMINATING SET (showing the upper bound). In particular, this implies NP-hardness of OL.
The following result focuses on the classical complexity of VB-SM-PLP and VB-AM-PLP; the parameterized complexity of these problems will be studied in Section 5 and will make use of the proof of Theorem 4.5 below.
To employ the W[2]-hardness result of Christian et al. [CFRS07], we show that OL is a special case of VB-SM-PLP and thus (parameterized) polynomial-time reduces to VB-SM-PLP. Analogous arguments apply to VB-AM-PLP.
Theorem 4.5 VB-SM-PLP and VB-AM-PLP are NP-complete.
Proof. Membership in NP is obtained through a “guess-and-check” algorithm for VB-SM-PLP and VB-AM-PLP. We present the details for the sake of completeness. Let (P,CP, B,t) be a given instance of VB-Y-PLP for evaluation criterion Y ∈ {SM, AM}, where P ∈ Q[m0×,1n] is a probability matrix with cost matrix CP (with integer entries), B is a budget, and t is a threshold. Nondeterministically guess a subset V of rows in P (each corresponding to a voter to be inﬂuenced in this nondeterministic branch) and a corresponding list DV = (d1, d2, . . . , d V ) of integers such that ∑i=V1 di ≤ B, where di is the amount of bribery money to be spent on vi ∈ V in this nondeterministic branch. For any (V, DV ) guessed, check deterministically whether spending di on vi, for each vi ∈ V , will change (according to the cost matrix CP) the given matrix P into a new matrix PV such that each issue evaluates to “yes” in PV under evaluation criterion Y with respect to threshold t, and accept/reject accordingly on this nondeterministic branch.
We now prove that VB-SM-PLP is NP-hard by reducing OL to VB-SM-PLP. We are given an instance (E, b) of OL, where E is a m×n 0/1 matrix and b is the number of votes to be edited. Recall that The Lobby’s target vector is 1n. We construct an instance of VB-SM-PLP consisting of the given matrix P = E (a “degenerate” probability matrix with only the probabilities 0 and 1), a corresponding cost matrix CP, and a budget B. CP has two columns (we have k = 0, since the problem instance is deterministic, see Section 2.1), one column for probability 0 and one for probability 1. All entries of CP corresponding to pi, j = 1 are set to unit cost: ci, j[1] = 1 if pi, j = 1. Set the threshold t to 1/2.
The cost of increasing any value in P is n, since donations are distributed evenly across issues for a given voter. We want to know whether there is a set of bribes of cost at most b · n = B such that The Lobby’s agenda passes. This holds if and only if there are b voters that can be bribed so that they vote uniformly according to The Lobby’s agenda and that is sufﬁcient to pass all the issues. Thus, the given instance (E, b) is in OL if and only if the constructed instance (P,CP, B,t) is in VB-SM-PLP, which shows that OL is a polynomial-time recognizable special case of VB-SM-PLP, and thus VB-SM-PLP is NP-hard.
16

Problem
MB-SM-PLP-WIW MB-AM-PLP-WIW VB-SM-PLP-WIW VB-AM-PLP-WIW

Classical Complexity
NP-complete NP-complete NP-complete NP-complete

Parameterized Complexity

Budget

Budget per Issue

Budget & Discr. Level

FPT

?

FPT

?

FPT W[2]-complete∗

?

W[2]-hard

(FPT) (FPT) FPT FPT

Stated in or implied by Thm./Cor.
4.6, 5.6 4.6, 5.6 4.7, 5.7, 5.8, 5.9 4.7, 5.8, 5.7

Table 2: Complexity results for X-Y-PLP-WIW, where X ∈ {MB, VB} and Y ∈ {SM, AM}

Note that for the construction above it does not matter whether we use the strict-majority crite-

rion (SM) or the average-majority criterion (AM). Since the entries of P are 0 or 1, we have p j > 0.5

if and only if we have a strict majority of ones in the jth column. Thus, VB-AM-PLP is NP-hard,

too.

❑

4.3 Probabilistic Lobbying with Issue Weighting
Table 2 summarizes some of our results for X-Y-PLP-WIW, where X ∈ {MB, VB} and Y ∈ {SM, AM}; again, note that Table 2 does not cover all our results. The most interesting observation from the table is that introducing issue weights raises the complexity from P to NP-completeness for all cases of microbribery (though it remains the same for voter bribery). Nonetheless, we show (Theorem 5.6) that these NP-complete problems are ﬁxed-parameter tractable. Another interesting observation concerns the question of membership in W[2]. In the case indicated by the ∗ annotation, we can show this membership only when we take the lower bound O quantifying the objective of the bribery (in terms of issue weights) as a further parameter. Question marks indicate open problems.
Theorem 4.6 MB-SM-PLP-WIW and MB-AM-PLP-WIW are each NP-complete.
Proof. Membership in NP can be shown with a “guess-and-check” algorithm for both problems.. The argument is analogous to that for NP membership of the problems VB-SM-PLP-WIW and VB-AM-PLP-WIW presented in the proof of Theorem 4.5, except that now we guess a subset E of entries in the given probability matrix P (rather than a subset V of rows of P) along with a corresponding list DE = (d1, d2, . . . , d E ) that collects the amounts of bribery money to be spent on each entry in E.
To prove that MB-SM-PLP-WIW is NP-hard, we give a reduction from the well-known NPcomplete problem KNAPSACK (see, e.g., [GJ79]) to the problem MB-SM-PLP-WIW. In KNAPSACK, we are given a set of objects U = {o1, . . . , on} with weights w : U → N and proﬁts p : U → N, and W, P ∈ N. The question is whether there is a subset I ⊆ {1, . . . , n} such that ∑i∈I w(oi) ≤ W and ∑i∈I p(oi) ≥ P. Given a KNAPSACK instance (U, w, p,W, P), create an MB-SM-PLP-WIW instance with k = 0 and only one voter, v1, where for each issue, v1’s acceptance probability is either zero or one. For each object o j ∈ U , create an issue r j such that the acceptance probability of v1 is zero. Let the cost of raising this probability on r j be c1, j(1) = w(o j) and let the weight of issue r j be w j = p(o j). Let The Lobby’s budget be W and its objective value be O = P. Set the threshold
17

t to 1/2. By construction, there is a subset I ⊆ {1, . . . , n} with ∑i∈I w(oi) ≤ W and ∑i∈I p(oi) ≥ P if

and only if there is a subset I ⊆ {1, . . . , n} with ∑i∈I c1,i(1) ≤ W and ∑i∈I wi ≥ O.

As the reduction introduces only one voter, there is no difference between the evaluation criteria

SM and AM. Hence, the above reduction works for both problems.

❑

Turning now to voter bribery with issue weighting, note that an immediate consequence of Theorem 4.5 is that VB-SM-PLP-WIW and VB-AM-PLP-WIW are NP-hard, since they are generalizations of VB-SM-PLP and VB-AM-PLP, respectively. Again, membership in NP can be seen using appropriate “guess-and-check” algorithms for the more general problems.

Corollary 4.7 VB-SM-PLP-WIW and VB-AM-PLP-WIW each are NP-complete.

5 Parameterized Complexity Results
In this section, we study the parameterized complexity of our probabilistic lobbying problems. Parameterized hardness is usually shown by proving hardness for the levels of the W-hierarchy (with respect to parameterized reductions). Indeed, this hierarchy may be viewed as a “barometer of parametric intractability” [DF99, p. 14]. The lowest two levels of the W-hierarchy, W[0] = FPT and W[1], are the parameterized analogues of the classical complexity classes P and NP. We will show completeness results for the W[2] level of this hierarchy.
In parameterized complexity, the standard parameterization for minimization problems is an upper bound on the entity to be minimized. In our case, this is the budget B. Since in the voter bribery model, the money is equally distributed over all referenda, it also makes sense to consider the upper bound B/n, i.e., the budget per referendum, as a natural, derived parameter. Another natural way of parameterization is derived from certain properties of the input, be they implicit or explicit. In our case, the discretization level can be considered as such a parameter, in particular, since the smallest discretization level has been already considered before within the OPTIMAL LOBBYING problem [CFRS07]. Therefore, we examine all three of these parameterizations in order to understand the effect the choice of parameterizations has on the complexity of the problems.
5.1 Voter Bribery
Theorem 5.1 VB-SM-PLP and VB-AM-PLP (parameterized by the budget and by the discretization level) are in FPT.
Proof. Consider an instance of VB-Y-PLP, Y ∈ {SM, AM}, i.e., we are given n referenda and m voters, as well as a cost matrix CP (with either −− or integer entries), a discretization level k, a budget B, and a threshold t. Recall that the target vector Z of The Lobby is assumed to be 1n. Hence, the rows of CP are monotonically nondecreasing (after possibly some −− entries). Observe that any successful bribe of any voter needs at least n dollars, since the money is evenly distributed among all referenda, and at least one dollar is needed to inﬂuence the chosen voter’s votes for all referenda. Hence, B ≥ n. We can assume that any entry in CP is limited by B + 1, after replacing

18

every entry bigger than B by B + 1. Notice that the entry B + 1 reﬂects that the intended bribery

cannot be afforded.

Although k could be bigger than B, the interesting area of each row in CP (containing integer

entries) cannot have more than B strict increases in the sequence. We therefore encode each row in

CP by a sequence (k1, b1, k2, b2, . . . , kℓ, bℓ), ℓ ≤ B, which reads as follows: By investing b j dollars, we

proceed to column number ∑i≤ j ki. Note that k is given in unary in the original instance (implicitly

by giving the cost matrix CP), and that each k j can be encoded with log k bits. Hence, we extract

from CP for each voter v a submatrix SP(v) with n ≤ B rows (for the referenda) and at most 2B

columns (encoding the “jumps” in the integer sequence as described above). This matrix with at

most B rows and at most 2B columns can be alternatively viewed as a matrix with at most B rows and

at most B columns, where each matrix entry consists of a pair of numbers, one between 1 and B + 1 and one of size at most log k. Therefore, we can associate with each voter at most (B + 1 + log k)B2

distinct submatrices SP(v) of this kind, called voter proﬁles. It makes no sense to store more than B voters with the same proﬁle. Hence, we can assume that m ≤ B · (B + 1 + log k)B2. Therefore, all
relevant parts of the input are bounded by a function in the parameters B and k,5 so that a brute-force

algorithm can be used to solve the instance. This shows that the problem is in FPT.

❑

If we assume that the discretization level is a rather small number, the preceding theorem says that the problems VB-SM-PLP and VB-AM-PLP can be solved efﬁciently in practice. Although we were not able to establish an FPT result for VB-AM-PLP when the discretization level is not part of the parameter (but only the budget is), we can overcome this formal obstacle for VB-SM-PLP, as the following result shows.

Theorem 5.2 VB-SM-PLP (parameterized by the budget) is in FPT.

Proof. Let an instance of VB-SM-PLP be given. From the given cost matrix CP, we extract the

information W (i, j) that gives the minimum amount of money The Lobby must spend on voter vi to

turn his or her voting behavior on issue r j in favor of The Lobby’s agenda, eventually raising the

corresponding voting probability beyond the given threshold t. Each entry in W (i, j) is between 0

and B. Moreover, as argued in the previous proof, there are no more than B issues and we again

deﬁne a voter proﬁle (this time the ith row of the table W (i, j) gives such a proﬁle) for each voter,

and we need to keep at most B voters with the same proﬁle. Hence, no more than B(B + 1)B voters

are present in the instance. Therefore, some brute-force approach can be used to show membership

in FPT.

❑

The area of parameterized complexity leaves some freedom regarding the choice of parameterization. The main reason that the standard parameterization (referring to the entity to be minimized, in this case the budget) yields an FPT result is the fact that the parameter is already very big compared to the overall input (e.g., the number of issues n) by the very deﬁnition of the problem: Since the money given to one voter will be evenly distributed among the issues and since the cost matrix contains only integer entries, it makes no sense at all to spend less than n dollars on a voter. Hence, the budget should be at least n dollars (assuming that some of the voters must be inﬂuenced by The
5In technical terms, this means that we have derived a so-called problem kernel for this problem.

19

Lobby to achieve their agenda). This obstacle can be sidestepped by changing the parameterization to B/n, i.e., to the “budget per issue” (see, e.g., Theorem 5.3). Note that another way would be allowing rational numbers as entries in the cost matrix but we will not consider this in this paper but rather focus on the previous one.
Theorem 5.3 VB-SM-PLP (parameterized by the budget per issue) is W[2]-complete.
Proof. W[2]-hardness can be derived from the proof of Theorem 4.5. Recall that in the proof of this theorem an instance (E, b) of OL was reduced to an instance of VB-SM-PLP, with budget B = n · b. Hence, the parameter “budget per issue” of that VB-SM-PLP instance equals b. Therefore, the reduction in the proof of Theorem 4.5 preserves the parameter and hence W[2]-hardness follows from the W[2]-hardness of OL, see [CFRS07]. Moreover, the instance of VB-SM-PLP produced by the reduction has discretization level zero.
To show membership in W[2], we reduce VB-SM-PLP to SMNTMC, which was deﬁned in Section 3. To this end, it sufﬁces to describe how a nondeterministic multi-tape Turing machine can solve such a lobbying problem.
Consider an instance of VB-AM-PLP: a probability matrix P ∈ Qm[0×,1n] with a cost matrix CP, a budget B, and a ﬁxed threshold t. We may identify t with a certain step level for the price functions.
The reducing machine works as follows. From P, CP, and t, the machine extracts the information Hi, j(d), 1 ≤ d ≤ B, where Hi, j(d) is true if pi, j ≥ t or if ci, j(t) ≤ d/n. Note that the bribery money is evenly distributed across all issues, also note that Hi, j(d) captures whether paying d dollars to voter vi helps to raise the acceptance probability of vi on referendum r j above the threshold t. Moreover, for each referendum r j, the reducing machine computes the minimum number of voters that need to switch their opinion so that majority is reached for that speciﬁc referendum; let s( j) denote this threshold for r j. Since the cost matrix contains integer entries, meaningfully bribing s voters costs at least s · n dollars; only then each referendum will receive at least one dollar per voter. Hence, a referendum with s( j) > B/n yields a NO instance. We can therefore replace any value s( j) > B/n by the value ⌊B/n⌋ + 1.
From Hi, j(d), the reducing machine produces (basically by sorting) another winning table Wi(ℓ) that lists for voter vi those referenda where the acceptance probability of vi on referendum r j is raised above the threshold t by paying to vi the amount of ℓ · n dollars but not by paying (ℓ − 1) · n dollars. Note that we can assume that the bribery money is spent in multiples of n, the number of referenda, since spending n dollars on some voter means spending one dollar per issue for that voter. This table is initialized by Wi(0) listing those referenda already won at the very beginning, although this is not an important issue due to the information contained in s( j).
The nondeterministic multi-tape Turing machine M we describe next has, in particular, access to Wi(ℓ) and to s( j). M has n + 1 working tapes Tj, 0 ≤ j ≤ n, all except one of which correspond to issues r j, 1 ≤ j ≤ n. We will use the set of voters, V = {v1, . . . , vm}, as part of the work alphabet. The (formal) input tape of M is ignored.
M starts by writing s( j) symbols # onto tape j for each j, 1 ≤ j ≤ n. By using parallel writing steps, this needs at most ⌊B/n⌋ + 1 steps, since s( j) ≤ ⌊B/n⌋ + 1 as argued above. We also need an “information hiding” trick here: every time the machine writes a # symbol, it moves the writing head, so that in the next step the head will read a blank symbol. The trick is required in order to keep
20

the transition table small: basically, we cannot insert in the transition table 2n different instructions

to take into account all different congurations of blank and # symbols on the n tapes.

Second, for each i ∈ {1, . . . , m}, M writes ki symbols vi from the alphabet V on the zeroth tape, T0, such that ∑mi=1 ki ≤ B/n. This is the nondeterministic guessing phase where the amount of bribery
money spent on each voter, namely ki · n for voter vi, is determined. The ﬁnite control is used to ensure that a word from the language {v1}∗ · {v2}∗ · · · {vm}∗ is written on tape T0.

In the third phase, M reads tape T0. In its ﬁnite control, M stores the “current voter” whose

bribery money is read. For each voter vi, a counter ci is provided (within the ﬁnite memory of

M). If a symbol vi is read, ci is incremented, and then M moves in parallel all the heads on the

tapes Tj, where j is contained in Wi(ci). Hence, the string on tape T0 is being processed in at most

B/n (parallel) steps.

Finally, it is checked if the left border is reached (again) for all tapes Tj, j > 0. This is the case

if and only if the guessed bribery was successful.

❑

The W[2]-hardness proof for VB-AM-PLP is analogous. Recall that VB-SM-PLP is the same as VB-AM-PLP if the discretization level is zero. So, we conclude:

Corollary 5.4 VB-AM-PLP (parameterized by the budget per issue) is W[2]-hard.

Membership in W[2] is an open problem for VB-AM-PLP when parameterized by the budget per issue. In contrast, we show deﬁnitive parameterized complexity results for different parameterizations.

Theorem 5.5 VB-SM-PLP and VB-AM-PLP (parameterized by the budget per issue and by the discretization level) are W[2]-complete.

Proof. As mentioned above, we already have hardness for a discretization level of zero, i.e., when the second parameter is ﬁxed to the lowest possible value. We implicitly show membership in W[2] for VB-SM-PLP in Theorem 5.3 when the second parameter only plays a role in the polynomial
part of the run time estimate. Hence, the claim is a simple corollary of what we have already shown
above. It remains to prove membership in W[2] for VB-AM-PLP. This can be seen by modifying the
proof of Theorem 5.3. To show membership in W[2], we reduce VB-AM-PLP to SMNTMC. So, it sufﬁces to describe how a nondeterministic multi-tape Turing machine can solve such a lobbying
problem. Consider an instance of VB-SM-PLP: a probability matrix P ∈ Q[m0×,1n] with a cost matrix CP, a
budget B, and a ﬁxed threshold t. Again, we may identify t with a certain step level for the price
functions.
From this input, the reducing machine computes the following:

• It does some preprocessing, so that it is guaranteed that the overall money that could be meaningfully invested on any voter is bounded by ⌈B/n⌉, which is the ﬁrst parameter. No

21

larger amount of money is available, anyhow. Conﬁdence steps that cannot be reached at all are modeled by requiring an investment of (all in all) ⌊B/n⌋ + 1 dollars on that voter for each issue.
• It computes the entity s( j) that now denotes the number of conﬁdence steps issue r j has to be raised in total to ensure a win of that referendum. Notice that s( j) can be assumed to be bounded by the product of the ﬁrst parameter, more precisely, by ⌊B/n⌋ + 1 (as argued before), and the second parameter, more precisely, by k + 1: Each bribe (to whatever voter v) of n dollars (recall that we can again rely on bribery money being used in multiples of n, the number of issues) will raise v’s conﬁdence in voting according to the agenda of The Lobby by at most k + 1 steps.
• It ﬁnally computes Wi(ℓ) which now gives the list of issues whose conﬁdence is raised when investing ℓ · n dollars on vi (compared to (ℓ − 1) · n dollars), plus the number of conﬁdence steps by which the corresponding issue is raised.

The nondeterministic multi-tape Turing machine M we describe next has, in particular, access

to Wi(ℓ) and to s( j). M has n + 1 working tapes Tj, 0 ≤ j ≤ n, all except one of which correspond

to issues r j, 1 ≤ j ≤ n. We will use the set of voters, V = {v1, . . . , vm}, as part of the work alphabet.

The (formal) input tape of M is ignored.

M starts by writing s( j) symbols # onto tape j for each j, 1 ≤ j ≤ n. By using parallel writing

steps, this needs at most f (B/n, k) := (⌊B/n⌋ + 1) (k + 1) steps, since s( j) ≤ f (B/n, k) as argued above.

The “information hiding” trick works as before.

Second, for each i ∈ {1, . . . , m}, M writes ki symbols vi from the alphabet V on the zeroth tape, T0, such that ∑mi=1 ki ≤ B/n. This is the nondeterministic guessing phase where the amount of bribery
money spent on each voter, namely ki · n for voter vi, is determined. The ﬁnite control is used to ensure that a word from the language {v1}∗ · {v2}∗ · · · {vm}∗ is written on tape T0.

In the third phase, M reads tape T0. In its ﬁnite control, M stores the “current voter” whose

bribery money is read. For each voter vi, a counter ci is provided (within the ﬁnite memory of M).

If a symbol vi is read, ci is incremented, and then M moves in parallel all the heads on the tapes Tj,

where j is contained in Wi(ci); notice that the number of steps each head has to move is now also

stored in Wi(ci). Hence, the string on tape T0 is being processed in at most f (B/n, k) (parallel) steps.

Finally, it is checked if the left border is reached (again) for all tapes Tj, j > 0. This is the case

if and only if the guessed bribery was successful.

❑

5.2 Probabilistic Lobbying with Issue Weighting
Recall from Theorem 4.6 that MB-SM-PLP-WIW and MB-AM-PLP-WIW are NP-complete. We now show that each of these problems is ﬁxed-parameter tractable when parameterized by the budget. To this end, recall the KNAPSACK problem that was deﬁned in the proof of Theorem 4.6: Given two ﬁnite lists of binary encoded integers, (ci)ni=1 (a list of costs) and (pi)ni=1 (a list of proﬁts) associated to a list (oi)ni=1 of objects, as well as two further integers, C and P (both encoded in binary), the question is whether there is a subset J of {1, . . . , n} such that ∑i∈J ci ≤ C and ∑i∈J pi ≥ P.
22

Thus, putting all objects from {o j | j ∈ J} into your backpack does not violate your cost constraint C but does satisfy your proﬁt demand P. KNAPSACK is an NP-hard problem that allows a pseudopolynomial time algorithm. More precisely, this means that if all cost and proﬁt values are given in unary, a polynomial-time algorithm can be provided by using dynamic programming (see [KPP04] for details). This yields PTAS results both for the minimization version MIN-KNAPSACK (where the goal is to minimize the costs, subject to the proﬁt lower bound) and for the maximization version MAX-KNAPSACK (where the goal is to maximize the proﬁts, subject to the cost upper bound).

Theorem 5.6 MB-SM-PLP-WIW and MB-AM-PLP-WIW (parameterized by the budget or by the objective) are in FPT.

Proof. Since the unweighted variants of both problems are in P, we can compute the amount d j of

dollars to be spent to win referendum r j in polynomial time in both cases. The interesting cases are

the weighted ones. We re-interpret the given MB-Y-PLP-WIW instance, where Y ∈ {SM, AM},

as a KNAPSACK instance.

In the MB-Y-PLP-WIW instance, every issue r j has an associated cost d j and weight w j. The

aim is to ﬁnd a set of issues, i.e., a set J ⊆ {1, . . . , n}, such that ∑ j∈J d j ≤ B and ∑ j∈J w j ≥ O. Consider r j as an object o j in a KNAPSACK instance with cost c j = d j and proﬁt p j = w j, with

the bounds C = B and P = O. Then the J ⊆ {1, . . . , n} that is a solution to the MB-Y-PLP-WIW

instance is also a solution to the KNAPSACK instance, and vice-versa. Furthermore, the pseudopolynomial algorithm that solves KNAPSACK in time O(n2|B|), where |B| denotes the length of the

encoding of B, also solves MB-Y-PLP-WIW.

Observe that the given reduction works for both SM and AM because we introduce only one referendum. We now use the pseudo-polynomial algorithm to solve KNAPSACK in time O(n2|O|),

where |O| denotes the length of the encoding of O.

❑

Voter bribery with issue weighting keeps its complexity status for both evaluation criteria. Since we can incorporate issue weights into brute-force computations, we have the following corollary to Theorems 5.1 and 5.2.

Corollary 5.7 1. VB-SM-PLP-WIW and VB-AM-PLP-WIW (parameterized by the budget and by the discretization level) are in FPT.
2. VB-SM-PLP-WIW (parameterized by the budget) is in FPT.

It is not hard to transfer the W[2]-hardness results from the unweighted to the weighted case. However, it is unclear to us if or how the membership proofs of the preceding section transfer. The difﬁculty appears to lie in the weights that the reducing machine or the produced Turing machine would have to handle. Since it is not known in advance which items will be bribed to meet the objective requirement O, the summation of item weights cannot be performed by the reducing machine, but must be done by the produced nondeterministic multi-tape Turing machine. However, this Turing machine may only use time that can be measured in the parameter, which has been budget per issue in the unweighted case. We do not see how to do this. Therefore, we can state only the following.

23

Corollary 5.8 VB-SM-PLP-WIW and VB-AM-PLP-WIW (parameterized by the budget per issue) are W[2]-hard.
Theorem 5.9 VB-SM-PLP-WIW (parameterized by the budget per issue and by the objective) is in W[2].
Proof. Membership in W[2] is a bit more tricky than in the unweighted case from Theorem 5.3. To show membership in W[2], we reduce VB-SM-PLP-WIW to SMNTMC. We describe how a nondeterministic multi-tape Turing machine M can solve such a lobbying problem.
Consider an instance of VB-SM-PLP-WIW: a probability matrix P ∈ Q[m0×,1n] with a cost matrix CP, a budget B, and a ﬁxed threshold t, as well as an objective O. We may again identify t with a certain step level for the price functions.
We describe the work of the reducing machine in the following.
• The reducing machine calculates the difference O′ between the target weight and the sum of the weights of the referenda that are already won.
• The reducing machine replaces issue weights bigger than O′ with O′ + 1.
• The reducing machine eliminates all referenda that are already won.
• For each referendum that is not already won, the reducing machine introduces a special letter ri to be used on tape T0 of the Turing machine to be constructed.
For simplicity, we assume in the following that O′ = O, i.e., the reduction steps described above have not changed the instance.
After these steps, all the weights are bounded by the second parameter. Moreover, recall that by the problem deﬁnition, the weight associated to each issue is at least one.
Otherwise, the reducing machine works as described in the proof of Theorem 5.3. In particular, from P, CP, and t, the machine extracts the information Hi, j(d), 1 ≤ d ≤ B, and then s( j) (per r j) and ﬁnally the winning table Wi(ℓ).
We now describe how the Turing machine M works.
• M begins by guessing ν ≤ O referenda that should also be won. (Recall that the weight associated to each issue is at least one, so guessing more than O referenda is not necessary.) Then, M spends O( f (O)) time calculating whether winning those guessed referenda rγ(1), . . . , rγ(ν), ν ≤ O, would be sufﬁcient to exceed the threshold O. If not, M halts and rejects, otherwise it continues working.
• The mentioned threshold test can be implemented as follows: M guesses at most O referenda and writes the corresponding symbols on tape T0. It ﬁrst checks if all guessed referenda are pairwise different. If not, M stops and rejects. Otherwise, M writes a special symbol O − 1 times on the second tape, T1, and moves its head on this tape to the right. Then, it moves its head w j steps to the left on tape T1 (replacing the special symbol by the blank symbol again) upon reading symbol r j on tape T0. The threshold O is passed if and only if the blank symbol
24

is read on T1 after processing rγ(ν) on tape T0. Notice that tape T1 will be empty again after this phase, while tape T0 will still contain the guessed referenda. Observe that the time needed by the Turing machine M depends only on O.
• M will then continue to work as described in the proof of Theorem 5.3. During this phase, the weights will be completely ignored. In particular, this part of M can be produced in polynomial time by the reducing machine. As can be seen in the proof of Theorem 5.3, the time needed by M in this phase depends only on B/n.
• Finally, M will verify if all (at most O) referenda guessed initially have been won. In contrast to the proof of Theorem 5.3, this test can now be implemented in a sequential fashion (upon reading r j on tape T0, the corresponding test is performed on tape Tj), needing time dependent on O.

This concludes the proof sketch.

❑

It might be that W[2] is not the smallest class in the W-hierarchy where the problem discussed in the preceding theorem could be placed. However, we do not know how to ﬁnd an FPT or W[1] algorithm for it, even in the case when all weights equal one. This is in contrast to the possibly related problem PARTIAL t-DOMINATION, which asks whether there is a set of at most k vertices in a graph that dominates at least t vertices. Our belief that these two problems are related is motivated by the fact that the classical dominating set problem was the starting point of the reduction showing hardness for OPTIMAL LOBBYING. Kneis, Mo¨lle, and Rossmanith showed that the problem PARTIAL t-DOMINATION is in FPT even when parameterized by the threshold parameter t alone [KMR07].

6 Approximability
As seen in Tables 1 and 2, many problem variants of probabilistic lobbying are NP-complete. Hence, it is interesting to study them not only from the viewpoint of parameterized complexity, but also from the viewpoint of approximability.
The budget constraint on the bribery problems studied so far gives rise to natural minimization problems: Try to minimize the amount spent on bribing. For clarity, let us denote these minimization problems by preﬁxing the problem name with MIN, leading to, e.g., MIN-OL.
6.1 Voter Bribery is Hard to Approximate
The already-mentioned reduction of Christian et al. [CFRS07] (that proved that OL is W[2]-hard) is parameter-preserving (regarding the budget). The reduction also has the property that a possible solution found in the OL instance can be re-interpreted as a solution to the DOMINATING SET instance that the reduction started with, and the OL solution and the DOMINATING SET solution are of the same size. This in particular means that inapproximability results for DOMINATING SET transfer to inapproximability results for OL. Similar observations are true for the interrelation of SET COVER and DOMINATING SET, as well as for OL and VB-SM-PLP-WIW (or VB-AM-PLP-WIW).

25

The known inapproximability results [BGLR93, RS97] for SET COVER hence give the following result (see also Footnote 4 in [SSGL02]).

Theorem 6.1 There is a constant c > 0 such that MIN-OL is not approximable within factor c·log n unless NP ⊂ DTIME(nlog logn), where n denotes the number of issues.

Since OL can be viewed as a special case of both problem VB-Y-PLP and problem VB-Y-PLP-WIW for Y ∈ {SM, AM}, we have the following corollary.

Corollary 6.2 For Y ∈ {SM, AM}, there is a constant cY > 0 such that both MIN-VB-Y-PLP and MIN-VB-Y-PLP-WIW are not approximable within factor cY ·log n unless NP ⊂ DTIME(nloglogn),
where n denotes the number of issues.

Proof. The proof of Theorem 4.5 explains in detail how to interpret an instance of OL as a

VB-Y-PLP instance, Y ∈ {SM, AM}. The relation B = n · b between the budget B and the number

of voters b holds for both optimum and approximate solutions. Hence, the n is canceled out when

looking at the approximation ratio.

❑

Conversely, a logarithmic-factor approximation can be given for the minimum-budget versions of all our problems, as we will show now. We ﬁrst discuss the relation to the well-known SET COVER problem, sketching a tempting, yet ﬂawed reduction and pointing out its pitfalls. Avoiding these pitfalls, we then give an approximation algorithm for MIN-VB-AM-PLP. Moreover, we deﬁne the notion of cover number, which allows to state inapproximability results for MINVB-AM-PLP. Similar results hold for MIN-VB-SM-PLP, the constructions are sketched at the end of the section.
Voter bribery problems are closely related to set cover problems, in particular in the averagemajority scenario, so that we should be able to carry over approximability ideas from that area. The intuitive translation of a MIN-VB-AM-PLP instance into a SET COVER instance is as follows: The universe of the derived SET COVER instance should be the set of issues, and the sets (in the SET COVER instance) are formed by considering the sets of issues that could be inﬂuenced (by changing a voter’s opinion) through bribery of a speciﬁc voter. Namely, when we pay voter v a speciﬁc amount of money, say d dollars, he or she will credit d/n dollars to each issue and possibly change v’s opinion (or at least raise v’s acceptance probability to some “higher level”). The weights associated with the sets of issues correspond to the bribery costs that are (minimally) incurred to lift the issues in the set to some “higher level.” There are four differences to classical set covering problems:
1. Multiple voters may cover the same set of issues (with different bribing costs).
2. The sets associated with one voter are not independent. For each voter, the sets of issues that can be inﬂuenced by bribing that voter are linearly ordered by set inclusion. Moreover, when bribing a speciﬁc voter, we have to ﬁrst inﬂuence the “smaller sets” (which might be expensive) before possibly inﬂuencing the “larger ones”; so, weights are attached to set differences, rather than to sets.

26

3. A cover number c(r j) is associated with each issue r j, indicating by how many levels voters must raise their acceptance probabilities in order to arrive at average majority for r j. The cover numbers can be computed beforehand for a given instance. Then, we can also associate cover numbers with sets of issues (by summation), which ﬁnally leads to the cover number N = ∑nj=1 c(r j) of the whole instance.
4. The money paid “per issue” might not have been sufﬁcient for inﬂuencing a certain issue up to a certain level, but it is not “lost”; rather, it would make the next bribery step cheaper, hence (again) changing weights in the set cover interpretation.
To understand these connections better, let us have another look at our running example (under voter bribery with average-majority evaluation, i.e., MIN-VB-AM-PLP), assuming an all-ones target vector. If we paid 30 dollars to voter v1, he or she would credit 10 dollars to each issue, which would raise his or her acceptance probability for the second issue from 0.3 to 0.4; no other issue level is changed. Hence, this would correspond to a set containing only r2 with weight 30. Note that by this bribery, the costs for raising the acceptance probability of voter v1 to the next level would be lowered for the other two issues. For example, spending 15 more dollars on v1 would raise r3 from 0.5 to 0.6, since all in all 45 dollars have been spent on voter v1, which means 15 dollars per issue. If the threshold is 60% in that example, then the ﬁrst issue is already accepted (as desired by The Lobby), but the second issue has gone up from 0.5 to only 0.55 on average, which means that we have to raise either the acceptance probability of one voter by two levels (for example, by paying 210 dollars to voter v1), or we have to raise the acceptance probability of each voter by one level (by paying 30 dollars to voter v1 and another 30 dollars to voter v2). This can be expressed by saying that the ﬁrst issue has a cover number of zero, and the second has a cover number of two.
When we interpret an OL instance as a VB-AM-PLP instance, the cover number of the resulting instance equals the number of issues, assuming that the votes for all issues need amendment. Thus we have the following corollary:
Corollary 6.3 There is a constant c > 0 such that MIN-VB-AM-PLP is not approximable within factor c · log N unless NP ⊂ DTIME(NloglogN), where N is the cover number of the given instance. A fortiori, the same statement holds for MIN-VB-AM-PLP-WIW.
Let H denote the harmonic sum function, i.e., H(r) = ∑ri=1 1/i. It is well known that H(r) = O(log r). More precisely, it is known that
ln r ≤ H(r) ≤ ln r + 1.
We now show the following theorem.
Theorem 6.4 MIN-VB-AM-PLP can be approximated within a factor of ln(N) + 1, where N is the cover number of the given instance.
Proof. Consider the greedy algorithm shown in Figure 1, where t is the given threshold and we assume that The Lobby has the all-ones target vector. Note that the cover numbers (per referendum)
27

Input: A probability matrix P ∈ Q[m0×,1n] (implicitly specifying a set V of m voters and a set R of n referenda), a cost matrix CP, a treshold t, and n cover numbers c(r1), . . . , c(rn) ∈ N.
1. Delete referenda that are already won (indicated by c(r j) = 0), and modify R and CP accordingly.
2. If R = 0/ then output the amount spent on bribing so far and STOP.
3. For each voter v, compute the least amount of money, dv, that could raise any level in CP. Let nv be the number of referenda whose levels are raised when spending dv dollars on voter v.
4. Bribe voter v such that dv/nv is minimum.
5. Modify CP by subtracting dv/n from each amount listed for voter v.
6. Modify c by subtracting one from c(r) for those referenda r ∈ R inﬂuenced by this bribery action.
7. Recurse.
Figure 1: Greedy approximation algorithm for MIN-VB-AM-PLP in Theorem 6.4
can be computed from the cost matrix CP and the threshold t before calling the algorithm the very ﬁrst time.
Observe that our greedy algorithm inﬂuences voters by raising their acceptance probabilities by only one level, so that the amount dv possibly spent on voter v in Step 3 of the algorithm actually corresponds to a set of referenda; we do not have to consider multiplicities of issues (raised over several levels) here.
Let S1, . . . , Sℓ be the sequence of sets of referenda picked by the greedy bribery algorithm, along with the sequence v1, . . . , vℓ of voters and the sequence d1, . . . , dℓ of bribery dollars spent this way. Let R1 = R, . . . , Rℓ, Rℓ+1 = 0/ be the corresponding sequence of sets of referenda, with the accordingly modiﬁed cover numbers ci. Let j(r, k) denote the index of the set in the sequence inﬂuencing referendum r the kth time with k ≤ c(r), i.e., r ∈ S j(r,k) and |{i < j(r, k) | r ∈ Si}| = k − 1. To cover r the kth time, we have to pay χ(r, k) = / dj(r,k) |Sj(r,k)| dollars. The greedy algorithm will incur a cost of χgreedy = ∑r∈R ∑ck(=r1) χ (r, k) in total.
An alternative view of the greedy algorithm is from the perspective of the referenda: By running the algorithm, we implicitly deﬁne a sequence s1, . . . , sN of referenda, where N = c(R) = ∑r∈R c(r) is the cover number of the original instance, such that S1 = {sλ(1), . . . , sρ(1)}, S2 = {sλ(2), . . . , sρ(2)}, . . . , Sℓ = {sλ(ℓ), . . . , sρ(ℓ)}, where λ , ρ : {1, . . . , ℓ} → {1, . . . , N} are functions such that λ (i) gives the element of Si with the smallest subscript and ρ(i) gives the element of Si with the greatest
28

subscript for each i, 1 ≤ i ≤ ℓ:

λ (i) = 1 + ∑ |S j| and ρ(i) = ∑ |S j|.

j<i

j≤i

Ties (how to list elements within any Si) are broken arbitrarily. Slightly abusing notation, we associate a cost χ′(si) with Si for each i, (keeping in mind the multiplicities of covering implied by the sequence Si i), so that χgreedy = ∑Ni=1 χ′(si). Note that di = ∑λ(i)≤ j≤ρ(i) χ′(s j).
Consider s j with λ (i) ≤ j ≤ ρ(i). The current referendum set Ri has cover number N − λ (i) + 1, i.e., of at least N − j + 1. Let χopt be the cost of an optimum bribery strategy C ∗ of the original universe. C ∗ also yields a cover of the referendum set Ri with cost at most χopt. The average

cost per element (taking into account multiplicities as given by the cover numbers) is χopt/c(Ri). (So,

whether or not some new levels are obtained through bribery does not really matter here.)

C ∗ can be described by a sequence of sets of referenda C1, . . . ,Cq, with corresponding voters

z1, . . . , zq

and

dollars

d1∗, . . . , dq∗

spent.

Hence,

χopt

=

∑

q κ

=

1

dκ∗

.

With

each

bribery

step

we

associate

the cost factor dκ∗/|Cκ |, for each issue r contained in Cκ . C ∗ could be also viewed as a bribery strategy

for Ri. By the pigeon hole principle, there is a referendum r in Ri (to be inﬂuenced the kth time) with cost factor at most dκ∗/|Cκ ∩Ri| ≤ χopt/c(Ri), where κ is the index such that Cκ contains r for the kth time in C ∗ (usually, the cost would be smaller, since part of the bribery has already been paid

before). Since (Si, vi) was picked so as to minimize di/|Si|, we ﬁnd di/|Si| ≤ dκ∗/|Cκ ∩Ri| ≤ χopt/c(Ri).

We conclude that

χ ′(s j) ≤ χopt = χopt ≤ χopt . c(Ri) N − λ (i) + 1 N − j + 1

Hence,

∑ ∑ N

N

χgreedy = χ ′(s j) ≤

χopt = H(N)χopt ≤ (ln(N) + 1)χopt,

j=1

j=1 N − j + 1

which completes the proof.

❑

In the strict-majority scenario (SM), cover numbers would have a different meaning—we thus call them strict cover numbers: For each referendum, the corresponding strict cover number tells in advance how many voters have to change their opinions (bringing them individually over the given threshold t) to accept this referendum. Again, the strict cover number of a problem instance is the sum of the strict cover numbers of all given referenda.
The corresponding greedy algorithm would therefore choose to inﬂuence voter vi (with di dollars) in the ith loop so that vi changes his or her opinion on some referendum r j such that di/|ρj| is minimized.6
We can now read the approximation bound proof given for the average-majority scenario nearly literally as before, by re-interpreting the formulation “inﬂuencing referendum r” meaning now a complete change of opinion for a certain voter (not just gaining one level somehow). This establishes the following result.
6Possibly, there is a whole set ρ j of referenda inﬂuenced this way.

29

Theorem 6.5 MIN-VB-SM-PLP can be approximated within a factor of ln(N) + 1, where N is the strict cover number of the given instance.
Note that this result is in some sense stronger than Theorem 6.4 (which refers to the averagemajority scenario), since the cover number of an instance could be larger than the strict cover number.
This approximation result is complemented by a corresponding hardness result.
Theorem 6.6 There is a constant c > 0 such that MIN-VB-SM-PLP is not approximable within factor c · log N unless NP ⊂ DTIME(NloglogN), where N is the strict cover number of the given instance. A fortiori, the same statement holds for MIN-VB-SM-PLP-WIW.
Unfortunately, those greedy algorithms do not (immediately) transfer to the case when issue weights are allowed. These weights might also inﬂuence the quality of approximation, but a simplistic greedy algorithm might result in covering the “wrong” issues. Also, the proof of the approximation factor given above will not carry over, since we need as one of the proof’s basic ingredients that an optimum solution can be interpreted as a partial one at some point. Those problems tend to have a different ﬂavor.
6.2 Polynomial-Time Approximation Schemes
Those problems for which we obtained FPT results in the case of issue weights actually enjoy a polynomial-time approximation scheme (PTAS) when viewed as minimization problems.7 The proof of Theorem 5.6 yields a PTAS. That result was obtained by transferring pseudo-polynomial time algorithms: For each ﬁxed value of the parameter (the budget B or the objective O), we obtain a polynomial-time algorithm for the decision problem, which can be used to approximate the minimization problem.
Theorem 6.7 Both MIN-MB-SM-PLP-WIW and MIN-MB-AM-PLP-WIW admit a PTAS.
Proof. We provide some of the details for MIN-MB-SM-PLP-WIW only. As in the proof of Theorem 5.6, we ﬁrst compute the amount, d j, to be spent to win referendum r j in polynomial time. We then re-interpret the given instance of MIN-MB-SM-PLP-WIW as a MIN-KNAPSACK instance. After this re-interpretation, every issue r j has an associated cost d j and weight w j. The aim is to ﬁnd a set of issues, i.e., a set J ⊆ {1, . . . , n}, such that ∑ j∈J w j ≥ O and ∑ j∈J d j is minimum. Consider r j as an object o j in a MIN-KNAPSACK instance with cost c j = d j and proﬁt p j = w j, with the bound P = O. Then the subset J ⊆ {1, . . . , n} that is a solution to the MB-SM-PLP-WIW instance is also a solution to the KNAPSACK instance, and vice-versa. Furthermore, the PTAS algorithm that approximates MIN-KNAPSACK also gives a PTAS for MB-SM-PLP-WIW. ❑
7A polynomial-time approximation scheme is an algorithm that for each pair (x, ε), where x is an instance of an optimization problem and ε > 0 is a rational constant, runs in time polynomial in |x| (for each ﬁxed value of ε) and outputs an approximate solution for x within a factor of 1 + ε.
30

Let us mention here that the issue-weighted problem variants are actually bicriteria problems: We want to achieve as much as possible (expressed by the objective O) and pay as little as possible (expressed by the budget B). So, we could also consider this as a maximization problem (where now B becomes again part of the input). By the close relation to KNAPSACK mentioned above, the pseudo-polynomial time algorithms again result in PTAS results for this model:
Theorem 6.8 Both MAX-MB-SM-PLP-WIW and MAX-MB-AM-PLP-WIW admit a PTAS.
It would be interesting to study this optimization criterion in the light of other bribery scenarios.

7 Conclusions
This paper lies at the intersection of three research streams: computational social choice, reasoning under uncertainty, and computational complexity. It lays the foundation for further study of vote inﬂuencing in stochastic settings. We have shown that uncertainty complicates the picture; the choice of model strongly affects computational complexity.
We have studied four lobbying scenarios in a probabilistic setting, both with and without issue weights. Among these, we identiﬁed problems that can be solved in polynomial time, problems that are NP-complete yet ﬁxed-parameter tractable, and problems that are hard (namely, W[2]-complete or W[2]-hard) in terms of their parameterized complexity with suitable parameters. We also investigated the approximability of hard probabilistic lobbying problems (without issue weights) and obtained both approximation and inapproximability results.
An interesting direction for future work would be to study the parameterized complexity of such problems under different parameterizations. We would also like to investigate the open question of whether one can ﬁnd logarithmic-factor approximations for voter bribery with issue weights.
From the viewpoint of parameterized complexity, it would be interesting to solve the questions left open in this paper (see the question marks in Tables 1 and 2), in particular regarding voter bribery under average majority, with and without issue weighting, parameterized by the budget or by the budget per issue. The parameterized complexity of the problems involving microbribery with issue weighting, under either strict majority or average majority, parameterized by the budget per issue, is an open issue as well (again, see Table 2). In fact, we did not see how to put these problems in any level of the W-hierarchy. Problems that involve numbers seem to have a particular ﬂavor that makes them hard to tackle with these techniques [FGR10], but we suggest this as the subject of further studies. Note that all probabilistic lobbying problems that have been connected with W[2] somehow in this paper are in fact strongly NP-hard, i.e., their hardness does not depend on whether the numbers in their inputs are encoded in unary or in binary. We suspect that this adds to the difﬁculty when dealing with these problems from a parameterized perspective.

References

[BEH+10]

D. Baumeister, G. Erde´lyi, E. Hemaspaandra, L. Hemaspaandra, and J. Rothe. Computational aspects of approval voting. In J. Laslier and R. Sanver, editors, Handbook on Approval Voting, chapter 10, pages 199–251. Springer, 2010.

31

[BFH+08]
[BGLR93]
[BKdV93] [BKdV96] [BO91] [BTT89a] [BTT89b] [BTT92] [Ces03] [CFRS07] [Cro02] [CS03]
[CSL07] [DF99] [DKNS01] [EFG+09]
[EL05]

E. Brelsford, P. Faliszewski, E. Hemaspaandra, H. Schnoor, and I. Schnoor. Approximability of manipulating elections. In Proceedings of the 23rd AAAI Conference on Artiﬁcial Intelligence, pages 44–49. AAAI Press, July 2008.
M. Bellare, S. Goldwasser, C. Lund, and A. Russell. Efﬁcient probabilistically checkable proofs and applications to approximations. In Proceedings of the 25th ACM Symposium on Theory of Computing, pages 294–304. ACM Press, May 1993.
M. Baye, D. Kovenock, and C. de Vries. Rigging the lobbying process: An application of the all-pay auction. The American Economic Review, 83(1):289–294, 1993.
M. Baye, D. Kovenock, and C. de Vries. The all-pay auction with complete information. Economic Theory, 8(2):291–305, 1996.
J. Bartholdi III and J. Orlin. Single transferable vote resists strategic voting. Social Choice and Welfare, 8(4):341–354, 1991.
J. Bartholdi III, C. Tovey, and M. Trick. The computational difﬁculty of manipulating an election. Social Choice and Welfare, 6(3):227–241, 1989.
J. Bartholdi III, C. Tovey, and M. Trick. Voting schemes for which it can be difﬁcult to tell who won the election. Social Choice and Welfare, 6(2):157–165, 1989.
J. Bartholdi III, C. Tovey, and M. Trick. How hard is it to control an election? Mathematical and Computer Modelling, 16(8/9):27–40, 1992.
M. Cesati. The Turing way to parameterized complexity. Journal of Computer and System Sciences, 67:654–685, 2003.
R. Christian, M. Fellows, F. Rosamond, and A. Slinko. On complexity of lobbying in multiple referenda. Review of Economic Design, 11(3):217–224, 2007.
C. Crombez. Information, lobbying and the legislative process in the European Union. European Union Politics, 3(1):7–32, 2002.
V. Conitzer and T. Sandholm. Universal voting protocol tweaks to make manipulation hard. In Proceedings of the 18th International Joint Conference on Artiﬁcial Intelligence, pages 781– 788. Morgan Kaufmann, August 2003.
V. Conitzer, T. Sandholm, and J. Lang. When are elections with few candidates hard to manipulate? Journal of the ACM, 54(3):Article 14, 2007.
R. Downey and M. Fellows. Parameterized Complexity. Springer-Verlag, Berlin, Heidelberg, New York, 1999.
C. Dwork, R. Kumar, M. Naor, and D. Sivakumar. Rank aggregation methods for the web. In Proceedings of the 10th International World Wide Web Conference, pages 613–622. ACM Press, May 2001.
G. Erde´lyi, H. Fernau, J. Goldsmith, N. Mattei, D. Raible, and J. Rothe. The complexity of probabilistic lobbying. In Proceedings of the 1st International Conference on Algorithmic Decision Theory, pages 86–97. Springer-Verlag Lecture Notes in Artiﬁcial Intelligence #5783, October 2009.
E. Elkind and H. Lipmaa. Small coalitions cannot manipulate voting. In Proceedings of the 9th International Conference on Financial Cryptography and Data Security, pages 285–297. Springer-Verlag Lecture Notes in Computer Science #3570, February/March 2005.

32

[ENR09]

G. Erde´lyi, M. Nowak, and J. Rothe. Sincere-strategy preference-based approval voting fully resists constructive control and broadly resists destructive control. Mathematical Logic Quarterly, 55(4):425–443, 2009.

[EPR11]

G. Erde´lyi, L. Piras, and J. Rothe. The complexity of voter partition in Bucklin and fallback voting: Solving three open problems. In Proceedings of the 10th International Joint Conference on Autonomous Agents and Multiagent Systems. IFAAMAS, May 2011. To appear.

[ER97]

E. Ephrati and J. Rosenschein. A heuristic technique for multi-agent planning. Annals of Mathematics and Artiﬁcial Intelligence, 20(1–4):13–67, 1997.

[ER10]

G. Erde´lyi and J. Rothe. Control complexity in fallback voting. In Proceedings of Computing: the 16th Australasian Theory Symposium, pages 39–48. Australian Computer Society Conferences in Research and Practice in Information Technology Series, January 2010.

[Fel09]

M. Fellows. Towards fully multivariate algorithmics: Some new results and directions in parameter ecology. In J. Fiala, J. Kratochv´ıl, and M. Miller, editors, Proceedings of the 20th International Workshop on Combinatorial Algorithms, pages 2–10. Springer-Verlag Lecture Notes in Computer Science #5874, June 2009.

[FG06]

J. Flum and M. Grohe. Parameterized Complexity Theory. EATCS Texts in Theoretical Computer Science. Springer-Verlag, 2006.

[FGR10]

M. Fellows, S. Gaspers, and F. Rosamond. Parameterizing by the number of numbers. In V. Raman and S. Saurabh, editors, Proceedings of the 5th International Symposium on Parameterized and Exact Computation, pages 123–134. Springer-Verlag Lecture Notes in Computer Science #6478, December 2010.

[FHH09]

P. Faliszewski, E. Hemaspaandra, and L. Hemaspaandra. How hard is bribery in elections? Journal of Artiﬁcial Intelligence Research, 35:485–532, 2009.

[FHHR07]

P. Faliszewski, E. Hemaspaandra, L. Hemaspaandra, and J. Rothe. Llull and Copeland voting broadly resist bribery and control. In Proceedings of the 22nd AAAI Conference on Artiﬁcial Intelligence, pages 724–730. AAAI Press, July 2007.

[FHHR08]

P. Faliszewski, E. Hemaspaandra, L. Hemaspaandra, and J. Rothe. Copeland voting fully resists constructive control. In Proceedings of the 4th International Conference on Algorithmic Aspects in Information and Management, pages 165–176. Springer-Verlag Lecture Notes in Computer Science #5034, June 2008.

[FHHR09a] P. Faliszewski, E. Hemaspaandra, L. Hemaspaandra, and J. Rothe. Llull and Copeland voting computationally resist bribery and constructive control. Journal of Artiﬁcial Intelligence Research, 35:275–341, 2009.

[FHHR09b]

P. Faliszewski, E. Hemaspaandra, L. Hemaspaandra, and J. Rothe. A richer understanding of the complexity of election systems. In S. Ravi and S. Shukla, editors, Fundamental Problems in Computing: Essays in Honor of Professor Daniel J. Rosenkrantz, chapter 14, pages 375–406. Springer, 2009.

[FHHR09c]

P. Faliszewski, E. Hemaspaandra, L. Hemaspaandra, and J. Rothe. The shield that never was: Societies with single-peaked preferences are more open to manipulation and control. In Proceedings of the 12th Conference on Theoretical Aspects of Rationality and Knowledge, pages 118–127. ACM Press, July 2009.

33

[GJ79]

M. Garey and D. Johnson. Computers and Intractability: A Guide to the Theory of NPCompleteness. W. H. Freeman and Company, 1979.

[GMHS99]

S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: The anatomy of recommender systems. In Proceedings of the 3rd Annual Conference on Autonomous Agents, pages 434–435. ACM Press, 1999.

[HH07]

E. Hemaspaandra and L. Hemaspaandra. Dichotomy for voting systems. Journal of Computer and System Sciences, 73(1):73–83, 2007.

[HHLBS09] Frank Hutter, Holger Hoos, Kevin Leyton-Brown, and Thomas Stu¨tzle. ParamILS: An automatic algorithm conﬁguration framework. Journal of Artiﬁcial Intelligence Research, 36:267– 306, 2009.

[HHR97]

E. Hemaspaandra, L. Hemaspaandra, and J. Rothe. Exact analysis of Dodgson elections: Lewis Carroll’s 1876 voting system is complete for parallel access to NP. Journal of the ACM, 44(6):806–825, 1997.

[HHR07]

E. Hemaspaandra, L. Hemaspaandra, and J. Rothe. Anyone but him: The complexity of precluding an alternative. Artiﬁcial Intelligence, 171(5–6):255–285, 2007.

[HHR09]

E. Hemaspaandra, L. Hemaspaandra, and J. Rothe. Hybrid elections broaden complexitytheoretic resistance to control. Mathematical Logic Quarterly, 55(4):397–424, 2009.

[HSV05]

E. Hemaspaandra, H. Spakowski, and J. Vogel. The complexity of Kemeny elections. Theoretical Computer Science, 349(3):382–391, 2005.

[KMR07]

J. Kneis, D. Mo¨lle, and P. Rossmanith. Partial vs. complete domination: t-dominating set. In J. van Leeuwen, G. Italiano, W. van der Hoek, C. Meinel, H. Sack, and F. Plasil, editors, Proceedings of the 33nd Conference on Current Trends in Theory and Practice of Computer Science, pages 367–376. Springer-Verlag Lecture Notes in Computer Science #4362, February 2007.

[KPP04]

H. Kellerer, U. Pferschy, and D. Pisinger. Knapsack Problems. Springer-Verlag, Berlin, Heidelberg, New York, 2004.

[LR08]

C. Lindner and J. Rothe. Fixed-parameter tractability and parameterized complexity, applied to problems from computational social choice. In A. Holder, editor, Mathematical Programming Glossary. INFORMS Computing Society, October 2008.

[MPRZ08] R. Meir, A. Procaccia, J. Rosenschein, and A. Zohar. Complexity of strategic behavior in multi-winner elections. Journal of Artiﬁcial Intelligence Research, 33:149–178, 2008.

[Nie06]

R. Niedermeier. Invitation to Fixed-Parameter Algorithms. Oxford University Press, 2006.

[Nie10]

R. Niedermeier. Reﬂections on multivariate algorithmics and problem parameterization. In J.-Y. Marion and T. Schwentick, editors, Proceedings of the 27th International Symposium on Theoretical Aspects of Computer Science, volume 5 of Leibniz International Proceedings in Informatics (LIPIcs), pages 17–32. Schloss Dagstuhl—Leibniz-Zentrum fu¨r Informatik, March 2010.

[PR07]

A. Procaccia and J. Rosenschein. Junta distributions and the average-case complexity of manipulating elections. Journal of Artiﬁcial Intelligence Research, 28:157–181, 2007.

[Rei83]

J. Reinganum. A formal theory of lobbying behaviour. Optimal Control Applications and Methods, 4(4):71–84, 1983.

34

[RS97]

R. Raz and S. Safra. A sub-constant error-probability low-degree test, and a sub-constant errorprobability PCP characterization of NP. In Proceedings of the 29th ACM Symposium on Theory of Computing, pages 475–484. ACM Press, 1997.

[RSV03]

J. Rothe, H. Spakowski, and J. Vogel. Exact complexity of the winner problem for Young elections. Theory of Computing Systems, 36(4):375–386, 2003.

[SSGL02]

T. Sandholm, S. Suri, A. Gilpin, and D. Levine. Winner determination in combinatorial auction generalizations. In Proceedings of the 1st International Joint Conference on Autonomous Agents and Multiagent Systems, pages 69–76. ACM Press, July 2002.

[vNM44]

J. von Neumann and O. Morgenstern. Theory of Games and Economic Behavior. Princeton University Press, 1944.

[XHHLB08] Lin Xu, Frank Hutter, Holger Hoos, and Kevin Leyton-Brown. SATzilla: Portfolio-based algorithm selection for SAT. Journal of Artiﬁcial Intelligence Research, 32:565–606, 2008.

[ZPR08]

M. Zuckerman, A. Procaccia, and J. Rosenschein. Algorithms for the coalitional manipulation problem. In Proceedings of the 19th ACM-SIAM Symposium on Discrete Algorithms, pages 277–286. Society for Industrial and Applied Mathematics, January 2008. Extended version to appear in Artiﬁcial Intelligence.

35

