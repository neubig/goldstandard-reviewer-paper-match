arXiv:1207.0120v5 [cs.CR] 22 Oct 2014

Distributed Secret Dissemination Across a Network
Nihar B. Shah, K. V. Rashmi and Kannan Ramchandran, Fellow, IEEE Department of Electrical Engineering and Computer Sciences University of California, Berkeley {nihar, rashmikv, kannanr}@eecs.berkeley.edu
Abstract
Shamir’s (n, k) threshold secret sharing is an important component of several cryptographic protocols, such as those for secure multiparty-computation and key management. These protocols typically assume the presence of direct communication links from the dealer to all participants, in which case the dealer can directly pass the shares of the secret to each participant. In this paper, we consider the problem of secret sharing when the dealer does not have direct communication links to all the participants, and instead, the dealer and the participants form a general network. Existing methods are based on secure message transmissions from the dealer to each participant requiring considerable coordination in the network. In this paper, we present a distributed algorithm for disseminating shares over a network, which we call the SNEAK algorithm, requiring each node to know only the identities of its onehop neighbours. While SNEAK imposes a stronger condition on the network by requiring the dealer to be what we call k-propagating rather than k-connected as required by the existing solutions, we show that in addition to being distributed, SNEAK achieves signiﬁcant reduction in the communication cost and the amount of randomness required.
I. INTRODUCTION
Shamir’s classical (n, k) secret sharing scheme [2] is an essential ingredient of several cryptographic protocols. The scheme considers a set of (n + 1) entities: a dealer and n honest-but-curious participants. The dealer possesses a secret s and wishes to pass functions (called shares) of this secret to the n participants, such that the following two properties are satisﬁed:
• k-secret-recovery: the shares of any k participants sufﬁce to recover the secret, • (k − 1)-collusion-resistance: the aggregate data gathered by any (k − 1) nodes reveals no knowledge (in the
information-theoretic sense) about the secret.
Several cryptographic protocols in the literature require execution of one or more instances of secret sharing among all the participants. These include protocols for secure multiparty-computation [3]–[6], secure key management [7], [8], general Byzantine agreement between all participants [3], [9]–[11], proactive secret sharing [12], [13], and secure archival storage [14]. For instance, under the celebrated Ben-Or-Goldwasser-Wigderson (BGW) protocol [3] for secure-multiparty function computation, the initialization step requires n instances of secret sharing with all participants, and every multiplication operation requires 2n additional instances.
Most protocols including those listed above assume that the dealer has direct secure communication links to every participant. In this case, the dealer can compute the shares as per Shamir’s scheme [2] and directly pass the shares to the respective participants. Such a setting is depicted in Fig. 1a for the parameters (n = 6, k = 2). In many situations, however, the dealer may not have direct communication links with every participant; instead, the dealer and the participants may form a general network. Fig. 1b depicts such a scenario. The network is described by a graph G with (n + 1) nodes. These (n + 1) nodes comprise the dealer and the n participants. An edge in this graph implies a communication link between its two end-points, while the absence of an edge denotes the non-existence of any direct communication link. We make the standard assumption that the communication links
This paper was presented, in part, at the IEEE International Symposium on Information Theory 2013 [1]. The work of Nihar B. Shah was supported by a Berkeley Fellowship and that of K. V. Rashmi was supported by a Facebook Fellowship.

2

1

1

3

5

s+r

6 s + 6r s + 2r 2

s + 5r D s + 3r

5

3

D

2

4

6

s + 4r

4
(b) Dealer and participants form a general network

(a) Dealer has communication links to all participants

Fig. 1: Shamir’s secret sharing for k = 2 and n = 6. (a) All participants (1, . . . , 6) are connected directly to the dealer (D), allowing the dealer to directly pass the shares. The share of participant i (1 ≤ i ≤ 6) is s + ir, where s is the secret and r is a value chosen uniformly at random from the ﬁnite ﬁeld of operation F7. (b) The dealer and the participants form a general network, where the dealer cannot pass shares directly to participants 3, 4, 5 and 6.

between the participants are secure. We will say that a participant is ‘directly connected to the dealer’ if there exists an edge from the dealer to that participant.
Under a general network G, all communication between the dealer and any participant who is not directly connected to it, must pass through other participants in the network. This poses the challenge of not leaking any additional information to any participant while disseminating the shares over the network.
Existing methods use separate secure message transmissions (SMT) from the dealer to each participant across the network [15]. Under such a solution, in order to communicate the designated share to a participant, the dealer treats this share as a secret, employs Shamir’s scheme to compute k shares of this secret, and communicates these k shares to the participant through k node-disjoint paths. (This solution is described in more detail in Section III-B.) Thus solution requires a signiﬁcant coordination in the network in setting up the node-disjoint paths from the dealer to every participant. It also incurs a high communication cost, since the dealer needs to transmit shares across the network separately for every participant.
In this paper, we present a distributed and communication-efﬁcient algorithm for secret share dissemination across a network, which we call SNEAK1. We analyze the performance of SNEAK and compare it to the state-of-the-art, i.e., the SMT-based solution. In addition to being distributed, SNEAK provides signiﬁcant gains in terms of the communication cost and the amount of randomness required. On the other hand, while the SMT-based solution requires the graph to satisfy a certain “k-connected-dealer” condition (which is in fact necessary for the feasibility of secret sharing), SNEAK imposes a stronger condition on the network, which we call the k-propagating-dealer condition, that will be formalized in the sequel.
We now present a toy example illustrating the existing SMT-based solution and SNEAK proposed in this paper.
Example 1: Consider the network depicted in Fig. 1b. Let n = 6 and k = 2, with the alphabet of operation as the ﬁnite ﬁeld F7. Under Shamir’s scheme of encoding the secret s, the share ti (1 ≤ i ≤ 6) for participant i is
ti = s + ir ,
where r is a value chosen by the dealer uniformly at random from the alphabet F7. While the dealer can directly pass the shares t1 and t2 to participants 1 and 2 respectively, the difﬁculty arises in communicating shares to the remaining participants with whom the dealer does not have direct communication links. For instance, if the dealer tries to pass share t3 to participant 3 by simply communicating t3 along the path ‘dealer → 1 → 3’, then participant 1 gains access to two shares, t1 and t3. Using these two shares, participant 1 can recover the secret s, thus violating the (k − 1)-collusion resistance requirement.
1‘SNEAK’ standing for ‘Secret-sharing over a Network with Efﬁcient communication And distributed Knowledge-of-topology’.

s+r 1 3 5

r+ra 1
s+r,

D
s+2r
2

D s+
2r, r+ 2r
a

4

6

2

3 4

1 s+3r+r3 3 5
3r+r 3 s+
D
r3

(s+r)+3(r+ra)
1 (=(s+3r)+(r+3ra)) 3 D

r)+ 3(r

)+2(r +2r

+3r a )

a ))

5

3

6 5

(s+3r

(= (s+2

r3 r5

2

4

6

s+4r+r4

1 s+4r+r4 3 5
4r+r 4 s+

D

D

r4

2 r4 4 6

1 s+5r+r5 3 s+5r+r5 5
5r+r 5 s+

D

D

r5

2 r5 4 6

s+6r+r6

1 s+6r+r6 3 s+6r+r6 5
6r+r 6 s+
DD
r6

2 r6

r6

4

6

2

(s+2r)+4(r+2ra) 4

6

(=(s+4r)+2(r+4ra))

1 3 (s+3r)+5(r+3ra) 5
(=(s+5r)+3(r+5ra))

3r a) )+4(r+ +4ra)) (s+3r 4r)+3(r (=(s+

2 1

4 3

6 5

(=(s(s++4r)+ 5 r)+4(5r(r+4ra ) +5r a ))

2 1

(s+4r)+6(r+4ra)
4 (=(s+6r)+4(r+6ra)) 6

3

5

r a) 6(r+5 6ra)) 5r)+ 5(r+ (s+ 6r)+ (=(s+

2

4

6

(a)

(b)

Fig. 2: Secret sharing across the network of Fig. 1b, for n=6 and k=2: (a) the SMT-based solution, employing separate secure message transmissions from the dealer to each participant, and (b) our new SNEAK. The text on an edge is the data passed by the node with the lower index to the node with the higher index. See Example 1 for more details.

The SMT-based solution is illustrated in the sequence of steps depicted in Fig. 2a. In order to pass the share t3 to participant 3, the dealer chooses another random value r3, passes (t3 + r3) along the path ‘dealer → 1 → 3’, and r3 along the path ‘dealer → 2 → 3’. Now, participant 3 can recover t3, and no participant gains any additional information about the secret s in this process. In a similar manner, the dealer can communicate ti (4 ≤ i ≤ 6) to participant i through k = 2 node-disjoint paths as shown in the ﬁgure.
Observe that the SMT-based solution transmits data across several hops in the network in every step, but the data transmitted in any step is never used in subsequent steps of the protocol. Thus, in order to design an efﬁcient and distributed algorithm, one may wish to propagate data in a manner that allows its subsequent reuse downstream.

4
This is the key idea underlying SNEAK proposed in this paper, which is illustrated in the sequence of steps in Fig. 2b. Here, the dealer ﬁrst draws two values r and ra uniformly at random from F7. The dealer then passes the two values (s + r) and (r + ra) to node 1, and the two values (s + 2r) and (r + 2ra) to node 2. Upon receiving its data, each node passes a particular linear combination of its received data to each of its downstream neighbours. For instance, node 1 passes (s + r) + 3(r + ra) to node 3, which can equivalently be written as (s + 3r) + (r + 3ra). Node 2 passes (s + 2r) + j(r + 2ra) (= (s + jr) + 2(r + jra)) to node j ∈ {3, 4} respectively. Node 3 can thus recover the two values (s + 3r) and (r + 3ra) from the data it receives. Similarly, as shown in the sequence of steps depicted in Fig. 2b, every node i ∈ {1, . . . , 6} can recover its requisite share (s + ir), along with a random counterpart (r + ira) which is used to disseminate shares further downstream. Note that in Fig. 2b, the expression written above an edge is the linear combination that is transmitted, and the corresponding expression written in the parenthesis below that edge is a simple rewriting of the data transmitted.
We can see that SNEAK is completely distributed requiring knowledge of only one-hop neighbours as opposed to the SMT-based solution which requires the knowledge of the global topology in order to set-up communication over node-disjoint paths. Also, SNEAK requires a communication of only 12 values, as opposed to 24 under the SMT-based solution. The number of random values generated under SNEAK is only 2, whereas the SMT-based solution requires generation of 5 random values.
The remainder of the paper is organized as follows. Section II provides a formal description of the system model and summarizes the results of this paper. Section III reviews related literature. Section IV describes SNEAK. Section V presents a comparative analysis of the SMT-based solution, SNEAK, and the lower bounds in terms of the communication-cost and the randomness requirements. Section VI presents conclusions and discusses open problems.
II. SYSTEM MODEL AND SUMMARY OF RESULTS
A. Secret Sharing in a General Network
The dealer possesses a secret s that is drawn from some alphabet A, and wishes to pass shares of this secret to n participants. The dealer and the participants form a communication network, denoted by graph G. The graph G has (n + 1) nodes comprising the dealer and the n participants, and an edge in the graph denotes a secure and private communication link between the two end-points. Thus, at times, we will also refer to a participant as a node of the graph. We will also use the terms ‘network’ and ‘graph’ interchangeably, and ‘link’ and ‘edge’ interchangeably. The problem is to design a protocol which will allow the dealer to pass shares (of the secret) to the n participants, meeting the requirements of (k − 1)-collusion-resistance and k-secret-recovery (described in Section I). All the participants are assumed to be honest-but-curious, i.e., they follow the protocol correctly, but may store any accessible data in order to gain information about the secret. The edges in the graph G are allowed to be directed or undirected: a directed edge implies existence of only a one way communication link, while an undirected edge implies direct communication links both ways. The parameters n and k are assumed to satisfy n ≥ k > 1, since n ≤ k − 1 prohibits the secret from ever being recovered, while k = 1 degenerates the problem into a trivial case wherein no secrecy is required.
We now discuss a condition that the graph G must necessarily satisfy for any algorithm to successfully perform secret sharing on it, which directly follows from [15].
Deﬁnition 1 (m-connected-dealer): A graph with (n + 1) nodes (the dealer and n participants) satisﬁes the mconnected-dealer condition for a positive integer m if each of the n participants in the graph either has an incoming edge directly from the dealer or has at least m node-disjoint paths from the dealer to itself.
Proposition 1 (Necessary condition [15]): For any graph G, a necessary condition for any algorithm to perform (n, k) secret sharing is that G satisﬁes the k-connected-dealer condition.
Thus no algorithm can operate successfully on all network topologies, and must require the graph G to obey at least the k-connected-dealer condition.

5

(a) Layered network

(b) Backbone network

(c) One-dimensional geometric network (e.g., sensors deployed on a border)

Fig. 3: Examples of undirected networks satisfying the 3-propagating-dealer condition. Any node in the network may be the dealer.

B. Class of Networks Considered
We saw above in Proposition 1 that feasibility of secret sharing on a graph G requires G to satisfy the k-connecteddealer condition. SNEAK requires the communication network G to satisfy a stronger condition, which we term the k-propagating-dealer condition.
Deﬁnition 2 (m-propagating-dealer): A graph with (n + 1) nodes (the dealer and n participants) satisﬁes the m-propagating-dealer condition for a positive integer m if there exists an ordering of the n participants in the graph such that every node either has an incoming edge directly from the dealer or has incoming edges from at least m nodes preceding it in the ordering.
As an illustration of the m-propagating-dealer condition, consider the network of Example 1 (Fig. 1b). This network satisﬁes the 2-propagating-dealer condition, with the ordering 1, 2, 3, 4, 5, 6 (observe that this is also the order in which the participants receive their shares under SNEAK as shown in Fig. 2b).
We enumerate below examples of a few classes of graphs that satisfy the m-propagating dealer condition.
Fig. 3 depicts three examples of graphs that satisfy the 3-propagating dealer condition. These examples can be generalized to the following classes of graphs. The ﬁrst three classes consider undirected graphs and permit any of the nodes to be the dealer.
(a) Layered networks (Fig. 3a): Each layer contains at least m nodes, and each node is connected to all nodes in the neighbouring layers. An ordering that satisﬁes the m-propagating-dealer condition is the ordering of the nodes with respect to the distance (in terms of number of hops) from the dealer.
(b) Networks with a backbone (Fig. 3b): A subset of nodes, termed the ‘backbone’, form a densely connected subgraph (that satisﬁes the m-propagating-dealer condition), and every node outside the backbone is connected directly to at least m nodes in the backbone. An ordering that satisﬁes the m-propagating-dealer condition is: the ordering under the backbone subgraph, followed by all remaining nodes not in the backbone in any order.
(c) m-connected one-dimensional geometric networks (Fig. 3c): A one-dimensional geometric network is formed by arranging the nodes (in an arbitrary fashion) along a line, and connecting a pair of nodes by an edge if the distance (number of hops) between is smaller than a ﬁxed threshold. A one-dimensional geometric network that satisﬁes the m-connected-dealer condition also satisﬁes the m-propagating dealer condition. In this case, an ordering that satisﬁes the m-propagating-dealer condition is the arrangement of the nodes in an ascending order of their euclidean distance from the dealer.
(d) Directed acyclic graphs: Any directed acyclic graph that satisﬁes the m-connected-dealer condition also satisﬁes the m-propagating-dealer condition. The root must be the dealer, and any topological ordering of the DAG sufﬁces as the requisite node-ordering. E.g., the directed version of the graph of Fig. 1b, with the edges directed from the left to the right, falls in this class.

6
We note that while the necessity of the k-propagating-dealer condition under SNEAK requires the existence of some such ordering of the nodes, the execution of the algorithm is completely distributed and oblivious to the actual ordering. We also note that while SNEAK requires the graph to satisfy the k-propagating dealer condition, it is robust to the network topology, i.e., it satisﬁes the (k − 1)-collusion-resistance property over any arbitrary network topology. This robustness property is important since the secrecy of the secret is paramount, and in practice, the structure of the network may not be known beforehand. Moreover, under a dynamic network, the graph structure may also vary with time (even during the execution of the algorithm), thus further motivating robustness.
Apart from the parameters n and k, an additional parameter “d” is associated to SNEAK. We saw earlier that the k-connected-dealer condition is necessary for any secret sharing algorithm, and SNEAK requires the k-propagatingdealer condition to be satisﬁed. Now, assuming that these necessary conditions have been met, one would intuitively expect the efﬁciency of the algorithm to be higher if the graph has a higher connectivity. The parameter d captures this intuition: SNEAK takes the parameter d (≥ k) as input, and under the assumption that the graph satisﬁes the d-propagating-dealer condition, achieves a greater communication efﬁciency.
C. Summary of Results
This paper presents a distributed algorithm, called SNEAK, that takes parameters n, k and d (≥ k) as input, and enables a dealer to disseminate shares of a secret to n participants forming a general network G, such that the properties of (i) k-secret-recovery (when G satisﬁes the d-propagating-dealer condition), and (ii) (k − 1)-collusionresistance (irrespective of the network topology) are satisﬁed. The algorithm is completely distributed and each node needs to know only the identities of its neighbours, and it is efﬁcient with respect to the communication cost and the amount of randomness required.
For any (n, k) and any graph G with (n+1) nodes, we derive and compare (a) information-theoretic lower bounds on the total communication cost under any algorithm, (b) lower bounds on the communication cost under the SMTbased solution, and (c) communication cost under SNEAK. Using these results, we establish the communication efﬁciency of SNEAK. SNEAK has particularly useful implications on bounded degree graphs.2 For networks with bounded degree and satisfying the k-propagating-dealer condition, the communication cost of SNEAK is within a constant (multiplicative) factor of the information-theoretic lower bound, and is Θ(n) in the worst-case. In contrast, the communication-cost of the SMT-based solution is lower bounded as Ω(n log n), and is Ω(n2) in the worst case. Moreover, the amount of randomness required under SNEAK is Θ(1), while that required under the SMT-based solution is Θ(n).
Appendix C presents three heuristic techniques to extend SNEAK algorithm to networks where the k-propagatingdealer condition is not satisﬁed. Appendix C also contains an extension of the algorithm to handle active adversaries, and an extension to support two-threshold secret sharing.
D. Notational Conventions
A vector will be treated as a column vector by default, and a row vector will be written as the transpose of the corresponding column vector. The transpose of a vector or a matrix will be denoted by a superscript T . For any integer ≥ 1, [ ] will represent the set {1, . . . , }. For any participant j (1 ≤ j ≤ n), the set of its neighbours will be denoted by N (j). In case of a directed graph, N (j) will denote the set of nodes to which node j has an outgoing edge. The dealer will be denoted as D, and the set of neighbours of the dealer by N (D). We will say that a node j is directly connected to the dealer if j ∈ N (D).
2Bounded degree graphs have their maximum degree upper bounded by a constant that is independent of n.

7

III. RELATED LITERATURE

A. Shamir’s Secret Sharing Protocol

We ﬁrst give a brief review of Shamir’s secret sharing protocol [2]. To this end, we assume that the dealer has a direct (secure) communication link with every participant (as in the example in Fig. 1a).

Assume that the secret s is drawn from some ﬁnite ﬁeld Fq of size q (> n). The dealer chooses (k − 1) values {ri}ki=−11 independently and uniformly at random from Fq. Deﬁne a k-length vector m as 3

mT = [s r1 r2 · · · rk−1] .

(1)

Next, deﬁne a set of n vectors {ψi}ni=1, each of length k, as

ψTi = [1 i i2 · · · ik−1] .

(2)

The share ti of participant i is simply the inner product

ti

=

ψ

T i

m

.

(3)

It can be veriﬁed that the vectors {ψi}i∈I are all linearly independent. It follows that for any set I ⊆ [n] of

cardinality k, the secret s can be recovered from the set of values {ψTi m}i∈I. Furthermore, it can also be veriﬁed

that for any set I

⊆

[n]

of

cardinality

smaller

than

k,

the

set

{ψ

T i

m

}i

∈I

provides no knowledge about s.

Under the assumption that the dealer has direct communication links with each of the n participants, the dealer can simply pass ti to participant i (∈ [n]).

Remark 1: To see the Shamir’s secret sharing scheme in the conventional polynomial representation [2], note that each share ti can be seen as an evaluation of the (k −1) degree polynomial with the secret s as its constant term and the remaining (k − 1) coefﬁcients chosen uniformly at random and independent of the secret. Thus, k evaluations are necessary and sufﬁcient to recover the polynomial and hence the secret. This provides the k-secret-recovery and (k − 1)-collusion-resistance properties.

This completes the description of Shamir’s secret sharing protocol. There are numerous other extensions and generalizations of Shamir’s secret sharing protocol in the literature, and the reader is referred to [16], [17] and references therein for more details. We now describe the SMT-based solution that addresses the situation when the dealer and participants form a general communication network.

B. The SMT-based solution

This section describes a scheme for secret sharing over a general communication network employing secure
message transmissions from dealer to each participant [15]. Fig. 2a in Example 1 is an example of such a solution. Under this solution, the dealer ﬁrst encodes the secret s into n shares {t }n=1 using Shamir’s secret sharing scheme (3). The size q of the underlying ﬁnite ﬁeld Fq is assumed to be greater than n. To every node directly connected to the dealer, the dealer directly passes its share t . To disseminate shares to the remaining nodes, the
dealer performs the following actions, once separately for each remaining node. Let now denote a node that is
not connected directly to the dealer. The dealer applies Shamir’s secret sharing scheme treating t as a secret, and computes k shares {u ,j}kj=1, as

u ,j = [1 j j2 · · · jk−1] [t r ,1 r ,2 · · · r ,k−1]T ,

(4)

where the values {r ,1, . . . , r ,k−1} are chosen independently and uniformly at random from Fq. The dealer then ﬁnds k node-disjoint paths (from itself) to node , and passes u ,j along the jth path (1 ≤ j ≤ k). At the end of

3To suit the description of the algorithm developed subsequently in this paper, we present a matrix-based representation for Shamir’s protocol instead of the customary polynomial based representation. We will remark upon the connection between the two representations in the end.

8
these transmissions, node receives {u ,j}kj=1 from which it can recover its share t . Moreover, since each of the random values are independent, no participant can obtain any information about any other participant’s share, or any additional information about the secret s. This process is repeated once for every node that is not connected directly to the dealer.
The solution described above requires transmission of data across k node-disjoint paths once separately for every node that is not connected directly to the dealer. Thus this solution is not distributed, and furthermore is not efﬁcient in terms of communication and the randomness cost.
We note that the communication efﬁciency of this solution can be improved if more than k node-disjoint paths are available, by employing two-threshold secret sharing [18] over these node-disjoint paths. Under this setting, for any given participant i, let us suppose there are wi (≥ k) node-disjoint paths from the dealer to node i. The dealer chooses a value w (∈ {k, . . . , wi}), encodes the share of participant i into w chunks in a manner [18] that satisﬁes w-secret-recovery and (k −1)-collusion-resistance, and passes these chunks via the w shortest node-disjoint paths to participant i. The dealer chooses w such that the amount of communication in transmitting the share to participant i is minimized; the special case of choosing w = k for all participants is equivalent to the procedure described in the previous paragraphs. The analysis and comparisons performed subsequently in Section V will consider this more efﬁcient two-threshold version of the SMT-based solution.
C. Network Coding and Distributed Storage
The problem of secret sharing over a general communication network can also be cast as a speciﬁc instance of a network coding problem [19], requiring security from eavesdropping on the nodes. This casting can be performed in the following manner. The dealer is the source node, and the secret s is the message. The network graph in the network coding problem is identical to that in the secret sharing problem, but with a set of nk additional nodes that act as the sinks. Each of the nk sinks is connected to a distinct subset of k participants, and has one directed link of inﬁnite capacity coming in from each of the corresponding k participants. Each sink must recover the entire message: this requirement corresponds to the condition of k-secret-recovery. To satisfy the (k − 1)collusion-resistance property, a compromise of upto (k − 1) arbitrary nodes (excluding the source and the sinks) to a passive eavesdropper should reveal no information about the message. In this manner, the secret sharing problem is equivalent to a network coding problem requiring secrecy from an eavesdropper that can gain access to a subset of the nodes. However, with respect to this setting, very little appears to be known in the network coding literature.
To the best of our knowledge, the literature on secure network coding (e.g., [20]–[23]) considers the setting where the eavesdropper gains access to a subset of the links. The problem of node compromise is typically treated as a case of link compromise by allowing the eavesdropper to gain access to all links that are incident upon the compromised nodes. In [22], [23], authors consider the setting wherein a collection of subsets of the links is speciﬁed, and an eavesdropper may gain access to precisely one of these subsets. However, the scheme requires the knowledge of the network topology, and is computationally expensive. Moreover, the scheme requires the graph to satisfy a particular condition, which is almost always violated in our problem setting. Communication-efﬁcient algorithms to secure a network from an eavesdropper having access to a bounded number of links are provided in [20], [21]. Given the network topology, the actions to be performed at the nodes can be derived in a computationally efﬁcient manner. However, these algorithms communicate a message of size equal to the difference between the largest message that can be sent in the absence of secrecy requirements, and the bound on number of compromised links. Under our problem setting, this difference is generally zero or smaller (e.g., the difference is −2 in the network of Fig. 1b), thus rendering these algorithms inapplicable.
The SNEAK algorithm constructed in the present paper thus turns out to be an instance of a secure network coding problem that admits an explicit solution that is distributed, communication efﬁcient, and provides deterministic (probability 1) guarantees. Furthermore, the solution handles the case of nodal eavesdropping, about which very little appears to be known in the literature.
SNEAK is based on a variant of the Product-Matrix codes [24] which were originally constructed for distributed

9
storage systems. These codes possess useful properties that SNEAK exploits in the present context. The productmatrix codes are a practical realization of the concept of ‘Regenerating codes’ [25] proposed for distributed storage. To date, apart from the MDS codes of [26], these are the only known constructions of regenerating codes that are scalable (i.e., other parameters of the system impose no constraints on the total number of nodes in the system). It turns out that this scalability property is an essential ingredient for our problem. Secure versions of the productmatrix codes were constructed in [27], [28]. The reader familiar with the literature on regenerating codes for distributed storage may recognize later in the paper that we employ the minimum-bandwidth (MBR) version, and not the minimum-storage (MSR) version, of the product-matrix codes [24]. We make this choice to guarantee secrecy from honest-but-curious participants, who may store all the data that they receive, a characteristic of the MBR point on the storage-bandwidth tradeoff [25].

IV. ALGORITHM FOR SECRET SHARING OVER GENERAL NETWORKS
This section presents the main result of the paper. Consider a network G that obeys the d-propagating-dealer condition for some parameter d (≥ k). The secret s belongs to the alphabet A, and we assume that A = Fqd−k+1, for any arbitrary ﬁeld size q > n. Thus we can equivalently denote the secret as a vector s = [s1 s2 · · · sd−k+1]T with each element of this vector belonging to the ﬁnite ﬁeld Fq.

A. Initial Setting up by the Dealer

The dealer ﬁrst constructs an (n × d) Vandermonde matrix Ψ, with the ith (1 ≤ i ≤ n) row of Ψ being

ψi = [1 i i2 · · · id−1]T .

(5)

The vector ψi is termed the encoding vector of node i. Next, the dealer constructs a (d × d) symmetric matrix M comprising the secret s and a collection of randomly
generated values as follows:

 sA raT sBT 

M =  ra Rb RcT 

(6)

sB Rc 0

1 k−1 d−k

d
where the depicted sub-matrices of M are

• sA = sd−k+1 is a scalar,

• sB = [s1 · · · sd−k]T is a vector of length (d − k),

• ra is a vector of length (k − 1) with its entries populated by random values,

•

Rb is a ((k − 1) × (k − 1)) symmetric matrix with its

k(k−1) 2

distinct entries populated by random values,

• Rc is a ((d − k) × (k − 1)) matrix with its (k − 1)(d − k) entries populated by random values.

These random values are all picked independently and uniformly from Fq. Note that the total number of random values R in matrix M is

k(k − 1)

R = (k − 1) +

+ (k − 1)(d − k)

2

k−1

= (k − 1)d −

.

(7)

2

The entire secret is contained in the components sA and sB as sT = [s1 · · · sd−k+1] = [sBT sA].

10

Observe that the structure of M as described in (6), along with the symmetry of matrix Rb, makes the matrix M symmetric.

The share tj for participant j (1 ≤ j ≤ n) is a vector of length (d − k + 1):

 sA sBT 

tTj = ψTj  ra RcT  .

(8)

sB 0

We will show subsequently in Theorem 3 that any k of these shares sufﬁce to recover the entire secret.

Remark 2: To see these shares in the conventional polynomial representation of Shamir’s secret sharing scheme, recall that the vector ψTj is drawn from a Vandermonde matrix. Thus each entry of tj in (8) can be seen as the evaluation of a polynomial at value j. Thus there is one polynomial for each secret value si (1 ≤ i ≤ d − k + 1), with the corresponding secret symbol as its constant term and the remaining coefﬁcients independent of the secret
value si.

Example 2: Consider the setting of Example 1 (Fig. 2b) where n = 6, k = 2, d = 2. Here

M= s r , r ra

and for every j (1 ≤ j ≤ n), ψTj = [1 j] and the share for participant j is tTj = [s + jr].

B. Communication across the Network Algorithm 1 describes the communication protocol to securely transmit the shares {tj}nj=1 to the n participants.

Algorithm 1 Communication Protocol Dealer: For every j ∈ N (D), compute and pass the d-length vector ψTj M to participant j.
Participant ∈ N (D): Wait until receipt of data ψT M from the dealer. Upon receipt, perform the following actions. For every j ∈ N ( ), compute the inner product of the data ψT M with the encoding vector ψj of participant j. Transmit the resulting value ψT M ψj to participant j.

Participant ∈/ N (D): Wait until receipt of one value each from any d neighbours, and then perform the

following actions (if more than d neighbours pass data, retain data from some arbitrary d of these nodes).

Denote this set of d neighbours as {i1, . . . , id}, and the values received from them as {σ1, . . . , σd} respectively.

Compute the vector



ψTi

−1   σ1

1

v =  ...   ...  .

ψTid σd

For every neighbour i ∈ N ( ) from whom you did not receive data, compute and pass the inner product vT ψi to participant i.

Remark 3: In order to reduce the communication cost, one would like to ensure that a participant receives data from no more than d of its neighbours. This can be ensured via a simple handshaking protocol between neighbours, wherein a participant who is ready to transmit data to its neighbours, queries the neighbours for the requirement of the respective transmissions, prior to actually sending the data.

Example 3: Consider the setting of Example 1 (Fig. 2b), wherein n = 6, k = 2, d = 2. The values of M , ψj

and tj (1 ≤ j ≤ n) under this setting are speciﬁed in Example 2. For the given network, we have N (D) = {1, 2}.

As

per

Algorithm

1,

participant

j

∈

{1, 2}

receives

ψ

T j

M

=

[s + jr

r + jra] directly from the dealer. Now

let us focus on participant 3. Since participant 3 is a neighbour to participants 1 and 2, following Algorithm 1,

11

participant

j

∈

{1, 2}

passes

ψ

T j

M

ψ

3

=

(s

+

jr)

+

3(r

+

jra)

to

participant

3.

Participant

3

thus

receives

the

two values σ1 = (s + r) + 3(r + ra) and σ2 = (s + 2r) + 3(r + 2ra) from neighbours i1 = 1 and i2 = 2. Using

the fact that ψT1 = [1 1] and ψT2 = [1 2], it computes

1 1 −1 (s + r) + 3(r + ra)

s + 3r

v=

=

.

12

(s + 2r) + 3(r + 2ra)

r + 3ra

A similar procedure is executed at participants 4, 5 and 6 as well.

C. Correctness of the Algorithm

The following theorems show that each participant indeed receives its intended share (8), and the algorithm satisﬁes the properties of k-secret-recovery, and (k−1)-collusion-resistance, and that the (k−1)-collusion-resistance property is also robust to network structure.

Theorem 2 (Successful share dissemination): Under the algorithm presented, every participant ∈ [n] can recover ψT M , and hence obtain its intended share

 sA tT = ψT  ra
sB

sBT  RcT  . 0

Proof: Recall that the graph satisﬁes the d-dealer propagation condition. Let us assume without loss of generality

that the ordering of nodes satisfying this condition is 1, . . . , n. It follows that the ﬁrst d nodes in this ordering

must be connected directly to the dealer. The proof proceeds via induction. The induction hypothesis is as follows: every participant can recover the data ψT M , and if passes any data to any other node j ∈ N ( ) then this data is precisely the value ψT M ψj.

Consider the base case of node 1. Since this node is directly connected to the dealer, it receives the data ψT1 M

from

the

dealer.

Moreover,

following

the

communication

protocol,

it

passes

ψ

T 1

M

ψ

j

to

each

neighbour

j

∈

N (1).

Let us now assume that the hypothesis holds true for the ﬁrst ( − 1) nodes in the ordering. If node is directly

connected to the dealer, then the hypothesis is satisﬁed for this node by an argument identical to the case of node

1. Suppose is not directly connected to the dealer. It follows that node must be connected to at least d other

nodes preceding it in the ordering, and furthermore, must receive data from at least d of these nodes (say, nodes {j1, . . . , jd} ⊆ [ − 1]). By our hypothesis, these d nodes pass the d values {ψTj1M ψ , . . . , ψTjdM ψ }. It follows that the algorithm running at node operates on the input

 σ1   ψTj1   ...  =  ...  M ψ . (9)
σd ψTjd

By construction, the matrix in (9) with ψTj1, . . . , ψTjd as its rows is a (d × d) Vandermonde matrix, and is hence invertible. Thus, the computation of v as described in Algorithm 1 can be performed efﬁciently using standard
Reed-Solomon decoding algorithms [29], [30]. It further follows that v = M ψ , and since M is a symmetric matrix, we get vT = ψT M T = ψT M . Finally, the data passed by node to any other node i ∈ N ( ), according to the protocol, is vT ψi = ψT M ψi. This proves the hypothesis for node .
Due to the speciﬁc structure (6) of M , the desired share t is a subset of the elements of the vector ψT M . Thus,
every participant obtains its intended share.

Theorem 3 (k-secret-recovery): Any k shares sufﬁce to recover the secret.

Proof: Let I ⊆ [n] denote the set of the k participants attempting to recover the secret. Let ΨI be a (k × d)

matrix

with

its

k

rows

comprising

{

ψ

T i

}

i

∈I

.

Further,

let

Ψ˜ I

denote

the

(k × k)

submatrix

of

ΨI

comprising

the

12

ﬁrst k columns of ΨI. Observe that the k participants in I collectively have access to the data

 sA ΨI  ra
sB

sBT  RcT  . 0

Consider the last (d − k) columns of this data, i.e.,

 sBT 

sT

ΨI  RcT  = Ψ˜ I

B T

.

0

Rc

Since ΨI is a (k × d) Vandermonde matrix, it follows that Ψ˜ I is a (k × k) Vandermonde matrix. Thus, Ψ˜ I is

invertible. This allows for the decoding of sB (via algorithms [29], [30] identical to those for decoding under

Shamir’s original secret sharing scheme). It now remains to recover sA, and to this end consider the ﬁrst column

of the data, i.e.,

 sA 

ΨI  ra  .

sB

Since the value of sB is now known, its effect can be subtracted from this data to obtain

 sA 

ΨI  ra  = Ψ˜ I sA .

0

ra

Since Ψ˜ I is invertible, the value of sA can be decoded from this data.

Theorem 4 ((k − 1)-collusion-resistance and robustness): Any set of (k − 1) or fewer colluding participants can gain no information about the secret. This guarantee is robust to network topology, i.e., holds for arbitrary graphs.

The proof of Theorem 4 is provided in Appendix A.

Remark 4: In certain scenarios, the communication network topology may be known beforehand, and it may be desired to verify whether the topology satisﬁes the d-propagating-dealer condition. This task can be performed efﬁciently by simply simulating the communication protocol of SNEAK (Algorithm 1) on the given network: the d-propagating dealer condition is satisﬁed if and only if all nodes receive data from at least d other nodes.

V. COMPLEXITY ANALYSIS AND BOUNDS
In this section, we provide an analysis and comparison of the complexity of SNEAK, the SMT-based solution, and lower bounds for any secret-sharing scheme.
Recall that D denotes the dealer and N (D) denotes the set of neighbours of the dealer (or, in case of directed edges, the set of nodes with edges coming in from the dealer). Let |N (D)| denote the size of this set. We assume without loss of generality that the units of data are normalized with one unit deﬁned to be equal to the size of the secret. We will use the notation Γ(.) to denote communication cost, and ρ(.) to denote amount of randomness required. The proofs of each of the results stated below are available in Appendix B.

A. Communication Cost and Randomness Required

Theorem 5: For an (n, k) secret sharing problem on any graph G with (n+1) nodes satisfying the d-propagating-

dealer condition for some (known) d, SNEAK

(a)

requires

every

node

to

receive

d d−k+1

units

of

data,

and

hence

requires

a

total

communication

of

d ΓSNEAK(G) = n d − k + 1 (10)

13

units of data, and (b) requires an amount of randomness given by
(k − 1)(2d − k) ρSNEAK(G) = 2(d − k + 1) . (11)

Theorem 6: For an (n, k) secret sharing problem on any graph G with (n + 1) nodes, the SMT-based solution

(a) requires a total communication of

w

ΓSMT(G) = |N (D)| +

min

× w(D → i)

(12)

w≥k w − k + 1

i∈/N (D)

units of data, where w(D → i) is the average of the path lengths of the w shortest node-disjoint paths from the dealer to node i (with w(D → i) = ∞ if there do not exist w node-disjoint paths from D to i), and (b) requires an amount of randomness lower bounded by

k−1 ρSMT(G) ≥ k − 1 + wmax(i) − k + 1 (13)
i∈/N (D)

(k − 1)

≥ (n − |N (D)|)

(14)

|N (D)| − (k − 1)

where wmax(i) is the maximum number of node-disjoint paths from the dealer to node i.

Remark 5: The lower bound on the randomness requirement of the SMT-based solution provided in (13) is achievable, however, at the cost of an increased communication cost (the communication cost will be higher than that speciﬁed in (12), wherein the optimal w chosen for every term inside the summation would be replaced by wmax(i)).

From the two theorems stated above, we can see that SNEAK provides the greatest gains over the SMT-based solution when the distance in the graph between the dealer and the participants is large on an average.

The following theorem provides information-theoretic lower bounds under any scheme on the amount of communication and the amount of randomness required, which serves as a benchmark to compare SNEAK and the SMT-based solution.

Theorem 7: For an (n, k) secret sharing problem on any graph G with (n + 1) nodes under any algorithm,

(a) any node ∈ [n] must receive at least

 deg(de)g−( k)+1 if ∈/ N (D) and deg( ) ≥ k 

Γevery( ) ≥ 1

if ∈ N (D)



∞

if ∈/ N (D) and deg( ) < k

(15)

units of data, where deg( ) denotes the number of incoming edges at node . Furthermore, this bound is the best

possible, given only the identities of the neighbours of node . Hence the total communication cost under any

algorithm is lower bounded by

deg(i) Γany(G) ≥ |N (D)| + deg(i) − k + 1 , (16)
i∈/N (D)

≥n

(17)

and (b) the amount of randomness required under any algorithm is lower bounded [31] by

ρany(G) ≥ k − 1 .

(18)

Remark 6: The lower bound (17) can be deduced alternatively from the fact that the share of each participant must be atleast the size of the secret [Theorem 1, [32]].

14

B. Implications for the Case of Bounded Degree Graphs

The SNEAK algorithm has particularly striking implications on secret sharing on graphs whose maximum degree is bounded (independent of n), for example, in the graph depicted in Fig. 3a with the nodes partitioned into ‘layers’ of three nodes each.

As discussed earlier, for any secret sharing algorithm to succeed, the graph must satisfy the d-connected-dealer condition for some d ≥ k. Now, if a graph satisﬁes the d-connected-dealer (or the stronger d-propagating-dealer) condition, the value of d must be upper bounded by the maximum degree of the graph. It follows that the parameters k and d are upper bounded by the maximum degree of the graph, and are therefore independent of n. Theorem 12 and Theorem 13 present the main results for this setting.

Lemma 8: For any given (n, k), and for any given d (k ≤ d < n), consider any undirected graph with (n + 1) nodes such that (a) every non-neighbour of D has a degree of d, and (b) the graph satisﬁes the d-propagatingdealer condition. Under SNEAK, the amount of data received by any node ∈/ N (D) meets the lower bound (15). Furthermore, under SNEAK, the amount of data received by any node ∈ N (D) is independent of n.

Lemma 9: For any given (n, k), and for any given d (k ≤ d < n), there exists a class of graphs such that the

communication cost on graphs belonging to this class is lower bounded by

d

d

Γany(G) ≥ n d − k + 1 − (k − 1) d − k + 1 . (19)

Thus, for the class of graphs considered in Lemma 9, the communication cost of SNEAK (10) is within a constant (additive) factor of the lower bound.

The following two lemmas quantify the performance of the SMT-based solution. Lemma 10 is more general than

that of bounded degree graphs considered in this section: the lemma also applies to graphs whose maximum degree

may grow with n.

Lemma

10:

On

graphs

with

the

maximum

outgoing

degree

O

((log

n

)

1 2

−

))

for

some

> 0, the SMT-based

solution requires a super-linear communication cost. Furthermore, for graphs with degree bounded by a constant

independent of n, the SMT-based solution requires an Ω(n log n) communication cost.

Lemma 11: For any given (n, k), and for any given d (k ≤ d < n), there exists a class of graphs with (n + 1) nodes such that each graph in this class satisﬁes the d-propagating dealer condition, and (n, k) secret sharing on any graph G in this class using the SMT-based solution requires a communication cost lower bounded by
n(n + 1) ΓSMT(G) ≥ 4d . (20)

The following theorem gives a comparison between the SMT-based solution, SNEAK and the lower bounds.

Theorem 12: Consider graphs that satisfy the k-propagating-dealer condition and have their maximum degree upper bounded by a constant independent of n. The the communication cost of SNEAK is within a constant (multiplicative) factor of the information-theoretic lower bound, and is Θ(n) in the worst-case. On the other hand, the communication cost of SMT-based solution is Ω(n log n), and is Ω(n2) in the worst case.

The following result quantiﬁes the amount of randomness required for secret sharing under the SMT-based solution and SNEAK.

Theorem 13: Consider graphs that satisfy the k-propagating-dealer condition and have their maximum degree upper bounded by a constant independent of n. The amount of randomness required under the SMT-based solution is Θ(n), and the amount of randomness required under SNEAK is Θ(1).

VI. CONCLUSIONS AND OPEN PROBLEMS
Many cryptographic protocols in the literature require execution of one or more instances of secret sharing among all the participants. Most of these protocols assume that the dealer has direct communication links to all the

15
participants. This paper presents SNEAK, a distributed and efﬁcient algorithm for secret sharing in a setting where the dealer and the participants form a general communication network. While SNEAK requires the network to satisfy the stronger k-propagating-dealer condition as opposed to the k-connected-dealer condition required by the existing methods, it provides signiﬁcant reduction in the communication cost and the amount of randomness required, in addition to being distributed. The paper also presents information-theoretic lower bounds on the communication cost for secret sharing in general networks, which may be of independent interest.
The upper and lower bounds on the communication cost for secret sharing presented in this paper are shown to be tight for certain classes of networks. However, obtaining (tight) bounds on the communication cost for general networks still remains open. SNEAK requires the network to satisfy the k-propagating dealer condition, and only heuristics are known to address networks that satisfy the k-connected-dealer but not the k-propagatingdealer condition. Designing more efﬁcient algorithms and quantifying the communication requirements for such settings remain open.
Finally, the results of this paper turn out to be an instance of a network coding problem that interestingly admits an explicit solution that is distributed, communication efﬁcient, and provides probability 1 guarantees. Moreover, the solution handles the case of nodal eavesdropping, about which very little appears to be known in the literature. As a part of future work, we wish to investigate if any of the ideas from this speciﬁc case of secure network coding carry over to more general network coding problems.
ACKNOWLEDGEMENTS
Nihar B. Shah was supported by a Berkeley Fellowship and K. V. Rashmi was supported by a Facebook Fellowship. This work was also supported in part by AFOSR grant FA9550-10-1-0567 and in part by NSF grant CCF-0964018. The authors would like to thank Prakash Ishwar, Piyush Srivastava, Anindya De, and Matthieu Finiasz for helpful discussions.
REFERENCES
[1] N. B. Shah, K. V. Rashmi, and K. Ramchandran, “Secure network coding for distributed secret sharing with low communication cost,” in Proc. IEEE International Symposium on Information Theory (ISIT), Istanbul, Jul. 2013.
[2] A. Shamir, “How to share a secret,” Communications of the ACM, vol. 22, no. 11, pp. 612–613, 1979. [3] M. Ben-Or, S. Goldwasser, and A. Wigderson, “Completeness theorems for non-cryptographic fault-tolerant distributed computation,”
in Proceedings of the twentieth annual ACM symposium on Theory of computing, 1988, pp. 1–10. [4] D. Chaum, C. Cre´peau, and I. Damgard, “Multiparty unconditionally secure protocols,” in Proceedings of the twentieth annual ACM
symposium on Theory of computing, 1988, pp. 11–19. [5] R. Cramer, M. Franklin, B. Schoenmakers, and M. Yung, “Multi-authority secret-ballot elections with linear work,” in Advances in
Cryptology–EUROCRYPT, 1996, pp. 72–83. [6] I. Damga˚rd, Y. Ishai, and M. Krøigaard, “Perfectly secure multiparty computation and the computational overhead of cryptography,”
Advances in Cryptology–EUROCRYPT, pp. 445–465, 2010. [7] T. Pedersen, “A threshold cryptosystem without a trusted party,” in Advances in Cryptology–EUROCRYPT, 1991, pp. 522–526. [8] M. Marsh and F. Schneider, “Codex: A robust and secure secret distribution system,” IEEE Transactions on Dependable and Secure
Computing, vol. 1, no. 1, pp. 34–47, 2004. [9] M. Rabin, “Randomized Byzantine generals,” in Foundations of Computer Science, 1983., 24th Annual Symposium on, 1983, pp.
403–409. [10] P. Feldman and S. Micali, “Optimal algorithms for Byzantine agreement,” in Proceedings of the twentieth annual ACM symposium on
Theory of computing. ACM, 1988, pp. 148–161. [11] I. Ingemarsson and G. Simmons, “A protocol to set up shared secret schemes without the assistance of a mutually trusted party,” in
Advances in Cryptology–EUROCRYPT, 1990, pp. 266–282. [12] R. Ostrovsky and M. Yung, “How to withstand mobile virus attacks,” in Proceedings of the tenth annual ACM symposium on Principles
of distributed computing, 1991, pp. 51–59. [13] A. Herzberg, S. Jarecki, H. Krawczyk, and M. Yung, “Proactive secret sharing or: How to cope with perpetual leakage,” Advances in
Cryptology–CRYPT0, pp. 339–352, 1995. [14] M. Storer, K. Greenan, E. Miller, and K. Voruganti, “Potshards: A secure, recoverable, long-term archival storage system,” ACM
Transactions on Storage, vol. 5, no. 2, p. 5, 2009. [15] D. Dolev, C. Dwork, O. Waarts, and M. Yung, “Perfectly secure message transmission,” Journal of the ACM, vol. 40, no. 1, pp. 17–47,
1993.

16

[16] D. R. Stinson, “An explication of secret sharing schemes,” Designs, Codes and Cryptography, vol. 2, no. 4, pp. 357–390, 1992. [17] A. Beimel, “Secret-sharing schemes: a survey,” in Coding and cryptology. Springer, 2011, pp. 11–46. [18] M. Franklin and M. Yung, “Communication complexity of secure computation,” in Proceedings of the twenty-fourth annual ACM
symposium on Theory of computing, 1992, pp. 699–710. [19] R. Ahlswede, N. Cai, S. Li, and R. Yeung, “Network information ﬂow,” IEEE Transactions on Information Theory, vol. 46, no. 4, pp.
1204–1216, 2000. [20] H. Yao, D. Silva, S. Jaggi, and M. Langberg, “Network codes resilient to jamming and eavesdropping,” in IEEE International Symposium
on Network Coding (NetCod), 2010. [21] C. Ngai and R. Yeung, “Secure error-correcting (sec) network codes,” in IEEE Network Coding, Theory, and Applications (NetCod),
2009, pp. 98–103. [22] N. Cai and R. Yeung, “Secure network coding on a wiretap network,” IEEE Transactions on Information Theory, vol. 57, no. 1, pp.
424–435, Jan. 2011. [23] J. Feldman, T. Malkin, C. Stein, and R. Servedio, “On the capacity of secure network coding,” in Proc. 42nd Annual Allerton Conference
on Communication, Control, and Computing, 2004. [24] K. V. Rashmi, N. B. Shah, and P. V. Kumar, “Optimal exact-regenerating codes for the MSR and MBR points via a product-matrix
construction,” IEEE Transactions on Information Theory, vol. 57, no. 8, pp. 5227–5239, Aug. 2011. [25] A. G. Dimakis, P. B. Godfrey, Y. Wu, M. Wainwright, and K. Ramchandran, “Network coding for distributed storage systems,” IEEE
Transactions on Information Theory, vol. 56, no. 9, pp. 4539–4551, 2010. [26] K. V. Rashmi, N. B. Shah, P. V. Kumar, and K. Ramchandran, “Explicit construction of optimal exact regenerating codes for distributed
storage,” in Proc. 47th Annual Allerton Conference on Communication, Control, and Computing, Urbana-Champaign, Sep. 2009, pp. 1243–1249. [27] N. B. Shah, K. V. Rashmi, and P. V. Kumar, “Information-theoretically secure regenerating codes for distributed storage,” in Proc. Globecom, Houston, Dec. 2011. [28] K. V. Rashmi, N. B. Shah, K. Ramchandran, and P. Kumar, “Regenerating codes for errors and erasures in distributed storage,” in Proc. International Symposium on Information Theory, Jul. 2012. [29] R. Blahut, “Theory and practice of error control codes,” 1983. [30] I. Gohberg and V. Olshevsky, “Fast algorithms with preprocessing for matrix-vector multiplication problems,” Journal of Complexity, vol. 10, no. 4, pp. 411–427, 1994. [31] C. Blundo, A. De Santis, and U. Vaccaro, “Randomness in distribution protocols,” Information and Computation, vol. 131, no. 2, pp. 111–139, 1996. [32] E. D. Karnin, J. Greene, and M. E. Hellman, “On secret sharing systems,” Information Theory, IEEE Transactions on, vol. 29, no. 1, pp. 35–41, 1983.

APPENDIX A PROOF OF (k − 1)-COLLUSION-RESISTANCE

Proof of Theorem 4: This proof follows on the lines of the proof of [27, Theorem 1]. Consider execution of
SNEAK on a network having an arbitrary topology. Let J ⊂ [n] denote the set of (k − 1) participants colluding in
an attempt to recover information about the secret s. Denote the number of secret values (over Fq) by S = d−k +1. Further, let r denote the collection of (from (7)) R = (k − 1)d − k−2 1 random values introduced initially by the dealer.

The data obtained by any participant j ∈ J is a subset of the values ψjT M and {ψT M ψj} ∈[n]. This is true under any arbitrary topology, and irrespective of the connectivity of node j. Furthermore, since matrix M is symmetric, {ψT M ψj} ∈[n] = {ψjT M ψ } ∈[n]. Thus, participant j obtains at most the d-length vector ψjT M under the execution of the protocol.

It sufﬁces to consider the worst case wherein every node j ∈ J obtains ψjT M completely. Let ΨJ be the

((k − 1) × d)

submatrix

of

Ψ

comprising

the

(k − 1)

vectors

{

ψ

T j

}

j

∈J

as

its

rows.

Under

this

notation,

the

(k − 1)

colluding participants together have access to at most the (k − 1)d values

 sA raT sBT  CJ = ΨJ M = ΨJ  ra Rb RcT  .
sB Rc 0

Let e denote the set of these (k − 1)d values.

Throughout the proof, we will use the function H(.) to denote the Shannon entropy. All logarithms in the computation of the entropy functions are assumed to be taken to the base q.

17

As an intermediate step in the proof, we will show that given all the secret values s as side-information, the
(k − 1) colluding participants can recover all the R random values, i.e., we will show that H(r|e, s) = 0. To this
end, observe that since the code is linear, if the secret values sA and sB are known to the colluding participants, they can subtract the components of sA and sB from CJ , to obtain
 0 raT 0T  CJ = ΨJ  ra Rb RcT  .
0 Rc 0

Since ΨJ is a ((k − 1) × d) Vandermonde matrix with all non-zero entries, when restricted to columns 2 to (k − 1), it forms a ((k − 1) × (k − 1)) invertible matrix. This allows recovery of the random values in ra and Rc. Subtracting the components of these decoded values gives

 0 0T 0T  CJ = ΨJ  0 Rb 0T  ,
00 0

and in a manner identical to that of decoding ra and Rc, the colluding participants can decode the remaining

random values Rb. Thus, given the secret values, the (k − 1) colluding participants can decode all the random

values, which implies

H(r|e, s) = 0 .

(21)

As another intermediate step in the proof, we will now show that all but R of the values obtained by the (k − 1)
participants are functions of the other values that they possess, i.e., H(e) ≤ R. From the value of R in (7), it sufﬁces to show that out of the (k − 1)d values that the colluding participants have access to, k−2 1 of them are functions (in particular, linear combinations) of the rest. Consider the ((k − 1) × (k − 1)) matrix

CJ ΨTJ = ΨJ M ΨTJ .

(22)

Since M is symmetric, this ((k − 1) × (k − 1)) matrix in (22) is also symmetric. Thus k−2 1 dependencies among

the elements of CJ are described by the

k−1 2

upper-triangular elements of the expression

CJ ΨTJ − ΨJ CJT = 0 .

(23)

Since the rows of ΨJ are linearly independent, these

k−1 2

redundant equations are independent. Thus the colluding

participants have access to at most (k − 1)d − k−2 1 independent values, which equals the value of R, and hence

H(e) ≤ R.

(24)

We ﬁnally show that the two conditions (21) and (24) above must necessarily imply that the mutual information between the secret values and the values obtained by the colluding participants I(s; e) = 0 is zero.

I(s; e) = H(e) − H(e|s)

(25)

≤ R − H(e|s)

(26)

= R − H(e|s) + H(e|s, r)

(27)

= R − I(e; r|s)

(28)

= R − (H(r|s) − H(r|e, s))

(29)

= R − H(r|s)

(30)

= R−R

(31)

= 0,

(32)

where (26) follows from (24); (27) follows since every value in the system is a function of s and r, giving H(e|s, r) = 0; (30) follows from (21); and (31) follows since the random values are independent of the secret values. Thus, s and e are independent random variables.

The (k − 1)-collusion-resistance property is thus satisﬁed under any arbitrary topology of the network (that may even vary with time), making SNEAK robust to the network topology.

18

APPENDIX B PROOFS OF COMPLEXITY ANALYSIS

Proof of Theorem 5: Under SNEAK, each participant who is directly connected to the dealer receives d values (over Fq) and each of the other participant receives exactly one value each from d of its neighbours. Thus, the total amount of data received by each participant is d values. Normalizing this by the size of the secret, which under SNEAK is (d − k + 1), gives the desired result (10).

Under SNEAK, the size of the secret is (d − k + 1) values over Fq. From the description of the algorithm (7) we see that the total randomness required is (k − 1)d − k−2 1 values over Fq. Normalizing this value by the size of the secret gives the desired result (11).

Proof of Theorem 6: Under the SMT-based solution, the dealer ﬁrst computes the (unit-sized) shares {ti}ni=1 of each of the nodes. To every node in N (D), the dealer directly passes its respective share, thus resulting in a total

communication of |N (D)| units of data. Now consider any other node i ∈/ N (D). Suppose there exist w (≥ k)

node-disjoint paths from the dealer to node i. The dealer treats ti as a secret and uses two-level secret sharing to

construct w shares such that no (k − 1) of these shares reveal any information about ti, and all w shares sufﬁce to

recover ti completely. Under this encoding, the size of each of the w shares is w−1k+1 . The dealer then passes these

w shares along the w node-disjoint paths to node i, and node i thus securely obtains ti. Thus, if we let w(D → i)

denote the average of the lengths of these w

paths, the communication required is

w w−k+1

w(D → i) units of data.

The dealer is free to choose the value of w across all feasible options, that minimizes this expression, thus leading

to the result (12).

Under the SMT-based solution, the dealer ﬁrst constructs the n shares using (k − 1) random values. In addition,

in order to disseminate the shares to any node i ∈/ N (D), the dealer can perform a two-level secret sharing and

pass

the

shares

across

w

node-disjoint

paths

as

described

above.

This

requires

k−1 w−k+1

units

of

randomness,

which

is minimized when w = wmax. This leads to the result (13).

For any graph G the maximum number of node-disjoint paths from the dealer to any node i is upper bounded by, wmax(i) ≤ |N (D)|. Using this bound in (13) leads to the result (14).

Proof of Theorem 7: Let S denote the random variable representing the secret, and assume without loss of generality that its entropy is normalized to unity, i.e.,

H(S) = 1.

(33)

Case I ( ∈/ N (D) and deg( ) ≥ k): Let z = deg( ) denote the number of incoming edges at node (in case of an undirected graph, z denotes the degree of node ). Let nodes {i1, . . . , iz} be these z neighbours of node . For j ∈ {1, . . . , z}, let Wj denote the random variable representing all the data available at node ij, and let Xj denote the random variable representing the data passed by node ij to node . We will now show that
z H(X1) + · · · + H(Xz) ≥ z − k + 1 , (34)
which sufﬁces to prove the result.
Since Wj is the entire data available at node ij, and Xj is the data passed by node ij, it follows that given Wj, the random variable Xj is conditionally independent of all other random variables in the set {S, X1, W1, . . . , Xj−1, Wj−1, Xj+1, Wj+1, . . . , Xz, Wz}.

19

Now, for any permutation {j1, . . . , jz} of {1, . . . , z}, it must be that

H(Xjk ) + · · · + H(Xjz )

≥ H(Xjk , . . . , Xjz )

≥ H(Xjk , . . . , Xjz |Wj1 , . . . , Wjk−1 )

≥ I(S; Xjk , . . . , Xjz |Wj1 , . . . , Wjk−1 )

= H(S|Wj1 , ..., Wjk−1 )−H(S|Wj1 , ..., Wjk−1 , Xjk , ..., Xjz )

= 1 − H(S|Wj1 , . . . , Wjk−1 , Xjk , . . . , Xjz )

(35)

= 1 − H(S|Wj1 , . . . , Wjk−1 , Xj1 , . . . , Xjz )

(36)

= 1.

(37)

Here, (35) is a consequence of the fact that any set of (k − 1) nodes cannot contain any information about the secret S, and that H(S) = 1; (36) is due to the conditional independence conditions described above; (37) arises due to the requirement of being able to recover the secret S from any k nodes.

Now, let us consider the z cyclic permutations of {1, . . . , z}: {1, . . . , z}, {2, . . . , z, 1}, . . ., {z, 1, . . . , z − 1}.

Setting {j1, . . . , jz} based on each of these permutations one by one, and adding up the resulting z inequalities (37)

we get

(z − k + 1) (H(X1) + · · · + H(Xz)) ≥ z,

(38)

and hence

z

H(X1) + · · · + H(Xz) ≥ z − k + 1 (39)

is the minimum amount of data required to be received at any node that is not a neighbour of the dealer.

Case II ( ∈ N (D)): Let W denote the entire data received by node . Consider a set of some other (k − 1) nodes, {i1, . . . , ik−1}. Let Wi1, . . . , Wik−1 be the data available at these (k − 1) nodes respectively. Then,

H(W ) ≥ H(W |Wi1 , . . . , Wik−1 )

≥ I(S; W |Wi1 , . . . , Wik−1 )

= H(S|Wi1 , . . . , Wik−1 ) − H(S|W , Wi1 , . . . , Wik−1 )

=1

(40)

where the ﬁnal equation arises from the k-secret-recovery and (k − 1)-collusion-resistance properties, and that we have normalized H(S) = 1. Thus node receives at least one unit of data.
Case III ( ∈/ N (D) and deg( ) < k): It is clear that in this case, k-connected-dealer condition is not satisﬁed, and hence (n, k) secret sharing is not possible. This completes the proof of (15).

We now show that for any (n, k), given only the identities of the neighbours of node , this lower bound is the best possible. This is trivially true when ∈/ N (D) and deg( ) < k, since in this case, the necessary condition of k-connected-dealer is not satisﬁed, thus making (n, k) secret sharing on this graph infeasible. We thus focus on the two remaining cases. Let A ⊆ [n] ∪ {D}\{ } denote the set of nodes that have outgoing edges to node , and B ⊆ [n] ∪ {D}\{ } denote the set of nodes which have incoming edges from node (if a node shares an undirected edge with , it belongs to both the sets). Given the sets A, B, we will construct a graph on (n + 1) nodes consistent with the information about the neighbours of (i.e., the sets A and B), and show that under SNEAK on this graph, the amount of data required to be received at node matches the bound (15) with equality. Consider a graph on (n + 1) nodes with the following edge set: an edge from node to every node in B, an edge from every node in A to node , and an edge from D to each node in [n]\{ }. One can verify that this graph is consistent with the information provided about the neighbourhood of node . One can also verify that this graph satisﬁes the d-propagating-dealer condition with d = deg( ). In this graph, every node in the set [n]\{ } receives

20

its share directly from the dealer. If ∈ N (D) (i.e., if D ∈ A), then node also receives its share directly from the dealer. Since the size of the share (8) is equal to the size of the secret, the bound (15) on the amount of data received is met. When ∈/ N (D), Theorem 5 shows that under SNEAK with d = deg( ), node obtains its share after receiving exactly deg(de)g−( k)+1 units of data. Thus, the lower bound (15) is achieved in this case as well.
The result (16) is an immediate consequence of of the result (15) proved above.

Proof of Lemma 8: Under SNEAK, each node receives

d d−k+1

units of data (as shown in Theorem 5).

Since each node ∈/ N (D) has deg( ) = d, an application of Theorem 7 leads to the desired result.

Proof of Lemma 9: For the given values of n, k and d (k ≤ d < n), consider any directed graph with (n + 1) nodes such that (a) the dealer has d outgoing edges, (b) every non-neighbour of D has d incoming edges, and (c) the graph satisﬁes d-propagating-dealer condition. Any graph with the above three properties has |N (D)| = d and deg(i) = d ∀ i ∈/ N (D). An application of (16) and a simple rearrangement of the terms leads to the desired result.

In order to show that the class of graphs considered above is non-empty, we now present a means to construct graphs with the requisite properties. Consider ﬁrst, a graph on (n + 1) nodes (the dealer and n participants) with no edges. Consider an arbitrary ordering of the n participants as 1, 2, . . . , n. Add edges in the following manner:

• For every i ∈ {1, . . . , d} – add a directed edge from the dealer to node i
• For every i ∈ {d + 1, . . . , n} – Pick any arbitrary subset Si of d nodes from the set {1, . . . , i − 1} – For every j ∈ Si, add a directed edge from node j to node i

This completes the construction of the graph. One can verify that this graph satisﬁes all the three requisite properties (with the d-propagating dealer condition satisﬁed under the ordering 1, 2, . . . , n of the participants).

While the above description provides a general consturction, a concrete example of a graph satisfying the three properties listed above, is the class of layered graphs as in Fig. 3a with a modiﬁcation: assume all edges to be directed from the left to the right, and the existence of an additional ‘dealer’ node that has edges to every node in the leftmost layer.
Proof of Lemma 10: For any graph Gn with (n + 1) nodes, let bn be the maximum of the outgoing degrees of all the nodes in the graph. Since k > 1, we have bn > 1. In (12) from Theorem 6(a), observe that

min w(D → i) ≥ min(D → i)
w>k

where

min(D

→

i)

is

the

length

of

the

shortest

path

from

the

dealer

to

node

i,

and

that

w w−k+1

≥

1,

As a consequence of this, we have

(41) ∀w > k.

ΓSMT(Gn) ≥ |N (D)| +

min(D → i) .

(42)

i∈/N (D)

Now, since the degree of each node is upper bounded by bn, there can be at most bn nodes that are connected directly to the dealer, at most b2n nodes with min(D → i) = 2, at most b3n nodes with min(D → i) = 3, and so on.
Let

m = arg max m˜

(43)





m˜

subject to  bjn ≤ n ,

j=1

and m˜ ∈ {0, 1, 2, . . .}.

21

It follows from the discussion above that

m

ΓSMT(Gn) ≥

jbjn

(44)

j=1

≥ mbmn .

(45)

One can infer from (43) that m is the largest integer satisfying

bmn +1 − bn ≤ n , bn − 1

and hence

m = log(n(bn − 1)) + bn − 1 log bn

log n

≥

−2 .

(46)

log bn

Substituting this in (45), we obtain

log n

n

ΓSMT(Gn) ≥

−2 log bn

b2

(47)

n

ΓSMT(Gn)

log n

1

⇒ n

≥

−2 log bn

b2 .

(48)

n

Setting

bn

=

O((log

n

)

1 2

−

))

or

bn

=

O(1)

gives

the

respective

desired

results.

Proof of Lemma 11: For any given (n, k) and d (k ≤ d < n), consider a parameter a where 0 ≤ a ≤ n. Construct a graph G with (n + 1) nodes in the following manner. Consider ﬁrst a graph on (n + 1) nodes (the dealer and n participants) with no edges. Consider an arbitrary ordering of the n participants as 1, 2, . . . , n. Denote the delaer as node 0. Add edges in the following manner:

• For every i ∈ {1, . . . , d} – add a directed edge from the dealer to node i
• For every i ∈ {d + 1, . . . , n} – Pick any arbitrary subset Si of d nodes from the set {max(i − (d + a), 0), . . . , i − 1} – For every j ∈ Si, add a directed edge from node j to node i

From the construction described above, it is clear that each graph in this class satisﬁes the d-propagating-dealer condition (with the requisite ordering of the nodes being 1, . . . , n).

Clearly under this construction, any path from the dealer to any node i requires at least

i d+a

steps. Now, the

expression in the statement of Theorem 6 can be bounded as

ΓSMT(G) ≥ |N (D)| +

min(D → i)

(49)

i∈/N (D)

where min(D → i) is the length of the shortest path from the dealer to node i. This can be rewritten in the present

context as

n

i

ΓSMT(G) ≥ d + a (50)

i=1

n(n + 1)

≥

.

(51)

2(d + a)

Setting a = d in (51) leads to the desired result.

22

Proof of Theorem 12: A consequence of Proposition 1 is that for a graph having a maximum degree that is upper bounded by a constant independent of n, the parameters k and d must also be bounded by that constant, and hence are O(1). The result now follows from Theorem 5(a), Theorem 6(a), Lemma 10, and Lemma 11.
Proof of Theorem 13: From (14) we can see that the amount of randomness required under the SMT-based solution increases with n unless the number of nodes connected directly to the dealer also increases linearly with n. A consequence of Proposition 1 is that for a graph having a maximum degree that is upper bounded by a constant independent of n, the parameters k and d must also be bounded by that constant, and hence are O(1). Furthermore, since the maximum degree is upper bounded by a constant independent of n, so is the number of neighbours of the dealer. Then the result follows from Theorem 5 and Theorem 6

APPENDIX C EXTENSIONS OF THE SNEAK ALGORITHM

A. Two-threshold Secret Sharing Over General Networks

In [18], the authors introduced a modiﬁcation of Shamir’s secret sharing scheme to include two thresholds k and (< k). The modiﬁed scheme satisﬁes the properties of k-secret-recovery and -collusion-resistance (Shamir’s original scheme is a special case with = k − 1). The relaxation of to a value smaller than (k − 1) allows for the reduction of the size of each share (when normalized by the message size), thus requiring the dealer to transmit a smaller amount of data, and the participants to store lesser data.

We now generalize the SNEAK algorithm presented in Section IV, for distributed secret sharing across a general

network, to accommodate two thresholds. The generalization only modiﬁes the structure of matrix M in (6) in the

original algorithm. Given two thresholds k and , the dimensions of the constituent submatrices of M are changed

to

 SA RaT SBT 

M =  Ra Rb RcT 

(52)

SB Rc 0

k−

d−k

d

where

•

SA is a symmetric ((k −

) × (k −

)) matrix containing

(k− )(k− +1) 2

secret values,

• SB is ((d − k) × (k − )) matrix containing (k − )(d − k) secret values,

• Ra is a ( × (k − )) matrix containing (k − ) random values, • Rb is a ( × ) symmetric matrix containing ( 2+1) random values,

• Rc is a ((d − k) × ) matrix containing (d − k) random values.

Each random or secret value is drawn from the ﬁnite ﬁeld Fq, q > n. Note that M continues to be a (d × d) symmetric matrix. The remaining algorithm remains the same as in Section IV. The properties of k-secret-recovery, -collusion-resistance and robustness to network structure can be veriﬁed via arguments analogous to those in Section IV-C.

B. Handling Active Adversaries
Throughout the paper we assumed a honest-but-curious model, where the participants honestly follow the protocol, but may gather any available information. Now, we consider the case when some participants may be active adversaries, i.e., may pass corrupt values to their neighbours (in addition to trying to gather information about the secret). We show how to modify SNEAK (Section IV) to handle the case when there are upto t active adversaries in the system, for some given parameter t.

23

The modiﬁed algorithm requires the network to satisfy a (d + 2t)-propagating-dealer condition; let us assume

this holds. Under the algorithm, the dealer computes the matrix M and the encoding vectors as described in

Section

IV.

As

before,

to

each

participant

i

directly

connected

to

the

dealer,

it

passes

the

data

ψ

T i

M

.

The

only

modiﬁcations are that each participant who is not connected to the dealer obtains data from (d + 2t) neighbours and that the method of recovering the data ψT M now involves correcting errors. Let us assume that participant

receives data form neighbours {j1, . . . , jd+2t}. According to the protocol, this data is the set of (d + 2t) values {ψTj1M ψ , . . . , ψTjd+2tM ψ }. By construction, any d vectors from the set {ψTj1, . . . , ψTjd+2t} are linearly independent.
Thus, the (d + 2t) values received by node form a Maximum-Distance-Separable (MDS) encoding of the d-length

vector M ψ . Furthermore, since at most t of the participants may be actively adversarial, no more than t out of

the (d + 2t) received values can be in error. Thus, participant can apply standard Reed-Solomon code decoding

algorithms [29] and recover M ψ correctly. Finally, since M is symmetric by construction (6), participant equivalently obtains its desired data ψT M . The participant then passes ψT M ψj to each of its neighbours j.

C. Heuristics for Handling Networks that Do Not Meet the Propagating-dealer Condition
SNEAK requires the graph to satisfy the d-propagating-dealer condition for some known d (≥ k). If a graph does not satisfy the d-propagating-dealer condition, there will exist a subset of the nodes that will not be able to recover their respective shares 4. For example, consider (n = 10, k = 2) secret-sharing over the graph shown in Fig. 4a using SNEAK with parameter d = 2. In this example, the graph does not satisfy 2-propagating-dealer condition since only one neighbour of node 8 (which is node 5) can recover the data prior to node 8. If SNEAK is used to disseminate the shares assuming that the graph satisﬁes 2-propagating dealer condition, nodes 8, 9, and 10 will not be able to recover their shares.
We now present three heuristic ways of extending SNEAK to handle secret sharing over graphs which do not satisfy the d-propagating-dealer condition, using the graph in Fig. 4a as a working example. We note that while
4Recall that no information will, however, be leaked.

1

3

5

7

9

D

2
1 D

4

6

(a)

8

10

r7

3

5

7

9

m 78 r 7+
, r7 m 58

2

4

6

8 r7+m78 10

(b)

Fig. 4: (a) An example network that does not satisfy the k-propagating dealer condition for k = 2. Node 8 is a bottleneck node. (b) Communicating data to the bottleneck node 8: node 7 communicates its message m78 = ((s+7r)+8(r+7ra)) to node 8 under SNEAK, through the two highlighted node-disjoint paths (r7 is chosen uniformly at random from the ﬁeld of operation F11). Node 8 also obtains m58 = ((s+5r)+8(r+5ra)) directly from node 5.

24
these heuristics work successfully, the resulting algorithm is no longer completely distributed and a rigorous analysis of its performance guarantees is open.
a) Heuristic 1: One straightforward approach is to employ the SMT-based solution of separate secure transmissions from the dealer to all the nodes that do not receive their respective shares upon an execution of SNEAK. Using this approach for the example in Fig. 4a, for each of the nodes i ∈ {8, 9, 10}, the dealer communicates the respective share (s + ir) over two node-disjoint paths, using the SMT-based solution solution. This requires a total of 30 units of communication to disseminate shares to these nodes. In general, this approach is inefﬁcient, since it does not exploit the advantages offered by our distributed algorithm to the fullest extent. This is especially so when only a few nodes act as bottlenecks hindering the progress of the algorithm as we will see below.
b) Heuristic 2: Observe that in the example network in Fig. 4a there is only one node, node 8, that is the bottleneck: receipt of its data by node 8 would allow SNEAK to continue further and disseminate shares to the remaining nodes (9 and 10) efﬁciently. This leads to a second approach that is more communication efﬁcient, wherein the SMT-based solution can be employed to communicate data to only the bottleneck nodes. The SMTbased solution would pass precisely the data that the bottleneck node(s) would possess under SNEAK, after which SNEAK can be employed to disseminate shares to the remaining nodes. For the example under consideration, node i ∈ {1, . . . , 7} would have obtained data {s + ir, r + ira} via SNEAK. Next, the dealer would communicate {s + 8r, r + 8ra} to node 8 through the two node-disjoint paths, 1 → 3 → 5 → 8 and 2 → 4 → 6 → 7 → 9 → 8, and subsequently, nodes 7 and 8 can pass the requisite shares to the remaining nodes 9 and 10. This approach requires a total of 14 units of communication to disseminate shares to the nodes 8, 9 and 10. Note that the graph considered in the example had only one bottleneck node, and hence the SMT-based solution was employed only once. On a general graph, this approach can be iteratively performed (whenever SNEAK hits a bottleneck node) until all the participants receive their shares. Further note that the dealer can always communicate the data to the bottleneck nodes since the graph has to necessarily satisfy the k-connected-dealer condition in order to achieve (n, k) secret sharing.
c) Heuristic 3: Instead of communicating the data to the bottleneck nodes from the dealer, one may alternatively use a local version of the SMT-based solution: nodes in the vicinity of the bottleneck nodes, who have already received their data, pass the requisite data to the bottleneck nodes via node-disjoint paths. The data that such a node passes to the bottleneck node is precisely what it would have passed had there been a direct edge between them using the SMT-based solution. This node treats this data as a secret, and uses k-node-disjoint paths (if available) to communicate this secret to the bottleneck node. To illustrate this approach, consider again the network depicted in Fig. 4a. Node 8 can directly receive m58 = ((s + 5r) + 8(r + 5ra)) from node 5. Now, if node 7 had a direct communication link to node 8, under SNEAK, it would have sent m78 = ((s + 7r) + 8(r + 7ra)) to node 8. In the absence of such an edge, node 7 can securely communicate this data over two node-disjoint paths as depicted in Fig. 4b. Once node 8 gets this data, SNEAK can proceed and disseminate shares to the remaining nodes 9 and 10. This approach requires only 8 units of communication to disseminate shares to nodes 8, 9 and 10. This simple tweak can be employed to reduce the communication cost to the bottleneck nodes, whenever sufﬁcient local connectivity is available.

