Decentralized, Hybrid MAC Design with Reduced State Information Exchange for Low-Delay IoT Applications

Avi Mohan‚àó Technion

Arpan Chattopadhyay‚Ä† IIT Delhi

Shivam Vinayak Vatsa‚Ä° ABB

Anurag Kumar¬ß IISc ¬∂

arXiv:2105.11213v1 [cs.NI] 24 May 2021

Abstract
We consider a system of several collocated nodes sharing a time slotted wireless channel, and seek a MAC that (i) provides low mean delay, (ii) has distributed control (i.e., there is no central scheduler), and (iii) does not require explicit exchange of state information or control signals. The design of such MAC protocols must keep in mind the need for contention access at light traÔ¨Éc, and scheduled access in heavy traÔ¨Éc, leading to the long-standing interest in hybrid, adaptive MACs.
We Ô¨Årst propose EZMAC, a simple extension of an existing decentralized, hybrid MAC called ZMAC. Next, motivated by our results on delay and throughput optimality in partially observed, constrained queuing networks, we develop another decentralized MAC protocol that we term QZMAC. A method to improve the short-term fairness of QZMAC is proposed and analysed, and the resulting modiÔ¨Åed algorithm is shown to possess better fairness properties than QZMAC. The theory developed to reduce delay is also shown to work in the presence of transmission errors and fast fading.
Extensions to handle time critical traÔ¨Éc (alarms, for example) and hidden nodes are also discussed. Practical implementation issues, such as handling Clear Channel Assessment (CCA) errors, are outlined. We implement and demonstrate the performance of QZMAC on a test bed consisting of CC2420 based Crossbow telosB motes, running the 6TiSCH communication stack on the Contiki operating system over the 2.4GHz ISM band. Finally, using simulations, we show that both protocols achieve mean delays much lower than those achieved by ZMAC, and QZMAC provides mean delays very close to the minimum achievable in this setting, i.e., that of the centralized complete knowledge scheduler.
Keywords‚àí Sensor Networks, Partially Observable MDPs (POMDPs), Medium Access Control, Throughput Optimality, Optimal Polling, Internet of Things, 6TiSCH.

Contents

1 Introduction

3

1.1 Our Contributions and Organization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
‚àóAvi Mohan (corresponding author) is a postdoctoral fellow at the Technion Israel Institute of Technology, Haifa, Israel. E-mail: avinashmohan@campus.technion.ac.il.
‚Ä†Arpan Chattopadhyay is with the Indian Institute of Technology, Delhi, India. E-mail: arpanc@ee.iitd.ac.in ‚Ä°Shivam Vinayak is currently with ABB Bangalore, India. E-mail: shivamv@iisc.ac.in ¬ßAnurag Kumar is with the Indian Institute of Science, Bangalore-560012, KA, India. E-mail: anurag@iisc.ac.in ¬∂This work was done when the Ô¨Årst author was at the Indian Institute of Science and was presented, in part, at the 13th IEEE International Conference on Mobile Ad Hoc and Sensor Systems (IEEE MASS, 2016). This research was supported by the Ministry of Human Resource Development, via a graduate fellowship for the Ô¨Årst author, and the Department of Science and Technology, via a J.C. Bose Fellowship awarded to the last author.

1

2 Frame Structure and System Processes

6

3 Information Structure

7

4 Delay-Optimal Polling with Partial Information

8

4.1 A Centralized Scheduling Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8

4.2 Optimality of Non-idling and Exhaustive Policies . . . . . . . . . . . . . . . . . . . . . . . . . 9

4.3 The Longest Expected Queue (LEQ) policy . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

4.4 Stability of Cyclic Exhaustive Service . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

4.5 Delay Optimality of the LEQ policy in Symmetric Systems . . . . . . . . . . . . . . . . . . . 11

4.5.1 Mean Delay Optimality of Cyclic Exhaustive Service . . . . . . . . . . . . . . . . . . . 12

4.5.2 Formulating The Discounted Cost MDP . . . . . . . . . . . . . . . . . . . . . . . . . . 12

4.5.3 Solution to the Discounted Cost MDP . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

4.5.4 The Class of Throughput Optimal Stationary Markov Policies . . . . . . . . . . . . . . 14

4.5.5 The Average-Cost Criterion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

4.6 Alleviating Short term Unfairness: The K-Longest Expected Queue (KLEQ) Policy . . . . . . 15

5 Mechanisms for Decentralized Scheduling

17

6 Protocol Design

18

6.1 The EZMAC Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

6.1.1 The ZMAC protocol [RWA+08] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

6.2 The QZMAC protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

7 Extending QZMAC

21

7.1 Handling Unequal Arrival Rates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22

7.2 Handling CCA errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22

8 Experiments on an Implementation of QZMAC

23

8.1 Frame Structure: Time Slots and Mini-Slots . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

8.2 Time Synchronization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

8.3 CCA Errors : Inference and Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

9 Experimental Results

25

2

9.1 Distributed Implementation of the LEQ policy . . . . . . . . . . . . . . . . . . . . . . . . . . 25 9.2 Performance of EZMAC and QZMAC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 9.3 Tuning QZMAC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 9.4 Channel Utilization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

10 Conclusion and Future work

29

11 Appendices

33

11.1 Glossary of Notation and Acronyms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33

11.2 Proof of Prop. 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34

11.3 Proof of Prop. 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

11.4 LEQ in Symmetric Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

11.5 Proof of Thm. 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

11.6 Formulating the MDP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39

11.7 Proof of Thm. 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

11.7.1 Monotonicity of ùêΩ‚àó (¬∑) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42

11.7.2 Proof of Thm. 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43

11.8 Proof of Lem. 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45

11.9 Proof of Lem. 9 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

11.10Solving the Time-Average Cost MDP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

11.11Proof of Prop. 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

11.12Channel Errors and Fading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53

11.13Handling Alarm TraÔ¨Éc: The QZMACùëé protocol . . . . . . . . . . . . . . . . . . . . . . . . . 53

11.13.1 Performance of QZMAC with Alarm TraÔ¨Éc . . . . . . . . . . . . . . . . . . . . . . . . 54

11.14EÔ¨Äects of Nonidealities in Clear Channel Assessment . . . . . . . . . . . . . . . . . . . . . . . 54

1 Introduction
In the Internet of Things (IoT), wireless access networks will connect embedded sensors to the infrastructure network (see Fig. 1). Since these embedded devices will be resource challenged, the wireless medium access control (MAC) protocols will need to be simple, and decentralized, and not require explicit exchange of state information and control signals. However, some of the emerging applications might expect low packet delivery delays as well. In this paper, we report our work on developing a low mean delay MAC protocol for ùëÅ collocated nodes sharing a time slotted wireless channel, such that there is no centralized control and no explicit exchange of state information. Networks with collocated nodes regularly arise in the industrial
3

Measurement Packets
Packet BuÔ¨Äer

Internet
IoT Gateway

Wireless Sensor Node
Figure 1: A typical application scenario. Each of the ùëÅ sensors generates measurement packets that get queued in its packet buÔ¨Äer. These are then transmitted over a wireless link to a gateway that forwards the packet to the broader internet, i.e., the infrastructure network.
IoT setting such as asset management applications, speciÔ¨Åcally, machine health monitoring [ZWX17], and in robotics applications, termed the ‚ÄúInternet of Robotic Things‚Äù (IoRT) [GRC+14, Mat19], owing to their reduced geographical spread (network monitoring a single machine or robot). Emerging standards for IoT applications, such as the DetNet and 6TiSCH [TPE15], have shown considerable interest in systems with a synchronous time-slotted framework. It may be noted that, for this setting, a centralized scheduler with full queue length information can just schedule any non-empty queue in each slot. The challenge we address in this paper is to develop a distributed mechanism, without explicit exchange of queue length information, that achieves mean delay very close to that of the centralized scheduler.
It is well known that, while contention access (ALOHA, CSMA etc.) performs well at low contention, it can result in very large delays and possibly instability under high contention [Le84]. While attempts have been made to stabilize CSMA (see [JW12], [JW11] and [RSS09] for examples), the delay of these algorithms still remains prohibitively high. Polled access (e.g., 1-limited cyclic service [TK85], which we will call TDMA in this paper) on the other hand, shows the opposite behavior. It is, hence, desirable to have protocols that can behave like TDMA under high contention and CSMA under low contention. Fig. 2 illustrates this behavior. The Ô¨Ågure compares the delay performance of polling and contention MACs (orange and blue, respectively) showing the phenomenon discussed above. Also shown are two illustrations of ‚Äúload adaptive‚Äù performance expected of hybrid MACs, the one in red being uniformly better than the one in green. The Ô¨Ågure also shows the lowest possible delay attainable in this setting (black curve). This curve is discussed in more detail in Sec. 9, where we show that the hybrid MACs proposed in this paper come extremely close to this curve and hence, are nearly delay optimal. There have been many attempts at proposing protocols that achieve this, especially in the context of wireless sensor networks. Important examples include [EM+82, DNF+05, RWA+08, AHM+06] and [SSB10]. Among these, ZMAC [RWA+08] has been observed to perform the best in terms of delay and channel utilization (see [WR05]), and will be an important point of comparison in this paper. The design of these protocols, however, has been heuristic and without recourse to known results in optimal scheduling of queues. Further, little attention appears to have been paid to distributed scheduling in the TDMA context, such that each node uses only locally available information. If all queue lengths are known at a central scheduler, then ideal performance can be achieved. In the context of partial information about queue occupancies, the aim, at each scheduling instant, is to minimize the time it takes for the system to Ô¨Ånd a nonempty queue and allow it to transmit. How this can be achieved in the setting of collocated nodes with a common receiver, by using stochastic optimal control (with partial information) in conjunction with extensions of known results on optimal scheduling, is the main contribution of this paper.
4

Figure 2: Delay performance of various MAC protocols. Arrival rates to all queues are equal. In this paper, such a system is termed a symmetric system.
ZMAC achieves contention-dependent behavior by maintaining a TDMA schedule as the basic transmission scheme, and by allowing nodes to contend for slots when the TDMA user is empty. When the network is lightly loaded, most nodes are empty and other nodes can acquire their TDMA slots through contention without waiting for their own TDMA slots, while under heavy load, most nodes use their TDMA slots and the protocol behaves like TDMA, as desired. ZMAC‚Äôs delay performance, however, is poor compared to centralized scheduling with full queue length knowledge (see Fig. 13b). The question, therefore, remains whether we can achieve low delay, in a decentralized setting, in which the information available to each node is just what it can acquire by ‚Äúlistening‚Äù over the channel.
1.1 Our Contributions and Organization
‚Ä¢ We consider ùëÅ nodes sharing a slotted wireless channel to transmit packets (each of which Ô¨Åts into one slot) to a common receiver. Each node receives a stochastic arrival process embedded at the slot boundaries.
‚Ä¢ We begin by describing in detail the structure of the (partial) information that nodes in the network will be assumed to possess, in Sec. 3. This structure will inform the development of optimal scheduling policies and distributed scheduling protocols.
‚Ä¢ We then prove the delay optimality of greedy and exhaustive service policies in this novel partial information setting (in Sec. 4.2). While our analysis employs proof techniques in [LNT92] to show sample pathwise dominance, the added complexity of state dependent server switchover delays complicates the analysis in this (and the next) section considerably.
‚Ä¢ Focusing on greedy and exhaustive service policies, with no explicit queue length information being shared between nodes, we derive a mean delay optimal policy by formulating the problem as a Markov decision process with partial information.
‚Ä¢ We initially cast the problem as an ùõº-discounted cost MDP and obtain the optimal policy (Sec. 4.5.3). Thereafter, we extend the result to time-average costs in Sec. 4.5.5. Next, we use Foster Lyapunov theory [FMM95] to modify and extend our proposed optimal policy to solve the problem of unfairness that it gives rise to in Sec. 4.6. We also discuss how our results can also handle channel errors and fading.
5

‚Ä¢ We then use the delay optimality results developed in Sec. 4.2 to design two Hybrid MAC protocols (EZMAC and QZMAC) and show that the delays achieved by them are much lower than that achieved by ZMAC (Sec. 6). We then present modiÔ¨Åcations to the QZMAC protocol to handle unequal arrival rates, alarm traÔ¨Éc and Clear Channel Assessment (CCA) errors. To the best of our knowledge, this is the Ô¨Årst work that deals with hybrid MAC scheduling for systems with unequal arrival rates (Prop. 2 and Thm. 3).
‚Ä¢ We report the results of implementing QZMAC over a collocated network comprising CC2420 based Crossbow telosB motes running the 6TiSCH [DWVT14] communication stack, in Sec. 8. In Sec. 9, we present simulation results comparing the delay (both mean and delay CDF) performance of QZMAC and EZMAC with that of ZMAC. We also show that delay with QZMAC is very close to the minimum delay that can be obtained in this scenario (Sec. 9.2). We discuss techniques to tune QZMAC to modify its performance over diÔ¨Äerent portions of the network capacity region (see Eqn.(2)) and also compare the Channel Utilization of QZMAC with that of ZMAC. Finally, we conclude the paper and present directions for future research.

2 Frame Structure and System Processes

We consider a wireless network comprising several source nodes (e.g., sensor nodes) transmitting to a common receiver node (e.g., a base station). The nodes are collocated in the sense that all nodes can hear each other‚Äôs transmissions. This could mean, at one extreme, that they can decode each other‚Äôs transmissions, or just sense each other‚Äôs transmissions. We will comment on this further in Sec. 3 on Information Structures. Time is assumed slotted; the slots are indexed ùë° = 0, 1, 2, ¬∑ ¬∑ ¬∑ , with slot ùë° being bounded by the epochs ùë° and ùë° + 1. In each slot ùë°, a single node can transmit successfully (note that there is a common receiver). If a node transmits in slot ùë°, at the instant ùë° +1, that node is viewed as the ‚Äúnode under service,‚Äù or the ‚Äúincumbent,‚Äù the identity of which is assumed known to all the nodes; as we will see, this property of knowing the incumbent is ensured by the information structure and our distributed algorithms.

We model the system as a network of ùëÅ parallel queues with a single shared server, whose service has to be scheduled between the ùëÅ queues. ùêº := {1, 2, ¬∑ ¬∑ ¬∑ , ùëÅ } represents the set of queues. We denote by ùê¥ ùëó (ùë°), the number of arrivals to Queue ùëó at time slot boundary ùë° (ùë° = 0, 1, 2, ¬∑ ¬∑ ¬∑ ). ùê¥ ùëó (ùë°) is assumed IID Bernoulli with rate ùúÜ ùëó , i.e., ùëÉ{ ùê¥ ùëó (ùë°) = 1} = ùúÜ ùëó . The arrival processes are assumed independent of each other and the system backlog. The backlog at Queue ùëó at the beginning of time slot ùë° (i.e., at ùë°+) is denoted by ùëÑ ùëó (ùë°) (see Fig. 3). We assume that each slot can carry exactly one data packet, after allowing time for any protocol overhead. A packet transmission from Node ùëó in slot ùë° leads to a ‚Äúdeparture‚Äù from the corresponding queue, which is viewed as occurring at (ùë° + 1)‚àí, i.e., just before the end of slot ùë°, and is denoted by ùê∑ ùëó (ùë°). Until Sec. 11.12 we assume packet transmission success probability to be 1 and therein, lift this assumption. It follows, from the embedding of the processes described, that the evolution of the queue-length process at Queue ùëó can be described by.
ùëÑ ùëó (ùë° + 1) = (ùëÑ ùëó (ùë°) ‚àí ùê∑ ùëó (ùë°))+ + ùê¥ ùëó (ùë° + 1), (1)
ùëÑ ùëó (0) = ùê¥ ùëó (0),
where for all ùë• ‚àà R, (ùë•)+ =max(ùë•, 0). Since at most one queue1 can be scheduled for transmission in a slot and at most one packet can be transmitted in one slot, the capacity region [TE92] of this system is given by

ùëÅ

‚àëÔ∏Å

ùö≤=

ùùÄ

‚àà

ùëÅ
R+

:

ùúÜùëó < 1 .

(2)

ùëó =1

1In the sequel we will use ‚Äúnode‚Äù and ‚Äúqueue‚Äù interchangeably.

6

Figure 3: Figure showing how the queue length, arrival and service processes are embedded.

DeÔ¨Åne Q(ùë°) = [ùëÑ1 (ùë°), ¬∑ ¬∑ ¬∑ , ùëÑùëÅ (ùë°)] , ùë° ‚â• 0. In this article, we say that the system is stable if the system backlog Markov chain, {Q(ùë°), ùë° ‚â• 0}, is positive recurrent. A protocol that is capable of stabilizing any vector in Œõ is said to be Throughput Optimal [TE92]. Delay is deÔ¨Åned as the number of slots between the instant a packet enters a queue and the instant it leaves the queue. Note that this along with the embedding described so far means that a packet experiences a delay of at least one slot.

Let ùëÑ ùëó =Œî limùë°‚Üí‚àû 1ùë° ùë°ùúè‚àí=10 ùëÑ ùëó (ùúè), let ùëä ùëó (ùëò) denote the delay experienced by the ùëòùë°‚Ñé packet in Queue ùëó and ùëä ùëó =Œî limùêø‚Üí‚àû ùêø1 ùëòùêø=‚àí01 ùëä ùëó (ùëò). Under stability, ùëÑ ùëó and ùëä ùëó are constant with probability one; we denote these constants also by ùëÑ ùëó and ùëä ùëó . Using Little‚Äôs law, ùëä ùëó = ùëÑùëó . The delay experienced by a packet randomly
ùúÜùëó

chosen from the arriving stream, therefore, is given by ùëä =

ùëÅ ùëó =1

ùúÜùëó
ùëÅ
ùëò=1 ùúÜùëò

ùëäùëó =

1
ùëÅ
ùëò=1 ùúÜùëò

in the paper is to develop decentralized protocols that minimize ùëä .

ùëÅ ùëó =1

ùëÑ

ùëó

.

Our

objective

3 Information Structure
In the setting described in Sec. 2, if, at the beginning of every slot, the queue lengths are all known to a central scheduler, then it suÔ¨Éces to simply schedule any non-empty queue. The sum queue length process would then be stochastically equivalent to a discrete time, work conserving, single server queue, whose arrival process is the superposition of the ùëÅ arrival processes. The mean delay (equivalently, the mean queue length) would then be the smallest possible. We, however, wish to avoid any explicit dissemination of queue length information over the network, and aim to develop a scheduler that the nodes implement in a decentralized fashion. In this section, we describe the information that we permit and, in Sec. 5, describe the mechanisms that will enable us to develop a distributed scheduler.
We will assume that certain common information, useful for scheduling, is available to all the nodes. The scheduler in each node will utilise only this common information, and hence can be implemented in a distributed manner at each of the nodes. As stated in Sec. 2, the nodes can hear each other‚Äôs transmissions.
Queue length sensing: The common information mentioned in the previous paragraph is disseminated by each node including its current queue length in the header whenever it transmits a packet. In such a case, all nodes have a record of each node‚Äôs queue length until the last time it transmitted. While this assumption is necessary for the proofs in this section, our analysis culminates in the surprising conclusion that reducing mean delay does not require explicit queue length exchange in this setting. We then leverage this result to construct our hybrid MAC protocols.
7

4 Delay-Optimal Polling with Partial Information

Under the information structure described in Sec. 3, at the beginning of each slot, every node will know

the length of every queue at the beginning of every slot in which the queue was allowed to transmit. But

since queue length evolution is Markovian (see Eqn. (2)) the nodes need only keep track of the last observed

queue lengths2, i.e., at the beginning of slot ùë°, each queue knows

ùúã
ùëÑ

ùë° ‚àí ùëâ ùúã (ùë°) ‚àí , ùëó ‚àà ùêº , where ùëâ ùúã (ùë°)

ùëó

ùëó

ùëó

is the number of slots prior to slot ùë° in which Queue ùëó was allowed to transmit under a generic scheduling

policy ùúã (the term ‚Äúpolicy‚Äù is deÔ¨Åned in Sec. 4.1 below). In the literature, ùëâ ùúã (ùë°) is also called ‚ÄúAge of
ùëó
Information‚Äù [YSB+21]. For example, if ùëó is the queue that transmitted in slot (ùë° ‚àí 1), then ùëâ ùúã (ùë°) = 0, and
ùëó

all

other

nodes

know

ùúã
ùëÑ

( (ùë° ) ‚àí)

(Fig.

3).

In

addition,

at

the

beginning

of

slot

ùë°,

every

node

evidently

knows

ùëó

its own queue length. We seek a distributed scheduling policy where each node acts autonomously based on

the queue information structure above, thereby achieving a global performance objective (say, minimising

the time average total queue length in the system).

We will motivate the solution to this problem by considering two centralized decision problems ‚Äì determining the optimal action when the incumbent is (i) nonempty and (ii) when the incumbent is empty. Notice that despite the centralized nature of the scheduling, our novel partial information structure involving random state-dependent delays renders this analysis nontrivial. The former is developed in Sec. 4.1 and then solved in Sec. 4.2. This leaves us with a centralized average cost Markov decision problem, with partial information, which is formulated and solved in Sec.4.5. Together, the solutions of these two problems provide the distributed scheduler that we need. It turns out that this solution requires a little more information to be shared amongst the queues. In Sec. 5 we use a device from [RWA+08] for providing this additional information to all the nodes, thus paving the way for a practical implementation of the distributed scheduler.

4.1 A Centralized Scheduling Problem

A centralized scheduler is deÔ¨Åned by a scheduling policy say ùúã, which (informally speaking), at the beginning of slot ùë°, i.e., at ùë°+, uses the available information and past actions to determine which queue (if any) should
be allowed to transmit in slot ùë°. We indicate the use of a given policy ùúã by placing the superscript ùúã on all processes associated with the system; for example, ùëÑ ùúã (ùë°), ùë° ‚àà {0, 1, ¬∑ ¬∑ ¬∑ } is the queue length process of
ùëó
Node ùëó under the policy ùúã. At the beginning of slot ùë°, ùë° ‚â• 1, we denote by ùúãùë°ùëû‚àí1, the queue that had been scheduled in the previous slot, or, equivalently the ‚Äúincumbent‚Äù at the beginning of slot ùë°.

Under

policy

ùúã,

the

action

at

ùë°+

is

denoted

by

Aùúã

:=

(ùúãùëé, ùúãùëû),

where

ùëé
ùúã

represents

the

action

to

be

taken

ùë°

ùë°ùë°

ùë°

during slot ùë° and ùúãùë°ùëû, the queue upon which the action is to be performed. ùúãùë°ùëé ‚àà {0, 1, ùë†0, ùë†1} which mean

respectively,

idle

at

ùëû
ùúã
ùë°

=

ùúãùë°ùëû‚àí1,

serve

ùëû
ùúã
ùë°

=

ùëû
ùúãùë° ‚àí1

if

nonempty,

switch

(away

from

queue

ùúãùë°ùëû‚àí1)

to

ùëû
ùúã
ùë°

and

idle

there,

and

switch

to

ùëû
ùúã

and

serve

it

if

nonempty,

respectively.

With

the

above

in

mind,

and

anticipating

a

ùë°

result similar to [LNT92, Prop. 3.2], we consider a centralized scheduler that has the following information.

For every ùë° ‚â• 1 and policy ùúã, the ‚Äúhistory‚Äù of the policy contains (i) all the actions taken until ùë° ‚àí 1, (ii) the

backlog of each queue at the last instant it was allowed to transmit, (iii) the instants at which this backlog

was revealed, and (iv) the backlog of the incumbent3 at ùë°, i.e.,

ùúã
ùêª

:=

Aùúã

ùë° ‚àí1

;

ùúã
ùëÑ

ùëÅ

ùëÅ

ùë° ‚àí ùëâ ùúã (ùë°) ‚àí ; ùëâ ùúã (ùë°) ; ùëÑùúã

(ùë°) .

(3)

ùë°

ùëö ùëö=0

ùëó

ùëó

ùëó =1

ùëó

ùëû
ùëó=1 ùúãùë°‚àí1

2If Node ùëñ transmits in slot ùë°, the other nodes get to know ùëÑùëñ (ùë°), and since a packet was transmitted, they can infer
ùëÑùëñ ( (ùë° + 1) ‚àí) = ùëÑùëñ (ùë°) ‚àí 1. However, the process embedding we have assumed prevents the queues from knowing ùëÑùëñ (ùë° + 1) itself, since ùëÑùëñ (ùë° + 1) = (ùëÑùëñ (ùë°) ‚àí 1)+ + ùê¥ùëñ (ùë° + 1) and ùê¥ùëñ (ùë° + 1) is not known.
3Once again, since the evolution of the system is Markovian, we do not require information about arrivals.

8

Note that ùêªùë°ùúã is common knowledge.

Let

ùúã
Hùë°

denote

the

set

of

all

histories

under

ùúã

up

to

time

ùë°.

A

deterministic

admissible

policy

is

deÔ¨Åned

as

a

sequence

of

measurable

functions

from

ùúã
Hùë°

into

the

action

space A = {0, 1, ùë†0, ùë†1} √ó ùêº. For policy ùúã, deÔ¨Åne

ùëÅ
‚àëÔ∏Å ùëÑ ùúã (ùë°) = ùëÑùëñùúã (ùë°), (4)
ùëñ=1
as the total backlog in the system at the beginning of time slot ùë°, ‚àÄùë° ‚â• 0. Let the space of all admissible policies be denoted by Œ†. A policy ùúã ‚àà Œ† is said to be

‚Ä¢ greedy or non-idling if the server never idles at a nonempty queue. The set of all such policies is denoted by Œ†ùëî ‚äÇ Œ†, i.e., Œ†ùëî = ùúã ‚àà Œ† ùëÑ ùúãùëû (ùë°) > 0 ‚áí Aùë°ùúã ‚àà {1, ùë†0, ùë†1} √ó ùêº, ‚àÄùë° ‚â• 0 .
ùë° ‚àí1
‚Ä¢ exhaustive if the server never switches away from a nonempty queue. This set is denoted by Œ†ùëí ‚äÇ Œ†, i.e., Œ†ùëí = ùúã ‚àà Œ† ùëÑ ùúãùë°ùëû‚àí1 (ùë°) > 0 ‚áí Aùë°ùúã ‚àà {0, 1} √ó ùúãùë°ùëû‚àí1 , ‚àÄùë° ‚â• 0

We will now present several results with regards to scheduling in this system that will aid our design process.

4.2 Optimality of Non-idling and Exhaustive Policies

Proposition 1. For the system deÔ¨Åned in Sec. 4 and for any policy ùúã ‚àà Œ†, ‚àÉ ùúâ ‚àà Œ†ùëî ‚à© Œ†ùëí, such that

ùë†ùë°

ùëÑ ùúâ (ùë°) ‚â§ ùëÑ ùúã (ùë°), ‚àÄ ùë° ‚â• 0,

(5)

where ‚Äúùë†ùë°‚Äù denotes stochastic ordering.

Proof. The structure of the model is similar to the one in [LNT92], and the result we seek is the same as [LNT92, Prop. 4.2]. There, the model is a centrally scheduled system of queues, with i.i.d. service times, non zero i.i.d. queue switching times4, and knowledge of ùëÑùëñ (ùë° ‚àí ùëâ ùúã ), 1 ‚â§ ùëñ ‚â§ ùëÅ . Since switching times are
ùëñ,ùë°
nonzero, by exhaustively serving a queue the per packet switching time is reduced, rather than switching away from a non-empty queue and then switching back to it in order to complete the service of the remaining packets. However, a crucial assumption in [LNT92] is that the scheduler instantaneously obtains the queue length of every queue to which it switches. This is important since this limits their study to schedulers that never waste time attempting to serve empty queues, since, upon Ô¨Ånding a queue empty, the scheduler is assumed to immediately switch away to another queue.
In our system, all queues can observe the empty or non empty status of a transmitter whenever it is allowed to transmit. However, while there are no explicit switching times, due to decentralized scheduling, at switching instants, time could be wasted by switching to empty queues, although other nonempty queues exist. In Sec.11.2 in the Appendix, we extend the stochastic coupling argument in [LNT92] to establish the same result as in [LNT92, Prop. 4.2].
4In polling literature, switching/switchover times refer to the time wasted while the server switches from one queue to another.

9

Discussion: Prop. 1 leads to the following partial solution for scheduling. Consider the situation in which an incumbent node completes a transmission, with all other nodes knowing its identity. This node must continue transmission until its queue is empty; this is a direct application of Prop. 1. As mentioned before, in Sec. 5, we discuss mechanisms by which the other nodes detect the fact that the node under service is now empty. At this point the problem is to select the next node for transmission. Given the greedy and exhaustive mechanism, it is then clear that at each scheduling instant the common information available to the centralized scheduler (and, in our system, to all nodes) is ùëâ ùúã (ùë°), the number of slots since each queue was
ùëó

last

served

(since

exhaustive

service

renders

ùúã
ùëÑ

ùë° ‚àí ùëâ ùúã (ùë°) ‚àí = 0, ‚àÄ ùëó). Given this common information,

ùëó

ùëó

which queue should be scheduled next so that mean delay is small? We answer this question in sections 4.3

and 4.5 .

4.3 The Longest Expected Queue (LEQ) policy

Let

the

arrival

rate

vector

be

denoted

by

ùùÄ

(‚àà

R

ùëÅ +

).

For

the

time

being,

this

information

will

be

assumed

to

be known to all queues, but we will lift this assumption in Sec. 9.1. For notational convenience, in the sequel,

we denote the number of slots since Queue ùëñ was last served, formerly denoted ùëâ ùúã (ùë°), by ùëâùëñ (ùë°) (omitting the
ùëñ

policy superscript). Since we consider exhaustive service, ùúÜùëñùëâùëñ (ùë°) is the expected backlog of queue ùëñ at ùë°, and

ùëéùëüùëî ùëöùëéùë•1‚â§ùëñ‚â§ùëÅ ùúÜùëñùëâùëñ (ùë°) is the longest expected backlog. We call the policy that, at every scheduling instant,

schedules this queue the Longest Expected Queue (LEQ) policy.

Proposition 2. The LEQ policy stabilizes all arrival rate vectors in the set

ùëÅ

‚àëÔ∏Å

Œõùêøùê∏ùëÑ :=

ùùÄ

‚àà

ùëÅ
R+

ùúÜùëñ < 1 and min ùúÜùëñ > 0 .

(6)

1‚â§ùëñ ‚â§ùëÅ

ùëñ=1

Proof. The proof essentially involves showing that the expected time to Ô¨Ånd the next nonempty queue (after serving some queue exhaustively) is bounded. Refer to Sec. 11.3 in the Appendix for details of the proof.

Comparing the deÔ¨Ånition of the region Œõùêøùê∏ùëÑ with that of the region Œõ in Eqn.(2) shows, quite clearly, that the LEQ policy is throughput optimal. We say that the system is ‚Äúsymmetric‚Äù or ‚Äúhomogeneous,‚Äù when

ùúÜùëñ = ùúÜ ‚àÄùëñ ‚àà ùêº.

(7)

In Sec. 11.4, we show that under symmetry (Eqn. (7)), ùëéùëüùëî ùëöùëéùë•1‚â§ùëñ‚â§ùëÅ ùúÜùëñùëâùëñ (ùë°) = ùëéùëüùëî ùëöùëéùë•1‚â§ùëñ‚â§ùëÅ ùëâùëñ (ùë°) and the policy reduces to a cyclic exhaustive service policy.

4.4 Stability of Cyclic Exhaustive Service
Before we embark on the analysis of this policy‚Äôs delay performance, we make an important observation about its stability. The cyclic exhaustive service policy is throughput optimal. The proof of the stability of the cyclic exhaustive service policy proceeds along the lines of the analysis in [AKL92]. Note, however, that the stability of this policy is proved for a system with general (possibly unequal) arrivals rates ùúÜ1, ¬∑ ¬∑ ¬∑ , ùúÜùëÅ , and includes, as a special case, the stability of the symmetric system. Formally,
Theorem 3. Consider the system capacity region deÔ¨Åned in Eqn. (2). If ùùÄ ‚àà Œõ, the system is stable under cyclic exhaustive service.
10

Comparison of Scheduling algorithms (20 queues) 70

Expected Delay (slots)

60

LEQ

50

Cyclic Exhaustive Service

Centralized Full‚àíknowledge Scheduler

40

30

20

10

0

0

0.2

0.4

0.6

0.8

1

Œ£k Œªk (pkts/slot)

Figure 4: Comparison of the performance of the LEQ and Cyclic Exhaustive Service policies. Also shown is the lowest possible

delay achievable in this system (black curve). This is discussed in detail in Sec. VI. We assume a Ô¨Åxed ratio of packet rates

that determines the arrival to each queue. SpeciÔ¨Åcally, ùúÜùëò = ùëüùëò ùúÜ is the arrival rate to Queue ùëò with

ùëÅ
ùëò=1 ùëüùëò

= 1.

In the plot,

ùúÜ ‚àà [0, 1).

Proof. The proof involves showing that the drift of a Lyapunov function computed at the end of ùëÅ busy periods, i.e., between two successive returns to any queue ùëñ, is negative. Refer to Sec. 11.5 in the Appendix for details.
Remark. Although we motivated cyclic exhaustive service as the LEQ policy specialized to symmetric systems, Thm. 3 shows that the former can actually stabilize unequal arrival rates as well. So we now have two throughput optimal scheduling policies (LEQ and cyclic exhaustive service). But since the LEQ policy requires estimates of the arrival rate vector and cyclic exhaustive service does not, can we do away with LEQ altogether? As Fig. 4 shows, with unequal arrival rates, LEQ can deliver substantially better delay performance and hence, is preferable to cyclic exhaustive service. In Sec. 9, we show how LEQ can be implemented in a distributed manner using arrival rate estimation, but where such estimation cannot be performed or is undesirable, cyclic exhaustive service can still be used to stabilize the system albeit at the cost of increased delay.

4.5 Delay Optimality of the LEQ policy in Symmetric Systems

We will now show that the LEQ policy specialized to symmetric systems, or the cyclic exhaustive service policy is mean delay optimal. The stability region for a symmetric system is obviously the interval ùúÜ = [0, 1 ).
ùëÅ
Recall that all scheduling decisions are made at the beginnings of slots and the only information available
then is whether the incumbent queue is empty and the number of slots since each queue in the system was last allowed to transmit 5. So, if the queue polled next turns out to be empty, the system wastes the entire
slot without transmitting any packets even if the other queues are nonempty.

ùëâùëñ (ùë°) is the last time Queue ùëñ's backlog was known to the system before time slot ùë°. We call a policy ùúã ‚àà Œ†

an SLQ (stochastically largest queue) policy if, at every instant ùë°, in which a switchover takes place, the

new queue chosen is not stochastically smaller than any other queue in the system. Formally, this means

that

whenever

ùëû
ùúã
ùë°

‚â†

ùúãùë°ùëû‚àí1,

ùëâùúãùëû (ùë°)

‚â•

ùëâùëò (ùë°)

for

every

ùëò

‚àà

ùêº.

The name SLQ arises from the fact that if

ùë°

ùëâùëô > ùëâùëò , and the two queues were served exhaustively, their current queue lengths, with Bernoulli arrivals,

5Note that, by Prop. 1, the additional knowledge that the incumbent queue has of its own queue length is not useful, since it is optimal for the incumbent to continue to transmit until its own queue is empty.

11

are Binomial(ùëâùëô, ùúÜ) and Binomial(ùëâùëò , ùúÜ) random variables respectively. Under these conditions, we know that Binomial(ùëâùëô, ùúÜ) is stochastically larger than Binomial(ùëâùëò , ùúÜ). Hence, the name.
Note that when ùëâùëô ‚â† ùëâùëò and ùúÜùëô ‚â† ùúÜùëò , it might not even be possible to stochastically order random variables distributed according to Binomial(ùëâùëô, ùúÜùëô) and Binomial(ùëâùëò , ùúÜùëò ). An example is when ùëâùëô > ùëâùëò , but ùúÜùëô < ùúÜùëò . Hence, with unequal arrival rates, the LEQ policy doesn‚Äôt necessarily choose the stochastically longest queue, but only the queue with the largest mean backlog. This is the diÔ¨Äerence between the LEQ and SLQ policies. In the sequel, we denote the set of all SLQ policies by Œ†ùë†.
Remark. Here, it should Ô¨Årst be noted that Prop. 5.1 of [LNT92] cannot be directly used with the present information structure, since the optimal policies derived therein have the property that the server never dwells at an empty queue. However, as mentioned at the end of Sec. 3, the queues only know if a queue was non-empty the last time it was polled. This always leaves open the possibility of scheduling an empty queue and wasting the entire slot. It is this slot-wastage conditioned on the chosen queue being empty that complicates matters, and also prevents us from simply reinterpreting such slots as switchover times.
We now explicitly derive the delay optimal policy for symmetric systems by presenting an expected delay version of the same result that uses the theory of Markov Decision Processes and is also of independent theoretical interest.

4.5.1 Mean Delay Optimality of Cyclic Exhaustive Service

Motivated by Prop. 1, we restrict ourselves to policies in which the channel is acquired by another queue

only if the queue under service is empty at the beginning of a slot. Suppose the queue scheduled in slot ùë°

is denoted by {ùë¢ùë° , ùë° ‚â• 0}. We seek a policy, say ùúã, to choose ùë¢0, ùë¢1, ¬∑ ¬∑ ¬∑ so as to minimize the following cost

function

1

ùëá ‚àí1 ùëÅ
‚àëÔ∏Å ‚àëÔ∏Å

lim sup Eùë†(0)

ùëÑùëñ(ùë°) ,

(8)

ùëá ‚Üí‚àû ùëá

ùë°=0 ùëñ=1

where ùë†(0) = [ùëÑ1 (0), ¬∑ ¬∑ ¬∑ , ùëÑùëÅ (0)] is the initial state of the system. This is the mean long-term backlog in

the system and, as described at the end of Sec. 2 can be used as a proxy for mean delay. In order to solve

this problem, we Ô¨Årst cast it as an ùõº-discounted cost minimization problem which involves minimizing the

cost function

‚àû

ùëÅ

‚àëÔ∏Å ‚àëÔ∏Å

ùë°
Eùë† (0) ùõº

ùëÑùëñ(ùë°) ,

(9)

ùë° =0

ùëñ=1

where ùõº ‚àà (0, 1) is the discount factor. We will later arrive at the solution to the long-term time averaged cost, (8), using a limiting procedure with a sequence of optimal policies ùúãùëò corresponding to a sequence of discount factors ùõºùëò ‚Üë 1. In what follows, we invoke the results of Propn. 1, and focus only on Œ†ùëî ‚à© Œ†ùëí.

4.5.2 Formulating The Discounted Cost MDP
In order to derive the optimal scheduling policy, we will slightly generalize the information structure as follows. At the beginning of slot ùë° all the queues know (i) the incumbent (ii) the number of slots since every queue was last served {ùëâùëò (ùë°), ùëò ‚àà ùêº} (iii) the queue-length of the incumbent, and (iv) residual known queue lengths in the queues (if any). It will turn out that the optimal policy (a) is a function only of the ùëâùëò s and the empty-nonempty status of the incumbent, and (b) serves queues exhaustively, so the residual known queue lengths in the queues are all zero. Thus, the information structure we have in our problem is suÔ¨Écient to implement the optimal policy we derive and this generalization is only required for the proof of delay optimality to go through.
12

The MDP, under the information structure wherein the queues know the backlog of the incumbent and V(ùë°) = [ùëâ1 (ùë°), ¬∑ ¬∑ ¬∑ , ùëâùëÅ (ùë°)]ùëá , has ùë†(ùë°) = ùëÑùë¢ùë°‚àí1 (ùë°); V(ùë°); r(ùë°); ùë¢ùë°‚àí1 ùëá as its state. The new coordinate r(ùë°) is explained as follows. At the beginning of slot ùë° (just after arrivals occur), the server knows that queue ( ùëó ‚â† ùë¢ùë°‚àí1) has length ùëü ùëó (ùë°) + ùëà ùëó and ùëà ùëó is a Binomial(ùëâùëó (ùë°), ùúÜ) random variable. To accommodate this new information, we expand our focus to the class of policies that always serve any queue ùëó such that ùëü ùëó (ùë°) > 0 in time slot ùë°. This means that if some queue ùëó has ùëü ùëó (ùë°) > 0 at the beginning of time slot ùë°, it is served in that slot and not the incumbent (ùë¢ùë°‚àí1), even if ùëÑùë¢ùë°‚àí1 (ùë°) > 0.
But these policies are still greedy and exhaustive, in the (restricted) sense that whenever r(ùë°) = 0 and ùëÑùë¢ùë°‚àí1 (ùë°) > 0, ùë¢ùë° = ùë¢ùë°‚àí1, i.e., if no other queue is known to have packets and the incumbent is non empty, it is served. This is a purely technical construction required for the proof of Thm. 4 and, as we will show later, the optimal policy (i.e., cyclic exhaustive service) will not require the knowledge of r(ùë°) at all. The action in every slot ùë° with an empty incumbent, involves choosing a queue ùë¢ùë° ‚àà ùêº and the single-step cost is the expected sum of the current queue lengths conditioned on the current state, given by

ùëÅ

‚àëÔ∏Å

‚àëÔ∏Å

‚àëÔ∏Å

ùëê(ùë†(ùë°), ùë¢ùë° ) = E ùëÑùëñ (ùë°)|ùë†ùë° = ùëÑùë¢ùë°‚àí1 (ùë°) + ùúÜ ùëâùëó (ùë°) + ùëüùëñ (ùë°). (10)

ùëñ=1

ùëó ‚â†ùë¢ùë° ‚àí1

ùëñ‚ààùêº

DeÔ¨Åne the state space as S := N √ó NùëÅ √ó NùëÅ √ó ùêº and optimal discounted cost ùêΩ‚àó : S ‚Ü¶‚àí‚Üí R+ starting in state

ùë†(0) ‚àà S as

‚àû

ùëÅ

ùêΩ‚àó (ùë†(0)) = ùëöùëñùëõ ùúâ Eùë†ùúâ(0) ‚àëÔ∏Å ùõºùë° E ‚àëÔ∏Å ùëÑùëñ (ùë°)|ùë†(ùë°) , (11)

ùë° =0

ùëñ=1

and let ùëû represent the backlog of queue ùëñ, the in-service queue. Note once again, that we have restricted our
focus to policies within Œ†ùëî ‚à© Œ†ùëí. The Bellman Optimality equations [Ber95] associated with the COMDP formulation as described above are as given in (12) (we denote ùêΩ‚àó (ùëû; V; r; ùëñ) by ùêΩ‚àó (ùëû; V; r)).
ùëñ

ùêΩ‚àó(ùëû

>

0;

V;

r

=

0)

=

ùëû

+

ùúÜ

‚àëÔ∏Å ùëâ

+ ùõºEùêΩ‚àó

ùëû ‚àí 1 + ùê¥; ùëâ

= 0, V‚àí

+ 1; r = 0 ,

ùëñ

ùëò

ùëñ

ùëñ

ùëñ

ùëò ‚â†ùëñ

ùêΩùëñ‚àó (ùëû = 0; V; r = 0) = ùúÜ ‚àëÔ∏Å ùëâùëò + ùõº min EùêΩ‚àóùëó ùêµ(ùëâùëó ); ùëâùëó = 0, V‚àí ùëó + 1; r = 0 , (12)
ùëó ‚â†ùëñ ùëò ‚â†ùëñ
In (12), ùê¥ is a generic Bernoulli(ùúÜ) random variable, V‚àíùëñ = [ùëâ1, ¬∑ ¬∑ ¬∑ , ùëâùëñ‚àí1, ùëâùëñ+1, ¬∑ ¬∑ ¬∑ , ùëâùëÅ ] and 1 ‚àà R(ùëÅ ‚àí1) is the vector with 1‚Äôs at all coordinates. Finally, if random variable ùê∂ is distributed Binomial(ùëâùëó , ùúÜ), ùêµ(ùëâùëó ) is a random variable whose distribution is the same as that of (ùê∂ ‚àí 1)+ + ùê¥. The detailed formulation of the MDP and the Bellman Optimality equations for the case where ùëü ùëó ‚â• 1 for some ùëó ‚àà ùêº ‚àí {ùëñ} can be found in Sec. 11.6 in the Appendix.
4.5.3 Solution to the Discounted Cost MDP
Clearly, no decision needs to be taken when either ùëû > 0 or (from Prop. 1,) when r ‚â† 0. Since the policies we seek are non-idling and exhaustive, they will simply continue to serve the incumbent when ùëû > 0 and therefore, states with r ‚â† 0 never actually arise. We will now show that if ùëû = 0 and r = 0, the system must choose ùëõ := arg max ùëó ùëâùëó . In what follows, let ùëâùëö < ùëâùëõ for some ùëö ‚àà ùêº, and ùëõ ‚â† ùëö. We now prove that choosing ùëõ results in the least cost.

13

Theorem 4. When ùëâùëö < ùëâùëõ,
EùêΩùëõ‚àó ùêµ(ùëâùëõ); ùëâùëõ = 0, V‚àíùëõ + 1; r‚àíùëõ = 0 ‚â§ EùêΩùëö‚àó ùêµ(ùëâùëö); ùëâùëö = 0, V‚àíùëö + 1; r‚àíùëö = 0 .
Hence, cyclic exhaustive service solves the discounted cost MDP.
Proof. The proof of the theorem can be found in Sec. 11.7 in the Appendix. Intuitively, with equal mean arrival rates, the queue that has not received service the longest is also the most likely to be non-empty. Hence, attempting to serve this queue will result in the slot being wasted with the least probability.
The policy above, denoted ùúã‚àó in what follows, chooses arg max ùëó ùëâùëó (ùë°) in every slot ùë° with an empty incumbent; in addition, by the exhaustive service r(ùë°) = 0 for all ùë°. In other words, ùúã‚àó is a stationary Markov policy that, at the beginning of each slot, chooses the incumbent, if nonempty, and the queue that has not been served the longest until that epoch, if the incumbent is found empty. Recall from Sec. 4.3 that ùúã‚àó is the cyclic exhaustive policy. In the sequel, we will use these two terms (‚Äúùúã‚àó‚Äù and ‚Äúcyclic exhaustive service‚Äù) interchangeably.
4.5.4 The Class of Throughput Optimal Stationary Markov Policies
We would next like to see if the class of stabilizing stationary Markov policies on these state and action spaces is a singleton, and if not, whether all policies in this class have the same cost. Obviously, both these situations would result in ùúã‚àó being a trivial solution to the MDP problem and hence, need to be discussed in detail. We now prove that that is, in fact, not the case.
Proposition 5. For the information structure in Sec. 4, the class of throughput optimal, Markov scheduling policies is not a singleton.
Proof. First, recall that ùúã‚àó itself is stabilizing as proved in Sec. 4.4. Next, consider a policy ùúã ‚àà Œ†ùëî ‚à© Œ†ùëí, starting with a given vector V(0) = V (ùúã‚àó starts with the same vector). When the in-service queue empties, ùúã chooses ùëö := ùëéùëüùëî ùëöùëéùë•1‚â§ ùëó ‚â§ùëÅ ùëâùëó except when V ‚àà ùëÜ ‚äÇ NùëÅ where ùëÜ is some Ô¨Ånite set. On ùëÜ , ùúã makes a suboptimal choice and deviates from ùúã‚àó, e.g., choosing ùëéùëüùëî ùëöùëéùë• ùëó‚â†ùëöùëâùëó . Clearly, this policy is stationary and Markov. We need to establish that it is also throughput optimal. Recall that Q(ùë°) ‚àà NùëÅ denotes the vector of backlogs at time ùë°. Now, since ùúã‚àó itself is stabilizing, by the Foster-Lyapunov criterion [FMM95, Thm 2.2.3], there exists6 a non-negative function, ùë¶ : NùëÅ ‚Üí R+, ùúñ > 0 and a Ô¨Ånite set ùê¥ ‚äÇ NùëÅ , such that,
‚â§ ‚àíùúñ, ‚àÄ q ‚àâ ùê¥, and E [ùë¶(Q(ùë° + 1)) ‚àí ùë¶(Q(ùë°))|Q(ùë°) = q]
< ‚àû, ‚àÄ q ‚àà ùê¥.
By expanding ùê¥ to ùê¥ = ùê¥ ‚à™ ùëÜ , and using the same Lyapunov function ùë¶, the Foster-Lyapunov criterion shows that ùúã is also stabilizing. Thus, considering the number of such subsets ùëÜ that can be chosen, we see that Œ†ùëî ‚à© Œ†ùëí contains inÔ¨Ånitely many stabilizing stationary Markov policies.
6The Foster-Lyapunov criterion is both necessary and suÔ¨Écient.
14

Collocated System with 30 queues
70 œÄ*

60

œÄ
1

œÄ
2

50

œÄ

3

40

Expected Delay

30

20

10 0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 Œª

Figure 5: ùúã1, ùúã2 and ùúã3 are suboptimal stabilizing stationary Markov policies, corresponding to ùëò = 40, 50 and 80 respectively. This Ô¨Ågure clearly shows that the class of stabilizing stationary Markov policies is not a singleton.

Moreover, these policies do not have the same cost! Suppose we deÔ¨Åne the set ùëÜ above to be the set
{0, 1, ¬∑ ¬∑ ¬∑ , ùëò }ùëÅ . This means ùúã will make sub-optimal decisions whenever 0 ‚â§ ùëâùëñ (ùë°) ‚â§ ùëò, ‚àÄùëñ ‚àà ùêº. Fig.5 shows the diÔ¨Äerence in cost between ùúã‚àó and three other policies ùúã1, ùúã2 and ùúã3 corresponding to ùëò = 40, 50 and 80. Note that all three policies are in Œ†ùëî ‚à© Œ†ùëí and are stabilizing, stationary and Markovian.

4.5.5 The Average-Cost Criterion
We use the technique described in [Sen89] to show that ùúã‚àó is optimal for the long term time-averaged cost criterion as well. We consider a sequence of discount factors {ùõºùëõ} ‚Üë 1 and the corresponding optimal policies and show that under certain conditions, the limit point of this sequence solves the Average-Cost problem, i.e., (8). For details, refer Sec. 11.10 in the Appendix.
Recall that we began this section with the aim of solving two centralized scheduling problems. Sec. 1 solved the Ô¨Årst, and we have now solved the second centralized, i.e., the optimal action the system needs to take when the incumbent is empty.

4.6 Alleviating Short term Unfairness: The K-Longest Expected Queue (KLEQ) Policy

While exhaustive service is delay optimal, it obviously exhibits short-term unfairness, especially at high arrival rates with the incumbent being served for long periods while other queues remain starved. While this might not be a cause of too much concern at low loads, near saturation, busy periods tend to be very long and starving queues might not be a good idea, especially if the application requires timely delivery of packets.

One of the ways of quantifying unfairness is by deÔ¨Åning a ‚ÄúFairness Index‚Äù, J (ùë°), as in [JCH84]. In our model, suppose we deÔ¨Åne ùë•ùëñ (ùë°), 1 ‚â§ ùëñ ‚â§ ùëÅ to be the fraction of time-slots in {0, 1, ¬∑ ¬∑ ¬∑ , ùë°} during which queue ùëñ was scheduled. Then, the fairness index at time ùë° is deÔ¨Åned as

2

ùëÅ ùëñ=1

ùë•ùëñ

(ùë°

)

J (ùë°) =

.

(13)

ùëÅ

ùëÅ ùëñ=1

ùë•ùëñ

(ùë°

)2

15

It can be shown, using the Cauchy-Schwarz inequality, that 1 ‚â§ J (ùë°) ‚â§ 1, ‚àÄùë° and the closer J (ùë°) is to 1,
ùëÅ
the fairer the allocation/algorithm [JCH84].
Fig. 6a compares the fairness indices of TDMA and Cyclic Exhaustive Service, near saturation (for a symmetric system with ùëÅ = 30 queues, ùúÜ < 1 ‚âà 0.033). The computation is over a period of 2 √ó 104 slots (we
ùëÅ
wait for the queue length processes to attain stationarity and only then record J (ùë°) for 2 √ó 104 slots) by which time, the indices attain their maximum value of 1. We see that although cyclic exhaustive service is delay optimal, it does exhibit short-term unfairness. The curious form of the curves corresponding to TDMA in Ô¨Ågures 6a and 6b respectively is due to the cyclic nature of the underlying TDMA schedule. Consider the TDMA fairnes curve. Since every queue gets scheduled exactly once every ùëÅ(= 30) slots, J (ùë°) shows the corresponding periodicity (notice that the swings have a period of 30). So, over slots 31 through 60 for example, J (ùë°) Ô¨Årst decreases, since the Ô¨Årst few queues get scheduled for a second time (while the others have been scheduled only once over slots 1 through 30) and then increases as this disparity reduces.

Fairness Index Fairness Index

Symmetric System with 30 queues (Œª = 0.03) 1

0.8

0.6

0.4

0.2 TDMA
Cyclic Exhaustive Service

0

100

101

102

103

104

105

t (slots)

(a) Comparing short term unfairness with TDMA and the cyclic exhaustive service policy, i.e., ùúã‚àó. TDMA clearly outperforms ùúã‚àó in this regard.

Symmetric System with 30 queues (Œª = 0.03) 1

0.8

0.6

0.4

KLEQ (K=1)

KLEQ (K=2)

0.2

Cyclic Exhaustive Service

TDMA

0

100

101

102

103

104

105

t (slots)

(b) Improvement in fairness with the KLEQ policy.

Figure 6: Alleviating short term unfairness through the KLEQ policy.

Towards alleviating this problem, consider the space Œ†ùêæ ‚äÇ Œ† of policies that do not permit a queue to transmit for more than ùêæ ‚â• 1 slots consecutively. Such policies are called ùêæ limited service policies. It is important to note that not all policies in Œ†ùêæ are throughput optimal. One prominent example is cyclic service, where, after serving queue ùëñ (for at most ùêæ slots), the server visits queue ùëñ mod ùëÅ + 1; refer [Tak88] for more details about the capacity regions of this policy and some of its variants. This means that the problem of deciding to which queue the system (server) should switch once a queue is empty or served for ùêæ consecutive slots, is non trivial. Here, we propose a policy that is both fair and throughput optimal. The proposed policy ùúãùêæ ‚àà Œ†ùêæ serves a queue for a maximum of ùêæ ‚â• 1 slots, and thereafter chooses to serve ùëéùëüùëî ùëöùëéùë•1‚â§ùëñ ‚â§ùëÅ ùëÑùëñ (ùë° ‚àí ùëâùëñ (ùë°)) + ùúÜùëñùëâùëñ (ùë°).

Proposition

6.

For

all

ùêæ

‚â•

1

and

ùùÄ

‚àà

ùëÅ
R+

such

that

ùëÅ
ùëñ=1 ùúÜùëñ

<

1,

ùúãùêæ

is

stabilizing.

Proof. The proof involves bounding the ùêæ slot conditional expected drift of a novel Lyapunov function. Refer Sec. 11.11 in the Appendix for details.
As can be seen from Fig. 6b, the KLEQ algorithm indeed improves fairness. In fact, with ùëò = 1 and ùëò = 2, KLEQ is able to achieve a fairness of 50%, about 100 and 90 slots before ùúã‚àó respectively. However, even more dramatic improvement in fairness is not possible, since stability pulls the protocol towards repeatedly
16

Figure 7: Illustrating the slot and minislot structures. Since ùëáùëù = 3, three poll-and-test procedures can be performed by the system (incumbent plus two other queues). If none of these results in identifying a nonempty queue, the system goes into contention over the next ùëáùëê = 4 minislots.
scheduling the same queue over consecutive sets of ùêæ slots. In Sec. 11.12 in the Appendix, we show how the above scheduler can be modiÔ¨Åed to handle Channel Errors and Fading.
5 Mechanisms for Decentralized Scheduling
We concluded Sec. 3 by providing a mechanism by which a node can keep track of the backlog of every other node the last time the latter was allowed to transmit. Prop. 1, shows that delay optimal policies with a centralized scheduler are non-idling and exhaustive in nature. Motivated by this result we will propose (in Sec. 6) a decentralized protocol that switches to a new queue only when the current one is empty. This immediately obviates the need to know anything more than the empty-nonempty status of the queues. In this section, we describe mechanisms by which this information can be obtained by the nodes in the system without any explicit exchange of information.
Transmission sensing: We assume that all nodes transmit at the same Ô¨Åxed power, and the maximum internode distance is such that every other node can sense the power from a transmitting node. Suppose a node has been scheduled to transmit in a slot. Then, whether or not the node actually transmits can be determined by the other nodes by averaging the received power over a small interval, akin to the CCA mechanism [Kin01]. For reliable assessment, the slot will need to be of a certain length, and the distance between the nodes will need to be limited. Let such an activity sensing slot be called a minislot (Fig. 7) [RWA+08].
The sensing mechanism and these minislots can be used by all nodes to infer if the incumbent is empty. If it is, with the updated common information, another node can be immediately scheduled, thereby possibly preventing the wastage of the slot. This can be viewed as a ‚Äúschedule-and-test‚Äù mechanism. If, say ùëáùëù minislots are available, then ùëáùëù poll-and-test procedures can be done at the beginning of a slot (see Fig. 7). In a light traÔ¨Éc setting, all the poll-and-test procedures might fail, with high probability. Having a large value of ùëáùëù reduces this probability but increases the overhead. So, the next mechanism is contention, for which we have ùëáùëê (‚â• 0) minislots following the poll-and-test slots. The nodes that have not been polled can contend over these ùëáùëê minislots, hopefully leading to the identiÔ¨Åcation of one non-empty queue. Fig. 8 illustrates this mechanism for a simple system with ùëáùëù = 1 and ùëáùëê = 0. In the Ô¨Årst slot in the Ô¨Ågure, the absence of power indicates, to all nodes in the network, that Node 1 is now empty and Node 2 is allowed to transmit. Since Node 2 is also empty, and since no more poll-and-test procedures are possible (since ùëáùëù = 1), the slot is wasted. Note that if ùëáùëù = 2, and ùëáùëê ‚â• 1, sensing that Node 2 is empty, the other nonempty nodes in the network will contend for the slot.
17

Figure 8: A sample path illustrating how cyclic exhaustive service, i.e. ùúã‚àó, is implemented in a system with ùëáùëù = 1 and ùëáùëê = 0. Of particular note is the initially wasted slot. Since the poll-and-test did not identify any nonempty queue and since the system cannot go into contention (ùëáùëê = 0), the slot is wasted.
6 Protocol Design
In this section, we develop the two protocols EZMAC and QZMAC. We Ô¨Årst show how a simple modiÔ¨Åcation of the contention mechanism in ZMAC results in signiÔ¨Åcant gains in terms of delay and use that observation to design EZMAC. We then use the results in Sec. 4 to motivate the practical design of QZMAC. This section will clearly describe how the optimal polling schemes in Section 4.2 are implemented in a distributed manner which will establish the self-organizing nature of our protocols.
6.1 The EZMAC Protocol
We explain the limitations of ZMAC and propose another protocol that we call EZMAC to alleviate them.
6.1.1 The ZMAC protocol [RWA+08]
As mentioned before, ZMAC Ô¨Årst sets up a TDMA schedule allotting a slot to every queue in a cyclicallyrepeating frame, so ùëÅ nodes in the system means a frame with ùëÅ slots. Slot ùëó, 1 ‚â§ ùëó ‚â§ ùëÅ, in every frame is assigned to Node ùëó which is called the Primary User (PU) in this slot. The other (ùëÅ ‚àí 1) nodes, i.e., nodes 1, 2, ¬∑ ¬∑ ¬∑ , ùëó ‚àí 1, ùëó + 1, ¬∑ ¬∑ ¬∑ , ùëÅ, are called Secondary Users (SUs) in this slot. These SUs are allowed to contend for transmission rights in every TDMA slot with an empty PU. This is accomplished as follows. At the beginning of each time slot, each queue checks if it has a packet. If it does, and this is its TDMA slot (which means it is the PU), it proceeds to transmit the packet. If the current slot is NOT its TDMA slot, the queue Ô¨Årst checks if the PU is transmitting (for a period of 1 minislot). If it hears nothing, it backs oÔ¨Ä over a duration chosen uniformly randomly over {ùëáùëù + 1, ¬∑ ¬∑ ¬∑ , ùëáùëù + ùëáùëê }, and if the channel is clear, starts transmitting. Collisions are assumed to be detected instantaneously and that slot is assumed wasted. Note that a mechanism is needed to set up the TDMA schedule before transmissions can begin (ZMAC uses DRAND for this [RWMX06]). In short, ZMAC proceeds as in Protocol 1.
We are now in a position to demonstrate the importance of the results obtained in Sec. 4.5. ZMAC uses a simple TDMA system that schedules queues only once every ùëÅ slots. While TDMA is certainly stabilizing in symmetric systems, it is far from delay optimal. Fig. 9 shows how ùúã‚àó shows enormous improvement over ZMAC at moderate and high loads. The two curves crossover near ùúÜ = 0.775. At these arrival rates, since many queues are nonempty, hitting empty queues proves very costly to the system (in terms of delay). This is because many queues contend during the contention portion of ZMAC (the ùëáùëê minislots) diminishing chances of a winner ever emerging. Since TDMA polls a new queue in every slot, it ends up scheduling many empty queues incurring high delay that cannot be mitigated by contention.
18

Protocol 1 ZMAC

1: Input: ùëÅ, ùëáùëê

‚ä≤ QZMAC runs in parallel at every Queue ùëó, ùëó ‚àà [ùëÅ] in the network

2: Init: ùë° ‚Üê 0, ùúè ‚Üê 1, ùëÉùëà ‚Üê 1

‚ä≤ ùúè keeps track of the minislot number

3: while ùë° ‚â• 0 do

ùúè‚Üê1

‚ä≤ Keeps track of minislot number.

4: if ùëÉùëà == ùëó && ùëÑ ùëó (ùë°) > 0 then

‚ä≤ If you are the PU

5:

Tx pkt.

6:

GOTO 16

7: else

‚ä≤ PU empty ‚áí network enters contention

8:

Over ùúè ‚àà {2, 3, ¬∑ ¬∑ ¬∑ , ùëáùëê + 1} do

9:

if ùëÑ ùëó (ùë°) > 0 then

10:

ùëà ùëó ‚àº ùëàùëõùëñ ùëì ({2, 3, ¬∑ ¬∑ ¬∑ , ùëáùëê + 1})

11:

Wait for ùëà ùëó ‚àí 1 minislots.

12:

If CCA == SUCCESS, Tx Pkt.

13:

GOTO 16

14:

end if

15: end if

16: ùëÉùëà ‚Üê ùëÉùëà mod ùëÅ + 1

17: ùë° ‚Üê ùë° + 1

‚ä≤ Next time slot

18: end while

Getting back to the development of EZMAC, consider the contention mechanism in isolation. If the contention winner can retain rights to access the channel for exactly one slot (which is what happens in ZMAC), each time the PU is empty, contention is needed to decide the next winner. We shall, henceforth, refer to the contention mechanism that allows a contention winner to transmit only in one slot as ‚ÄúALOHA.‚Äù That ALOHA wastes a lot of slots in contention is clearly demonstrated in the large diÔ¨Äerence in delay in Fig. 10. This problem is solved as follows.
The proposed protocol EZMAC diÔ¨Äers from ZMAC in the contention resolution (CR) portion. Here, once the winner of a contention is determined, it is allowed to transmit in all slots without a PU until it empties. It is assumed that at the end of the winner‚Äôs transmission, the packet contains an end of transmission message (a bit in the header, perhaps) that can be decoded by the other users. Following the terminology in the literature ( [HK83], for example), we refer to the contention mechanism that allows a contention winner to transmit until it is empty, ‚ÄúRALOHA,‚Äù which stands for ALOHA with Reservation. Also, when referring to either EZMAC or QZMAC, we will redeÔ¨Åne the term SU to refer to the queue that has won the latest

Homogeneous System with 30 queues 600

Mean Delay (slots)

500

Centralized Full knowledge

Cyclic Exhaustive Service (œÄ*)

ZMAC

400

TDMA

300

200

100

0

0

0.2

0.4

0.6

0.8

1

Total Arrival Rate (packets/slot)

Figure 9: Comparing ùúã‚àó and ZMAC in a symmetric system with 30 queues. The total arrival rate to the system = ùëÅ ùúÜ ‚àà [0, 1).

19

Expected Delay (slots)

Collocated system with 10 queues 2.8

2.6

2.4

ALOHA

2.2

RALOHA

2

1.8

1.6

1.4

1.2

1

0.8

0

0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08

Œª (pkts/slot)

Figure 10: Mean delay with ALOHA and RALOHA in a symmetric system with 10 queues.

contention. EZMAC modiÔ¨Åes Steps 7-14 of ZMAC to At time slot ùë°:
1. If PU is empty, check if the current SU is nonempty. If so schedule it for transmission.
2. If not, begin contention as described in the beginning of Sec. 6.1. Suppose there is no collision and a new SU, say ùëò, emerges, schedule ùëò for transmission. This will remain the SU until it becomes empty.
If the current slot is not the user‚Äôs TDMA slot, it checks if the PU is transmitting. If not and if the SU is also empty, the user contends for access to the channel as described above. The winner keeps transmitting in all slots where the PU is empty, until it is itself empty. Thereafter, in the next slot with an empty PU, contention begins to determine the next SU.

6.2 The QZMAC protocol
In section 4.5.2 we proved that in symmetric systems, scheduling the queue that has not been served the longest and serving it exhaustively is delay optimal. Recall that Thm. 4 therein, assumed ùëáùëù = 1. However, we use this result to propose a scheduling protocol, QZMAC, for general ùëáùëù, and later show through simulations that violating the ùëáùëù = 1 assumption does not hurt the performance of QZMAC. Solving the MDP for general ùëáùëù turns out to be a hard problem and, as simulation results in Ô¨Ågures 13a and 13b show, cannot result in any dramatic improvement in delay. We now describe QZMAC for ùëáùëù = 3 minislots. Every queue maintains its own copy of a vector V(ùë°) that is used to render the scheduling process fully distributed. The protocol proceeds as in Algorithm. 2.
There are three points to note here. Firstly, QZMAC has clearly been obtained by separately optimizing polling and contention protocols. Jointly optimizing both turns out to be intractable and even separate optimization ultimately shows excellent delay performance. Secondly, note that depending on the value of ùëáùëù QZMAC can show a range of behavior. When ùëáùëù = 1, the system never enters contention since one minislot is spent in ascertaining that the incumbent is empty and thereafter, ùëñ‚àó is allowed to transmit. Determining that ùëñ‚àó is empty requires another minislot which is not available since ùëáùëù = 1, and the system can enter contention only when ùëñ‚àó and the SU are empty.
So, in order for the system to enter contention, QZMAC needs ùëáùëù = 3 (one each for the PU, ùëñ‚àó and the SU). Similarly, ZMAC requires ùëáùëù = 1 and EZMAC requires ùëáùëù = 2. Finally, as mentioned in Sec. 4.5.3, the use
20

Protocol 2 QZMAC (with ùëáùëù = 3 minislots),

1: Input: ùëÅ, ùëáùëê

2: Init: ùë° ‚Üê 0, ùúè ‚Üê 1, ùëÉùëà ‚Üê 1, ùëÜùëà ‚Üê 2

3: Init: ‚àÄ ùëò ‚àà [ùëÅ], ùëâùëò (0) ‚Üê ùëò

4: while ùë° ‚â• 0 do

ùúè‚Üê1

5: if ùëÉùëà == ùëó && ùëÑ ùëó (ùë°) > 0 then

6:

ùëÉùëà transmits packet.

7:

for ùëò = 1 : ùëÅ do

8:

ùëâùëò (ùë°) ‚Üê (ùëâùëò (ùë°) + 1) I{ùëò‚â†ùëÉùëà }

9:

end for

10:

GOTO 35

11: else

12:

ùúè ‚Üê ùúè+1

13:

ùëñ‚àó := ùëéùëüùëî ùëöùëéùë•ùëñ‚àà[ùëÅ ]ùëâùëñ (ùë°)

14:

ùëÉùëà ‚Üê ùëñ‚àó

15:

if ùëñ‚àó == ùëó && ùëÑùëñ‚àó (ùë°) > 0 then

16:

ùëÉùëà transmits packet.

17:

for ùëò = 1 : ùëÅ do

18:

ùëâùëò (ùë°) ‚Üê (ùëâùëò (ùë°) + 1) I{ùëò‚â†ùëÉùëà }

19:

end for

20:

GOTO 35

21:

else if ùëÜùëà == ùëó && ùëÑùëÜùëà (ùë°) > 0 then

22:

ùúè ‚Üê ùúè+1

23:

ùëÜùëà transmits packet.

24:

GOTO 35

25:

else

26:

Over ùúè ‚àà {4, 5, ¬∑ ¬∑ ¬∑ , ùëáùëê + 3} do

27:

if ùëÑ ùëó (ùë°) > 0 then

28:

ùëà ùëó ‚àº ùëàùëõùëñ ùëì ({4, 5, ¬∑ ¬∑ ¬∑ , ùëáùëê + 3})

29:

Wait for ùëà ùëó ‚àí 4 minislots.

30:

If CCA == SUCCESS, Tx pkt.

31:

If no collisions detected, ùëÜùëà ‚Üê ùëó

32:

end if

33:

end if

34: end if

35: ùë° ‚Üê ùë° + 1

36: end while

‚ä≤ This runs at every Queue ùëó, ùëó ‚àà [ùëÅ] in the network ‚ä≤ ùúè keeps track of the minislot number ‚ä≤ Keeps track of minislot number. ‚ä≤ If you are the PU
‚ä≤ The 2nd of ùëáùëù minislots
‚ä≤ The last ùëáùëù minislot ‚ä≤ SU empty ‚áí network enters contention ‚ä≤ Queue ùëó knows its own backlog exactly in each slot
‚ä≤ Next time slot

of the V(ùë°) vector automatically induces a cyclic schedule. This is a much simpler technique than DRAND, used in ZMAC [RWMX06], which involves several rounds of communication among the nodes to converge to a TDMA schedule, even for fully connected interference graphs.

7 Extending QZMAC
QZMAC was developed in Sec. 6.2as a hybrid of certain polled and random access protocols, in symmetric systems, i.e., with applications that generate data at the same rate. In this section, we show how this
21

protocol can be modiÔ¨Åed to handle a variety of diÔ¨Äerent applications. We begin by lifting this assumption on symmetry.
7.1 Handling Unequal Arrival Rates
Prop. 2 helps generalize QZMAC very easily to accommodate unequal arrival rates. The system only needs to choose ùëéùëüùëî ùëöùëéùë•1‚â§ùëñ‚â§ùëÅ ùúÜùëñùëâùëñ (ùë°) in Step 13 of QZMAC. In Sec. 9.1 we discuss distributed implementation and eÔ¨Äects of distributed arrival rate estimation.
7.2 Handling CCA errors
We have, hitherto, assumed that when a network queue tests for channel activity (or lack thereof), the test always succeeds. In real wireless sensor networks this operation, called a Clear Channel Assessment (CCA), involves a hypothesis test based on noisy samples of channel activity and hence, is susceptible to error. This makes a 100% success rate a strong assumption and we relax it in this section. Notice that crucially, CCA errors tamper with the Ô¨Ådelity of the V(ùë°) vector across nodes and we now have a matrix ùëâùëÅ √óùëÅ (ùë°) = [V1 (ùë°), V2 (ùë°), ¬∑ ¬∑ ¬∑ , VùëÅ (ùë°)], where Vùëñ (ùë°) is the local copy at Queue ùëñ.
Extensive experimentation (reported in Sec. 8) reveals that absence of activity on the channel can be detected without error. This means that whenever a queue that is supposed to transmit (incumbent, ùëñ‚àó = ùëéùëüùëî ùëöùëéùë•ùëñ‚àà[ùëÅ ]ùëâùëñ (ùë°) or the SU) is empty, all CCAs across the network in that minislot report a ‚Äúclear channel.‚Äù In detection theoretic parlance, the probability of a false alarm is zero, i.e., ùëùùêπ ùê¥ = 0. On the other hand, our observation is (see Sec. 8) that the probability of CCA declaring an ‚Äúactive‚Äù channel as ‚Äúclear‚Äù is not zero, i.e., ùëùùëöùëñùë†ùë† > 0. However, our experiments show that ùëùùëöùëñùë†ùë† ‚âà 3 √ó 10‚àí6, i.e., CCA miss is a rare event. In Sec. 11.14 in the Appendix, we list the diÔ¨Äerent types of misalignment that such errors can produce across the columns of the aforementioned ùëâ (ùë°) matrix of which only the category termed M2 therein, necessitates modiÔ¨Åcations to QZMAC. A misalignment of type M2 occurs when the ùëñ‚àó Node assumes that the incumbent is empty and, being nonempty, begins transmitting. Naturally, the transmissions from the two nodes collide persistently, and further provisions are now required within QZMAC to extricate the network from this state. The polling portion is modiÔ¨Åed as follows. We set a threshold ùêæùë°‚Ñéùëü such that any time the transmitting node(s) perceive ùêæùë°‚Ñéùëü time outs, the node(s) assume it is due to CCA errors. These transmitting nodes then enter a state we term ‚ÄúCOLL‚Äù and Subroutine 3 is triggered. Informally, the subroutine does the following.
1. Until the transmitting nodes receive a reset beacon (denoted RSTBCN), the Ô¨Årst ùëáùëù minisolt of every slot following the ùêæùë°‚Ñéùëü timeouts is ‚ÄôBUSY‚Äô, ensuring no other queues attempt transmissions during those slots.
2. In every such slot, the transmitting nodes perform a random backoÔ¨Ä and transmit a RESET RQST packet to the base station.
3. Upon reception of a RESET RQST packet, the Base Station broadcasts a RESET beacon.
The network then simply resets, i.e., the copy of the vector V(ùë°) at each node is reset (without jettisoning any existing packets) and the protocol starts afresh. Note that while only the nodes in a COLL state trigger a reset (Steps 3-14), all nodes are required to reset their copies of the V(ùë°) vector upon receiving a RESET beacon from the Base Station (Steps 15-17). As simulation results in Sec. 11.14 show, this simple modiÔ¨Åcation resolves the CCA problem but does not harm delay performance adversely.
22

Protocol 3 RESET (Subroutine)

1: Input: THRSLD, NDST, RSTBCN

2: Init: RSTBCN == FALSE ‚ä≤ Keeps track of whether a RESET beacon has been received from the BS.

3: if NDST == COLL then

‚ä≤ Network resetting involves only colliding nodes.

4: while NDST == COLL && RSTBCN == FALSE do

5:

Tx DUMMY PKT

‚ä≤ To jam all ùëáùëù minislots.

6:

Over ùúè ‚àà {4, 5, ¬∑ ¬∑ ¬∑ , ùëáùëê + 3} do

7:

ùëà ùëó ‚àº ùëàùëõùëñ ùëì ({4, 5, ¬∑ ¬∑ ¬∑ , ùëáùëê + 3})

8:

Wait for ùëà ùëó ‚àí 4 minislots.

9:

If CCA = SUCCESS, Tx RSTRQST pkt

‚ä≤ Tx a Reset Request to the BS.

10:

if RSTBCN == TRUE then

‚ä≤ The BS transmits a RESET beacon.

11:

NDST ‚Üê NOCOLL

12:

end if

13: end while

14: end if

15: if RSTBCN == TRUE then

‚ä≤ Every node in the network resets.

16: ‚àÄùëò ‚àà [ùëÅ], ùëâùëò (ùë°) ‚Üê ùëò .

17: end if

Figure 11: The QZMAC testbed setup. Here, the center node is the Border Router for the network. The other nodes, numbered 1 to 4, are the sensor nodes. These nodes are programmed to run the QZMAC protocol and transmit packets to the Border Router.
8 Experiments on an Implementation of QZMAC
We implement the QZMAC algorithm as an additional module in the MAC layer of the 6TiSCH communication stack under the Contiki operating system [DGV04]. With the aid of in-built Contiki-based APIs, we implemented diÔ¨Äerent wireless transceiver functionalities and carried out our experiments over Channel 15 of the 2.4 GHz ISM band. We deployed CC2420 based telosB motes placed equidistant from the receiver node on a circular table Fig. 11. Here, the node placed in the center acts as a ‚ÄúBorder Router‚Äù (BR). The BR is always connected to a PC (host) through a USB cable; the BR collects the data packets from the sensor nodes and sends them to the host, which can further route them to the data processing computer over the Internet. Nodes labeled 1 to 4 in Fig. 11 are the sensor nodes upon which QZMAC runs. Our experiments aim to study the following aspects:
‚Ä¢ The network infers and maintain the status of V vector based on empty and non empty status of sensor nodes.
23

‚Ä¢ Verify the protocol working in contention mode as described between step 25 and step 33 of the QZMAC
‚Ä¢ CCA status inference across the slots
‚Ä¢ Synchronization within the network
8.1 Frame Structure: Time Slots and Mini-Slots
Time Slotted Channel Hopping (TSCH) is a MAC layer speciÔ¨Åed in the IEEE 802.15.4-2015 [iee16] standard, with a design inherited from WirelessHART and ISA 100.11a standards. In our implementation, we used the slots deÔ¨Åned as part of TSCH within Contiki (sans the channel hopping utility). The duration of a time slot is 10ùëöùë† which is suÔ¨Éciently long for the transmitter to transmit the longest possible packet and for the receiver to return an acknowledgment. The slots are further divided into polling minislots and contention minislots as shown in Fig. 7. The minislots are of two standard Clear Channel Assessment (CCA) duration, where 1 CCA duration is 128 microseconds. In our experiments, we used 3 polling and 9 contention minislots i.e. ùëáùëù = 3, and ùëáùëê = 9.
8.2 Time Synchronization
Maintaining network-wide time synchronization at the level of the minislots is a nontrivial problem. For our experiments, we used the Adaptive Synchronisation Technique [CWPW15]. The Border Router periodically broadcasts Enhanced Beacons (EBs) containing a Ô¨Åeld indicating the current slot number also known as Absolute Slot Number (ASN). The other nodes store the ASN value and increment it every slot to keep the time slot number aligned. To align the time slot boundaries, the Ô¨Årst mini-slot begins after a guard time oÔ¨Äset of TsTxOffset from the leading edge of every slot. Every node timestamps the instant it starts receiving the EB, and then aligns its internal timers so that its slot starts exactly TsTxOffset before the reception of EB. In our implementation we used TsTxOffset=1.8ms. Through extensive experimentation, we veriÔ¨Åed that clock drifts were not aÔ¨Äecting the protocol‚Äôs working across the minislots. The nodes form a 1-hop fully connected network. We used the ‚ÄúRouting Protocol for Low-Power and Lossy Links‚Äù (RPL) to form the routes within the network [W+12] and veriÔ¨Åed the working of our Ô¨Årmware on the COOJA simulator [ODE+06], before compiling it on to real target motes. We now describe our experimentation methodology in detail.
8.3 CCA Errors : Inference and Handling
To study the eÔ¨Äect of CCA errors on our protocol, we set up two testbeds (similar to the one in Fig. 11) with network diameter 6 meters and 8 meters respectively, each running QZMAC for a period of 12 hours (i.e., 3 √ó 106 time slots). The sensor nodes were programmed to generate packet at constant rate ensuring the queue at sensor nodes are always non empty and transmit as per the protocol. One of the sensor nodes was connected to a terminal and designated to monitor the CCA status during the experiment. Over the course of our experiment, we observed 1 CCA ‚ÄúMiss‚Äù error on the testbed with 6 m network diameter and, on the network with 8 m diameter, we recorded 3 CCA ‚ÄúMiss‚Äù errors, both calculated over a period of 12 hours. No False Alarms were observed. Further, in any given time slot at most one CCA error occurred network-wide.
24

9 Experimental Results
We now report the results of our extensive implementation and simulation studies of the various algorithms proposed in the earlier sections. We also deal with practical issues, such as arrival rate estimation and channel utilization. We begin with the performance of the LEQ algorithm proposed in Sec. 4.3. Protocols such as ZMAC [RWA+08] and subsequent developments such as [DNF+05], [AHM+06] and [SSB10] have not been designed to address the issue of unequal arrival rates. These protocols are not capable of stabilizing queues in this general setting, let alone provide low delay. Furthermore, the rigid cyclic TDMA structure imposed by the slot assignment protocol prevents extension to unequal arrival rates.
To the best of our knowledge, this is the Ô¨Årst work that deals with hybrid MAC scheduling for systems with unequal arrival rates. Consequently, we do not have any hybrid algorithms against which to compare the LEQ policy. The ZMAC protocol‚Äôs cyclic TDMA schedule assigns a single slot to each queue in one TDMA frame and hence is not Throughput Optimal. Furthermore, computing even an approximately delay optimal TDMA schedule requires complete knowledge of the arrival rate vector and even then requires prohibitively high message passing between nodes. One such procedure is given in [HR87]. It can be seen that the lower bound on delay even within the class of cyclic TDMA policies cannot always be achieved by this method; one example is when the arrival rates are irrational. Moreover, the general problem of Ô¨Ånding the periodic TDMA schedule of minimum length is NP-complete [AAKD08]. We, therefore, provide comparisons only with the lowest delay that can be achieved in this system, i.e., the one with a centralized scheduler that schedules a non empty queue in every slot.
9.1 Distributed Implementation of the LEQ policy
In the LEQ policy, keeping track of the vector V(ùë°) is simple. Each queue simply needs to maintain a count of the number of departures before the queue in service empties. But the arrival rates are a diÔ¨Äerent issue altogether. Clearly, Ô¨Ånding ùëéùëüùëî ùëöùëéùë•1‚â§ùëñ‚â§ùëÅ ùúÜùëñùëâùëñ (ùë°) in every scheduling slot requires knowledge of the entire arrival rate vector ùùÄ. Arrival rate estimation might not be feasible in several sensor networks of today that are expected to begin performing as soon as they are installed. For more information about this ‚Äúpeel and stick‚Äù paradigm refer to [DWVT14].
We resolve this problem by Ô¨Årst observing that under stability, the time average of the total number of packets transmitted by any queue tends to the arrival rate. Let ùê∑ùëñ (ùë°) be the random variable that denotes whether or not a departure occurred from queue ùëñ at the end of slot ùë°. Then, under stability, limùëá ‚Üí‚àû ùëá1 ùëáùë°=0 ùê∑ùëñ (ùë°) = ùúÜùëñ, ùëé.ùë†. So, let ùúÜÀÜùëñ (ùëá ) := ùëá1 ùëáùë°=0 ùê∑ùëñ (ùë°). The policy that chooses ùëéùëüùëî ùëöùëéùë•1‚â§ùëñ‚â§ùëÅ ùúÜÀÜùëñ (ùë°)ùëâùëñ (ùë°) in every scheduling slot also shows the same mean delay performance as the LEQ policy, as evidenced by simulation results presented below. This estimate can be maintained independently at each queue and the resulting decisions are still consistent. In Fig. 12a and Fig. 12b, we show the delay performance of QZMAC which takes decisions based on exact knowledge of arrival rates and the distributed version that only uses estimates of arrival rates. The green and red curves, corresponding to scheduling with estimated and exact arrival rates respectively, overlap signiÔ¨Åcantly, showing that arrival rate estimation does not degrade performance. Moreover, in small systems (Fig. 12a), the delay is almost the lowest that can be achieved, while with larger systems, the diÔ¨Äerence with the centralized scheduler‚Äôs delay becomes non negligible only near saturation.
With QZMAC, the nodes need to Ô¨Årst determine that the incumbent is empty, followed by detecting if the LEQ is empty and Ô¨Ånally, if the current contention winner is empty before entering contention mode. Since each of these requires 1 minislot, QZMAC uses ùëáùëù = 3 minislots and ùëáùëê = 7 minislots and ùëáùëù + ùëáùëê = 10. We will need to keep this total number of minislots the same for all protocols whose performances we compare (in Sec. 9.2) to ensure that the fraction of time per slot allocated to scheduling decisions (and not packet
25

transmission) is the same in all protocols being studied. Simulations are performed with ùëÅ = 10 and 30 nodes. In either case, we see that both protocols show the same delay performance. While in small systems (10 queues), the protocol very nearly hits the delay lower bound (with less than 1 slot delay diÔ¨Äerence near saturation), in large systems (30 queues) near saturation, the diÔ¨Äerence is larger (approximately 32% increase).

Expected Delay (slots) Expected Delay (slots)

System with 10 queues (unequal arrival rates) 40

35

Centralized full knowledge

30

QZMAC (LEQ computed with exact arrival rates)

QZMAC (LEQ computed with estimated arrival rates)

25

20

15

10

5

0 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1
Œ£iŒªi (pkts/slot)
(a) System with 10 queues.

System with 30 queues (unequal arrival rates) 70

60

Centralized full knowledge

50

QZMAC (LEQ computed with exact arrival rates)

QZMAC (LEQ computed with estimated arrival rates)

40

30

20

10

0

0

0.2

0.4

0.6

0.8

1

Œ£iŒªi (pkts/slot)

(b) System with 30 queues.

Figure 12: Performance of QZMAC with exact and estimated arrival rates (ùëáùëù = 3 and ùëáùëê = 7).

9.2 Performance of EZMAC and QZMAC

With Bernoulli arrivals to each queue, the centralized full knowledge scheduler converts the system into a ùê∫ùëíùëú[ùë•]/ùê∑/1 queue. In every slot, the arrivals to this queue are distributed according to a Binomial(ùëÅ, ùúÜ) distribution, where ùúÜ ‚àà [0, 1/ùëÅ) is the common arrival rate to all queues. This queue can be analysed for expected delay ùëä (ùúÜ) [BK93], and we get:

2 ‚àí (ùëÅ + 1)ùúÜ

ùëä (ùúÜ) =

.

(14)

2(1 ‚àí ùëÅùúÜ)

We compare all protocols against this lower bound.

We Ô¨Årst consider a system with equal arrival rates and compare the performance of QZMAC with that of the ùê∫ùëíùëú[ùëã ]/ùê∑/1 queue as described in (14), ZMAC and EZMAC. We see from Ô¨Ågures 13a and 13b, that the delay achieved by QZMAC is very close to optimal as is that achieved by EZMAC. In Fig. 13a, the ùê∫ùëíùëú[ùë•]/ùê∑/1 queue delay cannot be seen explicitly since QZMAC performs almost exactly like it. This is quite encouraging since QZMAC only needs knowledge of the time since a queue was served last, while the optimal algorithm needs full queue-length knowledge at all times. With 30 queues, in fact, QZMAC shows a decrease in delay over ZMAC of more than 60% and EZMAC of more than 40%. Note that since QZMAC requires ùëáùëù = 3, in order to keep the scheduling portion‚Äôs length ùëáùëê + ùëáùëù constant so as to maintain the scheduling portion to transmission portion (see Fig. 7) fraction uniform across protocols, we have reduced the contention window size by three minislots while simulating QZMAC. Also, as the Ô¨Årst Ô¨Ågure shows, for low and moderate arrival rates, in small WSNs one can use EZMAC and still achieve good delay performance.

9.3 Tuning QZMAC
One can tune QZMAC by changing ùëáùëù and ùëáùëê keeping ùëáùëù +ùëáùëê = ùëê, a constant. As the number of slots reserved for polling, ùëáùëù increases, Fig. 14 shows that QZMAC with fewer polling slots initially performs better, but at
26

Expected Delay (slots) Expected Delay (slots)

Symmetric system with 10 queues 200

150 Geo[x]/D/1 QZMAC

EZMAC

ZMAC

100

TDMA

50

0

0

0.02

0.04

0.06

0.08

0.1

Œª (pkts/slot)

(a) System with 10 queues.

600 500 400 300 200 100
0 0

Symmetric system with 30 queues
Geo[x]/D/1 QZMAC EZMAC ZMAC TDMA

0.005 0.01 0.015 0.02 0.025 0.03 Œª (pkts/slot)
(b) System with 30 queues.

0.035

Figure 13: Expected delay with QZMAC, ZMAC and EZMAC. The systems have 10 queues 13a and 30 queues 13b. ùëáùëê = 9 for ZMAC and 8 for EZMAC. For QZMAC, ùëáùëê = 7.

Expected Delay (slots)

Symmetric system with 30 queues 5

4.5

4

QZMAC T =3
p

QZMAC T =8

p

3.5

ZMAC

3

2.5

2

1.5

1

0

0.005

0.01

0.015

0.02

0.025

0.03

Œª (pkts/slot)

Figure 14: Figure showing how QZMAC can be tuned. Keeping ùëáùëù + ùëáùëê Ô¨Åxed at 10 minislots, increasing ùëáùëù causes delay to increase at light loads and decrease at heavy loads.

high loads, is overtaken by QZMAC with fewer slots for contention. At arrival rates close to 0 (i.e., ùúÜ ‚âà 0), it is an SU that transmits during most slots. This is because, with high probability, the PU‚Äôs are empty and the protocol enters the contention portion. Clearly, higher the value of ùëáùëê, greater the probability of resolving this contention. But at high loads (ùúÜ ‚âà 1 ) the PU‚Äôs are nonempty with high probability and
ùëÅ
hence, the polling portion is more likely to yield a nonempty queue. With a higher value of ùëáùëù, a nonempty queue can be found and the system does not have to go into contention. This trend is expected and opens up avenues for further research about protocols that automatically choose the ‚Äúright‚Äù ùëáùëê and ùëáùëù given that the fraction of time occupied by the scheduling portion must not exceed some predetermined threshold.
We simulated all three algorithms (QZMAC, EZMAC and ZMAC) once again, in symmetric systems and computed the (empirical) cumulative distribution functions (CDFs) of system backlog with all three (and basic TDMA as an upper bound). As Fig. 15 clearly shows, QZMAC indeed provides the stochastically smallest sum queue lengths, followed by EZMAC (owing to its superior contention mechanism) and Ô¨Ånally ZMAC. TDMA, as expected, performs the worst. With QZMAC, the CDF hits 1 at 12 packets, while its closest competitor, EZMAC‚Äôs CDF has a support that extends until 69 packets and that of ZMAC extends to 220 packets.

27

CDF

Symmetric system with 30 queues (Œª = 0.032) 1

0.9

0.8

0.7

ZMAC

0.6

EZMAC

0.5

QZMAC

TDMA

0.4

0.3

0.2

0.1

0

0

50

100

150

200

250

Queue Length

Figure 15: The CDFs of total system backlog with QZMAC, EZMAC, ZMAC and TDMA.

9.4 Channel Utilization

Recall from our earlier discussion (see Prop. 1) that the optimal scheduling policy under the information structure assumed in this paper lies in the class of non-idling, exhaustive policies. Consequently, the more eÔ¨Éciently a MAC algorithm Ô¨Ånds non empty queues in the network (assuming there are packets in the network), the better its mean delay performance is likely to be. In the literature, this probability of a non empty queue being served when one exists in the network is termed Channel Utilization, (ùúÅ) and is a performance metric commonly used to compare the eÔ¨Éciency of MAC algorithms [RWA+08,WR05]. Formally, given a scheduling policy ùúã,

ùëÅ

ùëÅ

‚àëÔ∏Å

‚àëÔ∏Å

ùúÅ ùúã (Q(0))

:=

lim

ùúã
PQ ( 0)

I{ùëÑùëó (ùë°)>0} ùê∑ ùëó (ùë°) > 0 ùëÑ ùëó (ùë°) > 0

ùë° ‚Üí‚àû

ùëó =1

ùëó =1

(‚àó) ùë°ùë°‚àí=01 ùëÅùëó=1 I{ùëÑ ùëó (ùë°)>0} ùê∑ ùëó (ùë°) > 0

= lim
ùë° ‚Üí‚àû

ùë° ‚àí1
I

, >0

ùë° =0

{

ùëÅ ùëó=1

ùëÑ

ùëó

(ùë°

)

>0

}

where the (‚àó) is under the assumption that the queue length process is ergodic. We used the setup described

in Sec. 8, to compare the channel utilization of QZMAC with that of ZMAC. Tthe network comprised 7

collocated nodes transmitting to a base station. Packet arrivals to the nodes followed IID Bernoulli processes

with rates ùùÄ = [0.17, 0.20, 0.04, 0.17, 0.17, 0.02, 0.07]. This rate vector is clearly within the network capacity

region, because

7
ùëñ=1 ùúÜùëñ

= 0.84 < 1.

The results of the experiment are shown in Table. 1.

The experiment

was repeated for diÔ¨Äerent values of control overhead, i.e., the portion of the time slot wasted in scheduling

a queue (ùëáùëù + ùëáùëê). The value of ùëáùëù was kept constant, ùëáùëù = 1 for ZMAC and ùëáùëù = 3 for QZMAC, and the

number of contention minislots was varied.

One obvious trend is that channel utilization increases as control overhead increases, since it becomes easier to resolve contention whenever it occurs with more ùëáùëê minislots. However, the other point to note is that regardless of contention overhead, QZMAC outperforms ZMAC. This is due to the fact that both the polling and the contention mechanisms of the former are designed better than the latter to Ô¨Ånd non empty queues with greater probability.

28

Algorithm
ZMAC (ùëáùëù = 1) QZMAC (ùëáùëù = 3)

ùëáùëù + ùëáùëê = 7
0.88968 0.96312

ùëáùëù + ùëáùëê = 8
0.90379 0.9706

ùëáùëù + ùëáùëê = 9
0.91356 0.97486

Table 1: Comparing the channel utilization of QZMAC with that of ZMAC with varying control overhead (ùëáùëù + ùëáùëê). Clearly,

ùëÑùëç ùëÄ ùê¥ùê∂
ùúÅ

>

ùúÅ ùëç ùëÄ ùê¥ùê∂ ,

showing

that

the

former

wastes

the

channel

less

often,

thereby

clearing

the

network

of

packets

more

eÔ¨Éciently.

10 Conclusion and Future work

Our objective has been to develop distributed MAC protocols, which require minimal information sharing, for data collection from resource-challenged wireless sensors. In this paper, we Ô¨Årst extended some results from optimal polling to systems with limited information structures and proved the delay-optimality of exhaustive service and cyclic polling in a symmetric version of our limited information scheduling problem. Leveraging these results, we proposed two distributed protocols EZMAC and QZMAC that perform much better than those available in the literature, both with respect to mean delay and system backlog distributions. We then extended this analysis to design hybrid MACs for systems with unequal arrival rates as well. Further, we showed that delay optimality comes at the price of excessive short-term unfairness and proposed modiÔ¨Åcations to QZMAC to reduce unfairness. We then implemented QZMAC on a test bed comprising telosB motes and demonstrated the operation of several salient aspects of the protocol. In the process, we also obtained a clear understanding of the CCA performance of the motes which, in turn, allowed us to extend QZMAC to handle situations with unequal arrival rates, CCA errors and alarm traÔ¨Éc. Extensions to this work will look at handling Markovian arrivals and state dependent fading. This paper handled fully-connected interference graphs. In the future, we will also be investigating how to modify QZMAC to solve the hidden node problem. Furthermore, our future study will include extending the theory we have developed in the present article to propose similar low-delay decentralized scheduling algorithms for more general interference graphs. Scheduling with energy harvesting nodes wherein the nodes are ‚Äúawake‚Äù only for certain periods and ‚Äúasleep‚Äù otherwise is an important area for IoT applications.

References

[AAKD08]

Imtiaz Ahmad, Buthaina Al-Kazemi, and A Shoba Das. An eÔ¨Écient algorithm to Ô¨Ånd broadcast schedule in ad hoc tdma networks. Journal of Computer Systems, Networks, and Communications, 2008:12, 2008.

[AHM+06]

Gahng-Seop Ahn, Se Gi Hong, Emiliano Miluzzo, Andrew T Campbell, and Francesca Cuomo. Funneling-MAC: a localized, sink-oriented MAC for boosting Ô¨Ådelity in sensor networks. In Proceedings of the 4th international conference on Embedded networked sensor systems, pages 293‚Äì306. ACM, 2006.

[AKL92]

Eitan Altman, Panagiotis Konstantopoulos, and Zhen Liu. Stability, monotonicity and invariant quantities in general polling systems. Queueing Systems, 11(1-2):35‚Äì57, 1992.

[Ber95]

Dimitri P Bertsekas. Dynamic Programming and Optimal Control. Number 2. Athena ScientiÔ¨Åc Belmont, MA, 1995.

[BK93]

Herwig Bruneel and Byung G. Kim. Discrete-time Models for Communication Systems including ATM. Kluwer Academic Publishers, 1993.

29

[CWPW15] Tengfei Chang, Thomas Watteyne, Kris Pister, and Qin Wang. Adaptive synchronization in multi-hop tsch networks. Computer Networks, 76:165‚Äì176, 2015.

[DGV04]

A. Dunkels, B. Gronvall, and T. Voigt. Contiki - a lightweight and Ô¨Çexible operating system for tiny networked sensors. In 29th Annual IEEE International Conference on Local Computer Networks, pages 455‚Äì462, Nov 2004.

[DNF+05]

Christian Doerr, Michael Neufeld, JeÔ¨Ä FiÔ¨Åeld, Troy Weingart, Douglas C Sicker, and Dirk Grunwald. MultiMAC-an adaptive MAC framework for dynamic radio networking. In New Frontiers in Dynamic Spectrum Access Networks, 2005. DySPAN 2005. 2005 First IEEE International Symposium on, pages 548‚Äì555. IEEE, 2005.

[DWVT14] Diego Dujovne, Thomas Watteyne, Xavier Vilajosana, and Pascal Thubert. 6tisch: deterministic ip-enabled industrial internet (of things). IEEE Communications Magazine, 52(12):36‚Äì41, 2014.

[EM+82]

Anthony Ephremides, Osama MowaÔ¨Å, et al. Analysis of a hybrid access scheme for buÔ¨Äered users-probabilistic time division. Software Engineering, IEEE Transactions on, (1):52‚Äì61, 1982.

[FL96]

Serguei Foss and Gu¬®nter Last. Stability of polling systems with exhaustive service policies and state-dependent routing. The Annals of Applied Probability, 6(1):116‚Äì137, 1996.

[FMM95]

G Fayolle, V.A. Malyshev, and M.V. Menshikov. Topics in the Constructive Theory of Countable Markov Chains. 1995.

[GRC+14]

Luigi Alfredo Grieco, Alessandro Rizzo, Simona Colucci, Sabrina Sicari, Giuseppe Piro, Donato Di Paola, and Gennaro Boggia. Iot-aided robotics applications: Technological implications, target domains and open issues. Computer Communications, 54:32‚Äì47, 2014.

[HK83]

M Hofri and A Konheim. The Analysis of a Finite Quasi-Symmetric ALOHA Network with Reservation. Technion-Israel Institute of Technology. Department of Computer Science, 1983.

[HL89]

On¬¥esimo Hern¬¥andez-Lerma. Adaptive Control of Markov Processes. Springer Verlag New York, NY, 1989.

[HR87]

Micha Hofri and Zvi Rosberg. Packet delay under the golden ratio weighted tdm policy in a multiple-access channel. IEEE Transactions on Information Theory, 33(3):341‚Äì349, 1987.

[iee16]

IEEE standard for low-rate wireless networks. IEEE Std 802.15.4-2015 (Revision of IEEE Std 802.15.4-2011), pages 1‚Äì709, 2016.

[JCH84]

Raj Jain, Dah-Ming Chiu, and William R Hawe. A quantitative measure of fairness and discrimination for resource allocation in shared computer system, volume 38. Eastern Research Laboratory, Digital Equipment Corporation Hudson, MA, 1984.

[JW11]

Libin Jiang and Jean Walrand. Approaching throughput-optimality in distributed csma scheduling algorithms with collisions. Networking, IEEE/ACM Transactions on, 19(3):816‚Äì829, 2011.

[JW12]

Libin Jiang and Jean Walrand. Stability and delay of distributed scheduling algorithms for networks of conÔ¨Çicting queues. Queueing Systems, 72(1-2):161‚Äì187, 2012.

[Kin01]

Pat Kinney. The 802.15.4 CCA method. Project: IEEE P802.15 Working Group for Wireless Personal Area Networks (WPANs), Submitted: Nov 14, 2001.

[Le84]

Simon S Lam (editor). Principles of Communication and Networking Protocols. IEEE Computer Society Press, 1984.

30

[LNT92]

Zhen Liu, Philippe Nain, and Don Towsley. On optimal polling policies. Queueing Systems, 11(1-2):59‚Äì83, 1992.

[LRZ03]

Juan Liu, James Reich, and Feng Zhao. Collaborative in-network processing for target tracking. EURASIP Journal on Advances in Signal Processing, 2003(4):616720, 2003.

[Mat19]

Kayla Matthews. The internet of robotic things: How iot and robotics tech are evolving together. 2019.

[ODE+06]

F. Osterlind, A. Dunkels, J. Eriksson, N. Finne, and T. Voigt. Cross-level sensor network simulation with cooja. In Proceedings. 2006 31st IEEE Conference on Local Computer Networks, pages 641‚Äì648, 2006.

[RSS09]

Shreevatsa Rajagopalan, Devavrat Shah, and Jinwoo Shin. Network adiabatic theorem: an eÔ¨Écient randomized protocol for contention resolution. In ACM SIGMETRICS Performance Evaluation Review, volume 37, pages 133‚Äì144. ACM, 2009.

[RWA+08]

Injong Rhee, Ajit Warrier, Mahesh Aia, Jeongki Min, and Mihail L Sichitiu. Z-MAC: a hybrid MAC for wireless sensor networks. IEEE/ACM Transactions on Networking (TON), 16(3):511‚Äì 524, 2008.

[RWMX06] Injong Rhee, Ajit Warrier, Jeongki Min, and Lisong Xu. DRAND: Distributed randomized TDMA scheduling for wireless ad-hoc networks. In Proceedings of the 7th ACM international symposium on Mobile ad hoc networking and computing, pages 190‚Äì201. ACM, 2006.

[Sen89]

Linn I Sennott. Average cost optimal stationary policies in inÔ¨Ånite state markov decision processes with unbounded costs. Operations Research, 37(4):626‚Äì633, 1989.

[SSB10]

Lanny Sitanayah, Cormac J Sreenan, and Kenneth N Brown. ER-MAC: A hybrid MAC protocol for emergency response wireless sensor networks. In Sensor Technologies and Applications (SENSORCOMM), 2010 Fourth International Conference on, pages 244‚Äì249. IEEE, 2010.

[Tak88]

Hideaki Takagi. Queuing analysis of polling models. ACM Computing Surveys (CSUR), 20(1):5‚Äì 28, 1988.

[TE93]

Leandros Tassiulas and Anthony Ephremides. Dynamic server allocation to parallel queues with randomly varying connectivity. Information Theory, IEEE Transactions on, 39(2):466‚Äì 478, 1993.

[TE92]

Leandros Tassiulas and Anthony Ephremides. Stability properties of constrained queueing systems and scheduling policies for maximum throughput in multihop radio networks. Auto. Ctrl., IEEE Trans. on, ‚Äô92.

[TK85]

H. Takagi and L. Kleinrock. A tutorial on the analysis of polling systems. Technical Report UCLA Report No. 850005, Computer Science Department, UCLA, February 1985.

[TPE15]

Pascal Thubert, Maria Rita Palattella, and Thomas Engel. 6TiSCH centralized scheduling: when SDN meets IoT. In Proc. of IEEE Conf. on Standards for Communications and Networking (CSCN, 2015), 2015.

[W+12]

Tim Winter et al. Rpl: Ipv6 routing protocol for low-power and lossy networks. RFC, 6550:1‚Äì 157, 2012.

[WR05]

Ajit Warrier and Injong Rhee. Stochastic analysis of wireless sensor network MAC protocols. North Carolina State Univ., Comput. Sci. Dept.,, ‚Äô05.

31

[YG02] [YHE02] [YSB+21] [ZWX17]

Yong Yao and Johannes Gehrke. The cougar approach to in-network query processing in sensor networks. ACM Sigmod record, 31(3):9‚Äì18, 2002.
Wei Ye, John Heidemann, and Deborah Estrin. An energy-eÔ¨Écient mac protocol for wireless sensor networks. In INFOCOM 2002. Twenty-Ô¨Årst annual joint conference of the IEEE computer and communications societies. Proceedings. IEEE, volume 3, pages 1567‚Äì1576. IEEE, 2002.
Roy D Yates, Yin Sun, D Richard Brown, Sanjit K Kaul, Eytan Modiano, and Sennur Ulukus. Age of information: An introduction and survey. IEEE Journal on Selected Areas in Communications, 39(5), 2021.
Ray Y Zhong, Lihui Wang, and Xun Xu. An iot-enabled real-time machine status monitoring approach for cloud manufacturing. Procedia CIRP, 63:709‚Äì714, 2017.

Avinash Mohan (S.M. ‚Äô16, M ‚Äô17) obtained his Master‚Äôs degree from the Indian Institute of Technology (IIT) Madras, and his PhD from and the Indian Institute of Science (IISc) Bangalore. He is currently a postdoctoral fellow at the Technion, Israel Institute of Technology, Haifa, Israel. His research interests include stochastic control, reinforcement learning, analysis of deregulated energy markets and resource allocation in wireless communication networks.
Arpan Chattopadhyay obtained his B.E. in Electronics and Telecommunication Engineering from Jadavpur University, India in the year 2008, and M.E. and Ph.D in Telecommunication Engineering from Indian Institute of Science, Bangalore, India in the year 2010 and 2015, respectively. He was a postdoctoral researcher in the Electrical Engineering department and is currently an assistant professor at the Indian Institute of Technology, Delhi, India. His research interests include design, resource allocation, control and learning in wireless networks and cyber-physical systems.
Shivam Vinayak Vatsa (B Tech. ‚Äô16) obtained Bachelor of Technology from NIIT University, India in Computer Science. He is currently a Software Engineer in Common Algorithm Development Group at ABB India. His research interests include Internet of Things, Cyber Physical Systems and Data analysis of wireless communication networks.
Anurag Kumar (Fellow IEEE) (B.Tech., Indian Institute of Technology (IIT) Kanpur; PhD, Cornell University, both in Electrical Engineering) was with Bell Labs, Holmdel, N.J., for over 6 years. Since then he has been on the faculty of the ECE Department at the Indian Institute of Science (IISc), Bangalore; he is at present the Director of the Institute. His area of research is communication networking, and he has recently focused primarily on wireless networking. He is a Fellow of the IEEE, the Indian National Science Academy (INSA), the Indian National Academy of Engineering (INAE), and the Indian Academy of Sciences (IASc). He was an associate editor of IEEE Transactions on Networking, and of IEEE Communications Surveys and Tutorials.

32

11 Appendices
11.1 Glossary of Notation and Acronyms
1. ùê¥ ùëó (ùë°): number of packets arriving to Queue ùëó in time slot ùë°. 2. ùêµ(ùëâùëó ): If ùê¥ is a generic Bernoulli(ùúÜ) random variable, and ùê∂ is distributed Binomial(ùëâùëó , ùúÜ), then ùêµ(ùëâùëó )
is a random variable whose distribution is the same as that of (ùê∂ ‚àí 1)+ + ùê¥. 3. CCA: Clear Channel Assessment. 4. ùê∑ ùëó (ùë°): the number of departures from Queue ùëó in time slot ùë°. 5. ùêªùë°ùúã: the history of policy ùúã up to time ùë° as deÔ¨Åned in (3). 6. Q(ùë°): backlog of Queue ùëó at the beginning of time slot ùë°. 7. ùëÑ ùúã (ùë°): backlog of Queue ùëó at the beginning of time slot ùë° under scheduling policy ùúã.
ùëó
8. ùêæùë°‚Ñéùëü : the threshold that triggers the RESET subroutine. It is denoted by THRSLD in the subroutine description.
9. ùùÄ: the arrival rate vector. 10. ùö≤: the capacity region of the queueing network. 11. ùö≤ùêøùê∏ùëÑ: the set of arrival rates that the LEQ policy can stabilize. 12. [ùëÅ]: the set of integers {1, 2, ¬∑ ¬∑ ¬∑ , ùëÅ }. 13. NDST: is short for ‚ÄúNode State.‚Äù Attains values COLL (meaning ‚Äúin collision‚Äù) or NOCOLL (meaning
‚Äúnot in collision‚Äù). 14. PU: Primary User. 15. Œ†: the space of all admissible policies. 16. Œ†ùëí: the subset of all exhaustive service policies. 17. Œ†ùëî: the subset of all non-idling service policies. 18. RSTBCN: Reset Beacon. 19. SU: Secondary User. In ZMAC this refers to any queue which is not the current PU. In EZMAC and
QZMAC, this refers to the queue that won the latest contention. 20. ùëáùëê: number of minislots reserved for contention. 21. ùëáùëù: number of minislots reserved for polling. 22. ùëâ ùúã (ùë°): is the number of slots prior to slot ùë° in which Queue ùëó was allowed to transmit under a generic
ùëó
scheduling policy ùúã.
33

Q1=1, but Q2=0

Q3>0

Q4=1

Q1=1

Q6>0

Idle Slot

Service

Service

n*: œÄ decides to switch

Q1=1

Q2=0

Q3>0

Service

Service

QŒ≥ = QœÄ

m*

Q4=1

Q6>0

Service

Idle Slot

Service

Service

Service

Figure 16: A sample path illustrating how ùõæ is derived from ùúã.

11.2 Proof of Prop. 1

This proof proceeds along the lines of the proof in [LNT92, Prop. 4.2]. It is easy to show that we can restrict
attention to non-idling policies and so, we begin our proof with some policy ùúã ‚àà Œ†ùëî, where, as mentioned
in Sec. 4.1, Œ†ùëî is the set of all non-idling policies. Consider a sample path ùúî ( a realization of the input sequences { ùê¥ùëñ (ùëõ)}‚àûùëõ=1 , ùëñ ‚àà ùêº and on that path, let

ùëõ‚àó := inf

ùëõ

‚â•

1

:

ùúã
ùëÑùëû

(ùëõ)

> 0,

ùëÑ ùúãùëû (ùëõ)

= 0,

and

ùëé
ùúã

=2

.

(15)

ùúãùëõ‚àí1

ùúãùëõ

ùëõ

This is the Ô¨Årst instant when a time slot is wasted by ùúã on account of switching to an empty queue though the previous one was non-empty. Further deÔ¨Åne

ùëö‚àó = inf ùëõ > ùëõ‚àó : ùëÑ ùúãùúãùëõùëû‚àí1 (ùëõ) > 0, ùúãùëõùëû‚àí1 = ùúãùëõùëû‚àó , and ùúãùëõùëé = 1 .

(16)

This is the Ô¨Årst time since ùëõ‚àó that the server continues to serve the (same) incumbent Ô¨Ånding it to be non-empty. Construct another policy ùõæ as follows (refer to Fig.16 for an illustration).

‚Ä¢ On [1, ùëõ‚àó) and [ùëö‚àó + 1, ‚àû), (ùõæùëé, ùõæùëû) = (ùúãùëé, ùúãùëû).

ùëòùëò

ùëòùëò

‚Ä¢

(ùõæùëé‚àó ,
ùëõ

ùõæùëû‚àó )
ùëõ

=

(1,

ùúãùëû(ùëõ‚àó‚àí1) ),

and

‚Ä¢

for

ùëõ‚àó + 1 ‚â§

ùëò

‚â§ ùëö‚àó,

(ùõæùëé, ùõæùëû)
ùëòùëò

=

(

ùúã

ùëé ùëò ‚àí1

,

ùúã

ùëû ùëò ‚àí1

)

.

So, ùõæ follows ùúã over [1, ùëõ‚àó) and [ùëö‚àó + 1, ‚àû) and at ùëõ‚àó, ùõæ deviates from ùúã and serves the incumbent (possible, since that queue is non-empty). Between ùëõ‚àó + 1 and ùëö‚àó, ùõæ follows ùúã albeit with one slot delay, i.e., it does whatever ùúã did one slot ago. Clearly,
ùëÑùõæ (ùë°) = ùëÑ ùúã (ùë°), ‚àÄ ùë° ‚àà [1, ùëõ‚àó) ‚à™ [ùëö‚àó + 1, ‚àû), and ùëÑùõæ (ùë°) ‚â§ ùëÑ ùúã (ùë°), ‚àÄ ùë° ‚àà [ùëõ‚àó + 1, ‚â§ ùëö‚àó],

34

whenever ùëö‚àó < ‚àû. This relation is true for every sample path ùúî. ùëö‚àó is set equal to ‚àû whenever either ùëõ‚àó = ‚àû, or, ùõæ is able to serve a packet in some slot ùëô (‚â• ùëõ‚àó + 1) while ùúã could not serve any packet in slot
ùëô ‚àí 1.

To explain the latter case further, observe that after ùëõ‚àó, ùõæ does whatever ùúã did one slot ago. If ùúã switched

to

some

empty

queue

in

ùëô ‚àí 1,

ùõæ

switches

to

the

same

queue

in

ùëô.

But

if

ùëû
ùúãùëô‚àí1

received

a

packet

in

ùëô ‚àí 1,

ùõæ

will

be able to serve that packet increasing ùëÑ ùúã (ùë°) ‚àí ùëÑ ùúâ (ùë°) to 2 (one at ùëõ‚àó and the second at ùëô). Since ùõæ follows ùúã

with exactly one step delay, ùúã will never be able to make up the diÔ¨Äerence! Hence, ùëö‚àó = ‚àû.

To complete the proof, one needs to consider epochs ùëô‚àó such as:

ùëô‚àó

:=

inf {ùëõ

‚â•

1

:

ùúã
ùëÑùëû

(ùëõ)

>

0,

ùúã
ùëÑùëû

(ùëõ)

>

0,

ùúãùëõ‚àí1

ùúãùëõ

and ùúãùëõùëé = 2}, (17)

wherein the queue which ùúã decides to serve, unlike the case with ùëõ‚àó, is non-empty and hence, slot ùëô‚àó is not wasted. Even in this case deÔ¨Åning ùõæ as before produces a policy that does no worse than ùúã in terms of total system backlog.
In the same manner, Ô¨Ånd such an ùëõ‚àó (or ùëô‚àó as the case may be) for ùõæ and reÔ¨Åne this policy using the procedure described. Iterating this procedure, one ends up with a policy say ùúâ, for which such an instant never exists, i.e., which never switches to a diÔ¨Äerent queue when the incumbent is nonempty. This is by deÔ¨Ånition exhaustive. We have, thus, deÔ¨Åned both queueing processes on some common probability space (Œ©, F , P) and for every ùúî ‚àà Œ©, we have shown that

ùëÑ ùúâ (ùë°, ùúî) ‚â§ ùëÑ ùúã (ùë°, ùúî), ‚àÄ ùë° ‚â• 1,

which means that ‚àÄùë• ‚àà R,

P{ùúî

:

ùëÑùúã (ùë°,

ùúî)

>

ùë•}

‚â•

P{ùúî

:

ùúâ
ùëÑ

(ùë°,

ùúî)

>

ùë•}.

(18)

This coupling argument shows that

ùë†ùë°

ùëÑ ùúâ (ùë°) ‚â§ ùëÑ ùúã (ùë°), ‚àÄ ùë° ‚â• 1.

(19)

11.3 Proof of Prop. 2

To prove this we invoke Theorem (3.1) in [FL96] that proves the stability of certain exhaustive service policies with state dependent routing. We Ô¨Årst require some more notation.

We denote by ùëÜ(ùë°) the queue in service during slot ùë°, and set ùëÜ(ùë°) = 0 if the server is idling at some queue

(which from Prop. 1, has to be empty) during some slot. We denote by ùëäùëõ, the time taken by the server

to

begin

the

ùë°‚Ñé
ùëõ

service.

By this we mean the time taken by the server to Ô¨Ånd a non empty queue after

serving some queue. So, if the incumbent is non empty, ùëäùëõ = 0 since the server simply begins serving the

next packet in the queue served in the previous slot without switching away from it. Otherwise the server

begins to search for a non empty queue to begin a busy period. SpeciÔ¨Åcally, if ùëÑùëÜ(0) (0) = 0, then ùëä1 is the

time taken to Ô¨Ånd a non empty queue. During this period, the server may have visited several empty queues.

Assume the underlying probability space is denoted by (Œ©, F , ùëÉ) and let

Fùëõ := ùúé [ùëÑ1 (ùë°), ¬∑ ¬∑ ¬∑ , ùëÑ ùëÅ (ùë°), ùëÜ(ùë°)] , ùë° ‚â§ ùëõ , ùëõ ‚â• 0,

35

be the Ô¨Åltration describing the history of the system. Let ùê¥ùëñ [ùë°] be the number of arrivals to queue ùëñ until and

including time ùë°, and ùê¥[ùë°] =

ùëÅ ùëñ=1

ùê¥ùëñ

[ùë°],

the

total

number

of

arrivals

to

the

system

over

the

same

duration.

The proof of Theorem (3.1) in [FL96] relies on two assumptions7 that we show are satisÔ¨Åed in our case. Firstly, that there exists ùë§ > 0 such that

E [ùëä1|F0] < ùë§, ùëÉ ‚àí ùëé.ùë†. on ùëÑùëÜ(0) = 0 ,

(20)

and secondly that there exists some ùëù > 0 such that

ùëÅ

‚àëÔ∏Å

ùëÉ ( ùê¥(ùëä1) = 0|F0) > ùëù, ùëÉ ‚àí ùëé.ùë†. on ùëÑùëÜ(0) = 0, ùëãùëñ (0) > 0 .

(21)

ùëñ=1

In other words, (20) means that if the system starts out empty, the time taken to Ô¨Ånd a non empty queue under the policy being considered, should have a Ô¨Ånite mean. (21), on the other hand, refers to the fact that when the system starts oÔ¨Ä non empty and the server is at an empty queue at time 0, the probability of 0 arrivals in ùëä1 is positive.
First note that on {ùëÑùëÜ(0) = 0}, ùëä1 ‚â• 1, and let ùúÜùëöùëñùëõ = min1‚â§ùëñ‚â§ùëÅ ùúÜùëñ be the smallest arrival rate which, by assumption is strictly positive. The Ô¨Årst assumption is satisÔ¨Åed, since

‚àû

‚àëÔ∏Å

E [ùëä1|F0] =

ùëÉ{ùëä1 ‚â• ùëò |F0}

ùëò =1

(‚àóùëé)

‚àû
‚àëÔ∏Å

‚â§

(1 ‚àí ùúÜùëÜ(ùëò))ùëò

ùëò =1

‚àû

‚àëÔ∏Å

‚â§

(1 ‚àí ùúÜùëöùëñùëõ)ùëò

ùëò =1

1

=

‚àí 1 < ‚àû.

ùúÜùëöùëñùëõ

Inequality (‚àóùëé) is true, since, for the walking time to be at least ùëò, the ùëòùë°‚Ñé polled queue, i.e., ùëÜ(ùëò), must be empty. Since on {ùëÑùëÜ(0) = 0} the system also starts oÔ¨Ä empty, this probability is (1 ‚àí ùúÜùëÜ(ùëò) )ùëò . To prove (21), Ô¨Årst deÔ¨Åne ùëùùëò = ùëÉ{ùëä1 = ùëò |F0}.

‚àû

‚àëÔ∏Å

ùëÉ{ ùê¥(ùëä1)|F0} =

ùëÉ{ ùê¥(ùëò) = 0|F0, ùëä1 = ùëò }ùëÉ{ùëä1 = ùëò |F0}

ùëò =1

‚àû

‚àëÔ∏Å

=

ùëÉ{ ùê¥(ùëò) = 0|F0, ùëä1 = ùëò } ùëùùëò .

ùëò =1

‚àûùëÅ

‚àëÔ∏Å ‚àëÔ∏Å

=

(1 ‚àí ùúÜùëñ)ùëò ùëùùëò.

ùëò=1 ùëñ=1

But on {ùëãùëÜ(0) = 0}, ùëù1 > (1 ‚àí ùúÜùëöùëñùëõ) ùëé.ùë†. So,

ùëÅ
‚àëÔ∏Å ùëÉ{ ùê¥(ùëä1)|F0} = ùëù1 (1 ‚àí ùúÜùëñ)
ùëñ=1
7Eqn. (2.3) and Eqn. (2.4) in [FL96].

36

‚àûùëÅ

‚àëÔ∏Å ‚àëÔ∏Å

+

(1 ‚àí ùúÜùëñ)ùëò ùëùùëò

ùëò=2 ùëñ=1

ùëÅ
‚àëÔ∏Å ‚â• (1 ‚àí ùúÜùëñ) > 0.
ùëñ=1

With both (20) and (21) satisÔ¨Åed, we note that Theorem (3.1) in [FL96] is proved under a much more general model, where the behavior of the system is inÔ¨Çuenced by another process ùëà (ùë°), ùë° ‚â• 0, that takes values in some measurable space (U, U). Setting U = NùëÅ and ùëà (ùë°) = ùëâ (ùë°), the proof is complete.

11.4 LEQ in Symmetric Systems
Under symmetry (Eqn. (7)), ùëéùëüùëî ùëöùëéùë•1‚â§ùëñ‚â§ùëÅ ùúÜùëñùëâùëñ (ùë°) = ùëéùëüùëî ùëöùëéùë•1‚â§ùëñ‚â§ùëÅ ùëâùëñ (ùë°) and the policy reduces to a cyclic exhaustive service policy, as can be seen from the following example. Consider the scenario with 4 queues in the system and suppose that at the beginning of Queue 1's service, V = [0, ùë£2, ùë£3, ùë£4], with ùë£2 > ùë£3 > ùë£4. At the end of Queue 1's service, the vector changes to V = [0, ùë£2, ùë£3, ùë£4], but the ordering is still preserved, i.e., ùë£2 > ùë£3 > ùë£4 > ùë£1 = 0. Hence, Queue 2 is chosen for service next. But at the end of queue 2's service, once again, we see that ùë£3 > ùë£4 > ùë£1 , as it was at the beginning of Queue 2's service, and Queue 3 is chosen, after which queue 4 is chosen followed by queue 1 and this process repeats. We see that under symmetry, LEQ induces a cyclic service system. This policy is discussed in detail in Sec. 4.5. where we will, in fact, show it to be mean delay optimal in symmetric systems. This also helps bolster our conÔ¨Ådence in the LEQ policy itself. We now explore in greater detail the behavior of the LEQ policy in symmetric systems.

11.5 Proof of Thm. 3

In this section, we return to the system discussed Sec.2, i.e., one that is not necessarily symmetric8. The analysis proceeds along the lines of the proof of the theorem in [AKL92]. We will be looking at the system‚Äôs state only at the epochs at which the server begins its visit to a queue.

With a slight abuse of notation, we deÔ¨Åne this system‚Äôs state is by s(ùëõ) = [Q(ùëõ), ùêº (ùëõ)]ùëá , where, Q(ùëõ) =

[ùëÑ1 (ùëõ),

ùëÑ2(ùëõ), . . . , ùëÑùëÅ (ùëõ)]ùëá

,ùëõ

‚â•

1

is

the

vector

of

queue

lengths

at

the

ùë°‚Ñé
ùëõ

switching

instant

(at

which

the

server visits the ùëõùë°‚Ñé queue), ùêº (ùëõ) is the identity of the ùëõùë°‚Ñé queue polled. Clearly, s(ùëõ) ‚àà NùëÅ √ó ùêº, and this

process is embedded at the instants at which the server arrives at a queue.

Further,

the

number

of

arrivals

to

queue

ùëò

in

ùë°

time-slots

is

denoted

by

ùê¥ùëò (ùë°)

and

the

length

of

the

ùë°‚Ñé
ùëõ

busy

period starting with ùëô packets by ùê∫ùëõ (ùëô). Also,

ùêº (ùëõ) + 1 if 1 ‚â§ ùëõ ‚â§ ùëÅ ‚àí 1

ùêº (ùëõ + 1) =

1

if ùëõ = ùëÅ.

Consequently, when

1. ùëó ‚â† ùêº (ùëõ)

Ô£±ùëÑ Ô£¥

ùëó

(ùëõ)

+

ùê¥

ùëó

ùê∫ùëõ

ùëÑùêº (ùëõ) (ùëõ)

,

Ô£¥

Ô£¥Ô£≤

ùëÑ ùëó (ùëõ + 1) = if ùëÑùêº (ùëõ) (ùëõ) ‚â• 1

Ô£¥ Ô£¥Ô£¥ùëÑ

ùëó

(ùëõ)

+

ùê¥ùëó

(1),

if

ùëÑùêº

(ùëõ)

(ùëõ)

=

0

Ô£≥

8Proving stability for this system obviously proves stability in the symmetric system.

37

2. ùëó = ùêº (ùëõ)

ùëÑ ùëó (ùëõ + 1) = ùê¥ ùëó (1).

The mean duration of a busy period, Eùêµ(ùêº (ùëõ)) of queue ùêº (ùëõ) beginning with one packet is found by observing that

Eùêµ(ùêº (ùëõ)) = 1 √ó ùúÜùêº (ùëõ) + {1 + Eùê∫ùëõ (ùëô)}{1 ‚àí ùúÜùêº (ùëõ) } .

‚áí Eùêµ(ùêº (ùëõ)) =

1 .

1 ‚àí ùúÜùêº (ùëõ)

Hence, since ùê∫ùëõ (ùëô) begins with ùëô packets instead of one,

Eùê∫ùëõ (ùëô) = ùëô √ó 1 √ó ùúÜùêº (ùëõ) + {1 + Eùê∫ùëõ (ùëô)}{1 ‚àí ùúÜùêº (ùëõ) }

ùëô =
1 ‚àí ùúÜùêº (ùëõ)

ùúÜùëó ‚áí Eùê¥ ùëó (ùê∫ùëõ (ùëô)) = 1 ‚àí ùúÜùêº (ùëõ) ùëô ‚àÄ ùëó ‚â† ùêº (ùëõ)

‚àëÔ∏Å

ùúå ‚àí ùúÜùêº (ùëõ)

‚áí E ùê¥ ùëó (ùê∫ùëõ (ùëô)) = 1 ‚àí ùúÜùêº (ùëõ) ùëô. (22)

ùëó‚â†ùêº (ùëõ)

We will now show that ùúå =

ùëÅ
ùëñ=1 ùúÜùëñ

< 1 is a suÔ¨Écient condition for stability.

Clearly, {Qùëõ, ùëõ ‚â• 1}, is an

irreducible DTMC. However, it is not time homogeneous since, as (22) shows, the transition probabilities

depend on the queue being served, i.e., on ùêº (ùëõ). Hence, as deÔ¨Åned in [AKL92], the system is said to be stable

if the ùëÅ irreducible, homogeneous DTMCs {[Q(ùëõùëÅ + ùëò), ùëò] , ùëõ ‚â• 1, 1 ‚â§ ùëò ‚â§ ùëÅ, ùëñ ‚àà {1, 2}} are all ergodic.

Now, from the deÔ¨Ånition of ùëÑ ùëó (ùëõ + 1), we see that

Ô£ÆùëÅ

Ô£π

ùëÅ

Ô£Ø‚àëÔ∏Å

Ô£∫

‚àëÔ∏Å

E Ô£Ø ùëÑ ùëó (ùëõ + 1)|Q(ùëõ)Ô£∫ ‚â§

ùëÑ ùëó (ùëõ) + ùúå

Ô£Ø

Ô£∫

Ô£Ø ùëó=1

Ô£∫

ùëó =1

Ô£∞

Ô£ª

ùúå ‚àí ùúÜùêº (ùëõ) + 1 ‚àí ùúÜùêº (ùëõ) ùëÑùêº (ùëõ) (ùëõ) ‚àí ùëÑùêº (ùëõ) (ùëõ)

ùëÅ

‚àëÔ∏Å

=

ùëÑ ùëó (ùëõ) + ùúå ‚àí (1 ‚àí ùúå)‚Ñéùêº (ùëõ) ùëÑùêº (ùëõ) (ùëõ),

ùëó =1

1 where ‚Ñéùêº (ùëõ) = 1 ‚àí ùúÜùêº (ùëõ) ,

which means that

Ô£ÆùëÅ

Ô£π

Ô£Æ Ô£ÆùëÅ

Ô£π

Ô£π

Ô£Ø‚àëÔ∏Å

Ô£∫

Ô£Ø Ô£Ø‚àëÔ∏Å

Ô£∫

Ô£∫

E Ô£Ø ùëÑ ùëó (ùëõ + 2)|Q(ùëõ)Ô£∫ = E Ô£ØE Ô£Ø ùëÑ ùëó (ùëõ + 2) | Q(ùëõ + 1)Ô£∫ | Q(ùëõ)Ô£∫

Ô£Ø

Ô£∫

Ô£ØÔ£Ø

Ô£∫

Ô£∫

Ô£Ø ùëó=1

Ô£∫

Ô£Ø Ô£Ø ùëó=1

Ô£∫

Ô£∫

Ô£∞

Ô£ª

Ô£∞Ô£∞

Ô£ª

Ô£ª

ùëÅ
‚àëÔ∏Å ‚â§ E ùëÑ ùëó (ùëõ + 1) + ùúå

ùëó =1

‚àí(1 ‚àí ùúå)‚Ñéùêº (ùëõ+1) ùëÑùêº (ùëõ+1) (ùëõ + 1) | Q(ùëõ)

ùëÅ
‚àëÔ∏Å ‚â§ E ùëÑ ùëó (ùëõ + 1) | Q(ùëõ) + ùúå
ùëó =1

38

‚àí(1 ‚àí ùúå)‚Ñéùêº (ùëõ+1) ùëÑùêº (ùëõ+1) (ùëõ + 1)

ùëÅ

‚àëÔ∏Å

=

ùëÑ ùëó (ùëõ) + 2ùúå ‚àí (1 ‚àí ùúå) ‚Ñéùêº (ùëõ) ùëÑùêº (ùëõ) (ùëõ)

ùëó =1

+‚Ñéùêº (ùëõ+1) ùëÑùêº (ùëõ+1) (ùëõ) .

Proceeding similarly, we get

Ô£ÆùëÅ

Ô£π

ùëÅ

Ô£Ø‚àëÔ∏Å

Ô£∫

‚àëÔ∏Å

E Ô£Ø ùëÑ ùëó (ùëõ + 2ùëÅ) | Q(ùëõ)Ô£∫ ‚â§

ùëÑ ùëó (ùëõ) + 2ùëÅ ùúå

Ô£Ø

Ô£∫

Ô£Ø ùëó=1

Ô£∫

ùëó =1

Ô£∞

Ô£ª

2ùëÅ ‚àí1
‚àëÔ∏Å

‚àí(1 ‚àí ùúå)

‚Ñéùêº (ùëõ+ùëö) ùëÑùêº (ùëõ+ùëö) (ùëõ),

ùëö=0

Ô£ÆùëÅ

ùëÅ

Ô£π

Ô£Ø‚àëÔ∏Å

‚àëÔ∏Å

Ô£∫

‚áí E Ô£Ø ùëÑ ùëó (ùëõ + 2ùëÅ) ‚àí ùëÑ ùëó (ùëõ) | Q(ùëõ)Ô£∫ ‚â§ 2ùëÅ ùúå

Ô£Ø

Ô£∫

Ô£Ø ùëó=1

ùëó =1

Ô£∫

Ô£∞

Ô£ª

2ùëÅ ‚àí1
‚àëÔ∏Å

‚àí(1 ‚àí ùúå)

‚Ñéùêº (ùëõ+ùëö) ùëÑùêº (ùëõ+ùëö) (ùëõ).

(23)

ùëö=0

Clearly, the RHS of (23) is at most 2ùëÅ ùúå, and if for even one 1

‚â§

ùëò

‚â§

2ùëÅ

and ùúñ

>

0, ùëÑùêº (ùëõ+ùëò) (ùëõ)

>

(

1‚àíùúå)

ùëÅùúå ‚Ñé(ùêº

ùúñ (

ùëõ+

ùëò

)

)

,

then E

ùëÅ ùëó =1

ùëÑ

ùëó

(ùëõ

+

2ùëÅ)

‚àí

ùëÅ ùëó =1

ùëÑ ùëó (ùëõ)

|

Q(ùëõ)

< ‚àíùúñ. Hence, by the Foster-Lyapunov criterion ( [FMM95],

Thm. 2.2.3), we see that {[Q(ùëõùëÅ + ùëò), ùëò, ùëñ] , ùëõ ‚â• 1} is positive recurrent for every 1 ‚â§ ùëò ‚â§ ùëÅ, and ùëñ ‚àà {1, 2}. Being irreducible DTMCs as well, it is also ergodic.

11.6 Formulating the MDP

1. State Space: The state of the system at time ùëõ ‚â• 1 is the vector

ùë†(ùë°) = ùëÑùë¢ùëõ‚àí1 (ùëõ), V(ùëõ), r(ùëõ), ùë¢ùëõ‚àí1 . (24) So ùë†(ùëõ) ‚àà N √ó NùëÅ √ó NùëÅ ‚àí1 √ó ùêº.

2. Action Space: The action space A = ùêº for all states.

3. Initial distribution on the State Space: We assume that the system begins empty and so, the initial distribution ùê∑ is simply I{ùë†(0)}, where ùë†(0) = [ùëû, V(0), r(0), ùëñ0] , is given and hence, known.

4. History: Since the state is observable, the initial history is nothing but the initial state, which is

supplied as the initial information.

‚Ñé0 = ùë†(0).

(25)

At time ùë°, the history provides the complete picture of successive observations and control actions chosen so far; for ùëõ ‚â• 1:

‚Ñéùëõ = (ùë†(0), ùëé(0), . . . , ùë†(ùëõ ‚àí 1), ùëé(ùëõ ‚àí 1), ùë†(ùëõ)) ,

(26)

where the action taken at time ùëõ, ùëé(ùëõ) ‚àà I, ‚àÄùëõ ‚â• 0.

39

5. Policies: In general, a policy is a sequence of conditional distributions ùúâ = {ùúâùëõ} such that for each ùëõ, ùúâùëõ is a distribution on A given ‚Ñéùëõ. As mentioned before, we restrict attention to policies that serve any queue ùëó with ùëü ùëó (ùë°) > 0 Ô¨Årst and then return to serve the incumbent. As a consequence of Prop. 1, we also restrict to the case where if ùëû > 0 then we serve ùëñ again.

6. Transition Law: We denote the current action by ùë¢ùëõ and distinguish two cases: ‚Ä¢ ùëüùëñ (ùëõ) ‚â• 1 for some ùëñ ‚àà ùêº ‚àí ùë¢ùëõ‚àí1. Then,

ùëûùë¢ùëõ (ùë†(ùëõ), ùë†(ùëõ + 1)) = I{ùëü (ùëõ+1)=ùëü (ùëõ)‚àí1} √ó

ùëñ

ùëñ

Œ† ùëó‚â†ùëñ I{ùëüùëó (ùëõ+1)=ùëüùëó (ùëõ) }I{ùë¢ùë° =ùëñ } √ó

Œ†ùëòùëÅ=1Iùë¢ùëõ {ùëâùëò (ùëõ), ùëâùëò (ùëõ + 1)} √ó

Œ†ùëòùëÅ=1ùëûùë¢ùëõ (ùëÑùëò (ùëõ), ùëÑùëò (ùëõ + 1)) ,

(27)

where

Ô£±Ô£¥1 if ùëâùëò (ùëõ + 1) = ùëâùëò (ùëõ) + 1 and ùëò ‚â† ùë¢ùëõ, Ô£¥ Ô£¥Ô£≤ ùêºùë¢ùëõ {ùëâùëò (ùëõ), ùëâùëò (ùëõ + 1)} := 1 if ùëâùëò (ùëõ + 1) = ùëâùëò (ùëõ) = 0 and ùëò = ùë¢ùëõ, and
Ô£¥ Ô£¥Ô£¥0 otherwise, Ô£≥

and

Ô£±Ô£¥ùúÜ if ùëÑùëò (ùëõ + 1) = ùëÑùëò (ùëõ) + 1

Ô£¥

Ô£¥Ô£¥Ô£¥Ô£¥ OR, if ùëÑùëò (ùëõ + 1) = (ùëÑùëò (ùëõ) ‚àí 1)+ + 1

Ô£¥

Ô£¥

Ô£¥ Ô£¥ Ô£¥

and ùëò = ùëñ,

Ô£¥

Ô£¥Ô£≤

ùëûùë¢ (ùëÑùëò (ùëõ), ùëÑùëò (ùëõ + 1)) := 1 ‚àí ùúÜ if ùëÑùëò (ùëõ + 1) = ùëÑùëò (ùëõ) + 0

ùëõ

Ô£¥Ô£¥Ô£¥Ô£¥ OR, if ùëÑùëò (ùëõ + 1) = (ùëÑùëò (ùëõ) ‚àí 1)+ + 0

Ô£¥

Ô£¥

Ô£¥ Ô£¥

and ùëò = ùëñ,

Ô£¥

Ô£¥

Ô£¥Ô£¥Ô£¥0 otherwise,

Ô£≥

‚Ä¢ r(ùëõ) = 0. Then,

ùëûùë¢ùëõ (ùë†(ùëõ), ùë†(ùëõ + 1)) = Œ† ùëó ‚ààùêº I{ùëüùëó (ùëõ+1)=0} √ó Œ†ùëòùëÅ=1Iùë¢ùëõ {ùëâùëò (ùëõ), ùëâùëò (ùëõ + 1)} √ó Œ†ùëòùëÅ=1ùëûùë¢ùëõ (ùëÑùëò (ùëõ), ùëÑùëò (ùëõ + 1)) , (28)

where and

Ô£±Ô£¥1 if ùëâùëò (ùëõ + 1) = ùëâùëò (ùëõ) + 1 and ùëò ‚â† ùë¢ùëõ, Ô£¥ Ô£¥Ô£≤ ùêºùë¢ùëõ {ùëâùëò (ùëõ), ùëâùëò (ùëõ + 1)} := 1 if ùëâùëò (ùëõ + 1) = ùëâùëò (ùëõ) = 0 and ùëò = ùë¢ùëõ, and
Ô£¥ Ô£¥Ô£¥0 otherwise, Ô£≥

Ô£±Ô£¥ùúÜ if ùëÑùëò (ùëõ + 1) = ùëÑùëò (ùëõ) + 1 and ùëò ‚â† ùë¢ùëõ,

Ô£¥

Ô£¥Ô£¥Ô£¥Ô£¥ OR, if ùëÑùëò (ùëõ + 1) = (ùëÑùëò (ùëõ) ‚àí 1)+ + 1

Ô£¥

Ô£¥

Ô£¥ Ô£¥ Ô£¥

and ùëò = ùë¢ùëõ,

Ô£¥

Ô£¥Ô£≤

ùëûùë¢ (ùëÑùëò (ùëõ), ùëÑùëò (ùëõ + 1)) := 1 ‚àí ùúÜ if ùëÑùëò (ùëõ + 1) = ùëÑùëò (ùëõ) + 0 and ùëò ‚â† ùë¢ùëõ,

ùëõ

Ô£¥Ô£¥Ô£¥Ô£¥ OR, if ùëÑùëò (ùëõ + 1) = (ùëÑùëò (ùëõ) ‚àí 1)+ + 0

Ô£¥

Ô£¥

Ô£¥ Ô£¥

and ùëò = ùë¢ùëõ,

Ô£¥

Ô£¥

Ô£¥Ô£¥Ô£¥0 otherwise,

Ô£≥

40

7. Single Stage Cost: This gives the expected cost over the current step when the current state and action are known.

ùëÅ
‚àëÔ∏Å ùëê(ùë†(ùëõ), ùë¢ùëõ) = E ùëÑùëñ (ùëõ)|ùë†ùëõ

ùëñ=1

‚àëÔ∏Å

‚àëÔ∏Å

= ùëÑùë¢ùëõ‚àí1 (ùëõ) + ùúÜ ùëâùëó (ùëõ) + ùëÖùëñ (ùëõ), (29)

ùëó ‚â†ùë¢ùëõ‚àí1

ùëñ‚ààùêº

which is the expected sum of the current queue lengths conditioned on the current state.

Recall that the optimal cost (Eqn. (11)) is given by

‚àû

ùëÅ

ùêΩ‚àó (ùë†(0)) = ùëöùëñùëõ ùúâ Eùë†ùúâ(0) ‚àëÔ∏Å ùõºùëõE ‚àëÔ∏Å ùëÑùëñ (ùëõ)|ùë†ùëõ . (30)

ùëõ=0

ùëñ=1

It is to be noted that ùêΩ‚àó (ùë†(0)) on the R.H.S of (11) exists for every initial state ùë†(0). Since arrivals are IID

Bernoulli variables, the single stage cost can increase at most linearly with time, while the discount factor

ùõºùëõ decreases exponentially and dominates.

The Bellman Optimality equations [Ber95] associated with this MDP formulation are as follows (recall from Eqn. (12) that we denote ùêΩ‚àó (ùëû; V; r; ùëñ) by ùêΩ‚àó (ùëû; V; r)). When r = 0,
ùëñ
ùêΩùëñ‚àó (ùëû > 0; V; r = 0) = ùëû + ùúÜ ‚àëÔ∏Å ùëâùëò + ùõºEùêΩùëñ‚àó (ùëû ‚àí 1 + ùê¥;
ùëò ‚â†ùëñ
ùëâùëñ = 0, V‚àíùëñ + 1; r = 0) , ùêΩùëñ‚àó (ùëû = 0; V; r = 0) = ùúÜ ‚àëÔ∏Å ùëâùëò + ùõº min EùêΩ‚àóùëó ùêµ(ùëâùëó );
ùëó ‚â†ùëñ ùëò ‚â†ùëñ
ùëâùëó = 0, V‚àí ùëó + 1; r = 0 ,
where ùê¥ is a generic Bernoulli(ùúÜ) random variable, V‚àíùëñ = [ùëâ1, . . . , ùëâùëñ‚àí1, ùëâùëñ+1, . . . , ùëâùëÅ ] and 1 ‚àà R(ùëÅ ‚àí1) is the vector with 1‚Äôs at all coordinates. Finally, if random variable ùê∂ is distributed Binomial(ùëâùëó , ùúÜ), ùêµ(ùëâùëó ) is a random variable whose distribution is the same as that of (ùê∂ ‚àí 1)+ + ùê¥.

If ùëü ùëó ‚â• 1 for some ùëó ‚àà ùêº ‚àí {ùëñ}, the server Ô¨Årst serves the ùëó‚â†ùëñ ùëü ùëó packets and then returns to queue ùëñ. Let ùëÖÀú = ùëó‚â†ùëñ ùëü ùëó , ùêø‚àíùëñ = ùëó‚â†ùëñ ùëâùëó , and ùêøÀú‚àíùëñ = ùëÖùëòÀú=1 ùõº(ùëÖÀú‚àíùëò) (ùêø‚àíùëñ + ùëÅ ùëò). Clubbing all these ùëÖÀú slots, we get:
ùëÖÀú‚àí1
ùêΩùëñ‚àó (ùëû > 0; V; r) = ùëû ‚àëÔ∏Å ùõºùëò + ùúÜùêøÀú‚àíùëñ + ùõºùëÖÀúEùêΩùëñ‚àó ùëû ‚àí 1 + ùê¥Àú;
ùëò =0
ùëâùëñ = 0, V‚àíùëñ + ùëÖÀú1; r = 0

ùêΩùëñ‚àó (ùëû = 0; V; r) = ùúÜùêøÀú‚àíùëñ + ùõºùëÖÀúEùêΩ‚àóùëó ùê¥Àú; ùëâùëó = 0,

V‚àí ùëó + ùëÖÀú1; r = 0 ,

(31)

where ùê¥Àú is a Binomial ùëÖÀú, ùúÜ random variable and represents the number of arrivals over ùëÖÀú slots.

11.7 Proof of Thm. 4
Before we prove that cyclic exhaustive service solves the discounted cost MDP described in Sec. 11.6, we require an intermediate result on monotonicity of the optimal cost function.
41

11.7.1 Monotonicity of ùêΩ‚àó (¬∑)

Consider, once again, the Bellman equations.

ùêΩùëñ‚àó (ùëû > 0; v; r = 0) = ùëû + ùúÜ ‚àëÔ∏Å ùë£ùëò + ùõºEùêΩùëñ‚àó (ùëû ‚àí 1 + ùê¥;

ùëò ‚â†ùëñ

ùë£ùëñ = 0, v‚àíùëñ + 1; r = 0) , ùêΩùëñ‚àó (ùëû = 0; v; r = 0) = ùúÜ ‚àëÔ∏Å ùë£ùëò + ùõº min EùêΩ‚àóùëó ùêµ(ùë£ ùëó );
ùëó ‚â†ùëñ ùëò ‚â†ùëñ

ùë£ ùëó = 0, v‚àí ùëó + 1; r = 0 ,

(32)

where, we recall that if random variable ùê∂ is distributed Binomial(ùë£ ùëó , ùúÜ), ùêµ(ùë£ ùëó ) is a random variable whose distribution is the same as that of (ùê∂ ‚àí 1)+ + ùê¥ and ùê¥ is a Bernoulli random variable with Eùê¥ = ùúÜ. We shall now prove that the optimal cost function is monotonically increasing in the Ô¨Årst coordinate when r = 0 (this is really the only scenario where decisions might have to be taken).
Lemma 7. When r = 0, the optimal ùõº‚àídiscounted cost function, ùêΩ‚àó satisÔ¨Åes

ùêΩ‚àó (ùëû1, v, 0)

‚â•

ùêΩ‚àó (ùëû2, v, 0),

‚àÄùëû1

‚â•

ùëû2,

and

v

‚àà

ùëÅ
N

.

(33)

Proof. Let M denote the set of all functions ùëî : S ‚Ü¶‚Üí R+. Considering the R.H.S of equations(32), we deÔ¨Åne the Dynamic Programming Operator ùëá : M ‚Ü¶‚Üí M as in [Ber95] as follows. For any ùëî ‚àà M,
‚àëÔ∏Å (ùëá ùëî)ùëñ (ùëû > 0, v, r) = ùëû + ùúÜ ùë£ùëò + ùõºEùëîùëñ (ùëû ‚àí 1 + ùê¥;
ùëò ‚â†ùëñ
ùë£ùëñ = 0, v‚àíùëñ + 1; r = 0) , ‚àëÔ∏Å
(ùëá ùëî)ùëñ (ùëû = 0, v, r) = ùúÜ ùë£ùëò + ùõº min Eùëî ùëó ùêµ(ùë£ ùëó );
ùëó ‚â†ùëñ ùëò ‚â†ùëñ
ùë£ ùëó = 0, v‚àí ùëó + 1; r = 0 ,
Consider any ùëî ‚àà M that is increasing in ùëû, i.e., ùëî(ùëû + ùëò, v, r) ‚â• ùëî(ùëû, v, r), ‚àÄùëò ‚â• 1. When

‚Ä¢ ùëû ‚â• 1:

‚àëÔ∏Å (ùëá ùëî)ùëñ (ùëû + ùëò, v, r) = (ùëû + ùëò) + ùúÜ ùë£ùëò + ùõºEùëîùëñ ùëû + ùëò ‚àí 1 + ùê¥;
ùëò ‚â†ùëñ
ùë£ùëñ = 0, v‚àíùëñ + 1; r = 0 ,

‚àëÔ∏Å ‚â• ùëû + ùúÜ ùë£ùëò + ùõºEùëîùëñ ùëû ‚àí 1 + ùê¥;
ùëò ‚â†ùëñ
ùë£ùëñ = 0, v‚àíùëñ + 1; r = 0 ,
= (ùëá ùëî)ùëñ (ùëû, v, r).

This shows that the operator ùëá preserves monotonicity for ùëû ‚â• 1. Proposition 2.1 of [Ber95] shows
that value iteration, starting from any ùëî ‚àà M, converges to the Ô¨Åxed point of the operator ùëá, namely ùêΩ‚àó, which also resides in M. Hence, we see that ùêΩ‚àó is monotonically increasing in ùëû when ùëû ‚â• 1.

42

‚Ä¢ ùëû = 0:

ùêΩ‚àó (0; v; r = 0)

=

‚àëÔ∏Å ùúÜùë£

+ ùõº min EùêΩ‚àó ùêµ(ùë£ ùëó ); ùë£ ùëó = 0, v‚àí ùëó + 1; r = 0 ,

ùëñ

ùëò

ùëó‚â†ùëñ ùëó

ùëò ‚â†ùëñ

‚Ä†
=

‚àëÔ∏Å ùúÜùë£

+ ùõº min EùêΩ‚àó ùêµ(ùë£ ); ùë£

= 0, v‚àí

+ 1; r = 0 ,

ùëò

ùëó‚ààùêº ùëó

ùëóùëó

ùëó

ùëò ‚â†ùëñ

‚àëÔ∏Å = ùúÜ ùë£ùëò

ùëò ‚â†ùëñ

+ùõº min min EùêΩ‚àó ùêµ(ùë£ ùëó ); ùë£ ùëó = 0, v‚àí ùëó + 1; r = 0 ,
ùëó‚â†ùëñ ùëó

‚àó
EùêΩ

ùê¥; ùë£ùëñ = 0, v‚àíùëñ + 1; r = 0

,

ùëñ

‚â§ 1 + ùúÜ ‚àëÔ∏Å ùë£ùëò + ùõºEùêΩùëñ‚àó ùê¥; ùë£ùëñ = 0, v‚àíùëñ + 1; r = 0 ,
ùëò ‚â†ùëñ
= ùêΩ‚àó (1; v; r = 0).
ùëñ
In equality ‚Ä† minimization over ùêº \ {ùëñ} is the same as minimization over all ùêº, since attempting to schedule queue ùëñ would result in slot wastage and idling, which, as Prop. 1 shows is suboptimal and hence, will not result in a smaller cost.

11.7.2 Proof of Thm. 4
In this section, we use r‚àíùëõ instead of r to explicitly show which queues‚Äô ùëü ùëó ‚Äôs are known to the server. So, r‚àíùëõ includes ùëü ùëó ‚àÄ ùëó ‚â† ùëõ. Let D be a ùêµùëñùëõ(ùë£ùëõ ‚àí ùë£ùëö ‚àí 1, ùúÜ) random variable. Wherever it becomes necessary to clarify the measure with respect to (w.r.t) which the expectation is being computed, we shall use Eùúá to explicitly denote expectation w.r.t the probability mass function (p.m.f) ùúá. Let ùúàùëö denote the p.m.f of ùêµ(ùë£ùëö), ùúàùëõ that of ùêµ(ùë£ùëö) and ùúá that of ùê∑, i.e., ùêµùëñùëõ(ùë£ùëõ ‚àí ùë£ùëö ‚àí 1, ùúÜ). Also, deÔ¨Åne ùúí =Œî ùúàùëö ‚àó ùúá (here, ‚àó denotes convolution) and ùõΩ =Œî ùúàùëö √ó ùúá (the product measure). Now, with ùë£ùëõ ‚àí ùë£ùëö > 0, we can write:
Eùúàùëõ ùêΩùëõ‚àó ùêµ(ùë£ùëõ); ùë£ùëõ = 0, v‚àíùëõ + 1; r‚àíùëõ = 0
‚àí Eùúàùëö ùêΩùëö‚àó ùêµ(ùë£ùëö); v‚àíùëö + 1; r‚àíùëö = 0
‚â§ùëé Eùúí ùêΩùëõ‚àó ùêµ(ùë£ùëö) + ùê∑; v‚àíùëõ + 1; r‚àíùëõ = 0
‚àí Eùúàùëö ùêΩùëö‚àó ùêµ(ùë£ùëö); v‚àíùëö + 1; r‚àíùëö = 0 (34)
= EùõΩ ùêΩùëõ‚àó ùêµ(ùë£ùëö) + ùê∑; v‚àíùëõ + 1; r‚àíùëõ = 0
‚àí ùêΩùëö‚àó ùêµ(ùë£ùëö); v‚àíùëö + 1; r‚àíùëö = 0 (35)
ùë£ùëõ ‚àí ùë£ùëö ‚àí1
=‚Ä† ‚àëÔ∏Å ùëÉ(ùëü) E ùêΩùëõ‚àó ùêµ(ùë£ùëö) + ùëü; v‚àíùëõ + 1; r‚àíùëõ = 0
ùëü =1
‚àí ùêΩùëö‚àó ùêµ(ùë£ùëö); v‚àíùëö + 1; r‚àíùëö = 0 ùê∑ = ùëü
43

+ ùëÉ(0) E ùêΩùëõ‚àó ùêµ(ùë£ùëö); v‚àíùëõ + 1; r‚àíùëõ = 0

‚àí ùêΩùëö‚àó ùêµ(ùë£ùëö); v‚àíùëö + 1; r‚àíùëö = 0 ùê∑ = 0
ùë£ùëõ ‚àí ùë£ùëö ‚àí1
‚â§ùëè ‚àëÔ∏Å ùëÉ(ùëü) E ùêΩùëõ‚àó ùêµ(ùë£ùëö) + ùëü; v‚àíùëõ + 1; r‚àíùëõ = 0
ùëü =1
‚àí ùêΩùëö‚àó ùêµ(ùë£ùëö); v‚àíùëö + 1; r‚àíùëö = 0 ùê∑ = ùëü (36)

Before we explain inequality ùëé we will require the following result.

Lemma 8.

ùë†ùë°

ùêµ(ùë£ùëõ) ‚â§ ùêµ(ùë£ùëö) ‚àó ùê∑,

(37)

where, as before, ùë†ùë° refers to stochastic ordering and ‚àó denotes convolution.

Proof. Refer Sec. 11.8.

Since nondecreasing functions of stochastically ordered random variables are themselves stochastically ordered, inequality ùëé follows from Lem. 8 and the monotonicity of ùêΩ‚àó in the Ô¨Årst coordinate as proved in
Lemma.7 in Sec. 11.7.1. In equality ‚Ä†, ùëÉ(ùëü) = ùëÉùëü {ùê∑ = ùëü }, as mentioned before.

To explain inequality ùëè we use the following observation about the diÔ¨Äerence between the state in which our controlled Markov chain (CMC) actually is and what the decision maker knows about that state. Note that the lemma that follows is true for CMCs in general. Let X (a countable set) be the state space on which the CMC actually evolves. The MDP is then deÔ¨Åned on the set of all probability mass functions, or p.m.fs on X denoted by P (X) := {p : ‚àÄùë• ‚àà X, 0 ‚â§ ùëù(ùë•) ‚â§ 1, and ùë•‚ààX ùëù(ùë•) = 1}. Let the action space be denoted by A.

Lemma 9. Let ùúá ‚àà P (X) be a probability mass function, or p.m.f, on X (this p.m.f can be degenerate, i.e., 1 at some ùë• ‚àà X and 0 elsewhere) and ùúã‚àó any stationary optimal policy (assuming one exists). Denote the
action space when the state is ùúá by ùê¥ùúá ‚äÇ A and the state of the CMC at time 0 by ùëã0 ‚àà X. Finally, let ùëê : P (X) √ó A ‚Ü¶‚Üí R+ denote the single stage cost and ùúáùëú = ùúá. Then9,

‚àû

‚àû

‚àó ‚àëÔ∏Å

‚àó ‚àëÔ∏Å

ùúã

ùõºùëò ùëê(ùúáùëò , ùê¥ùëò ) ùëã0 = ùë•

‚â•

ùúã
E

ùëò
ùõº

ùëê

(

ùúáùëò

,

ùê¥ùëò

)

,

Eùúá ùõøùë•

ùëò =0

ùëò =0

(38)

where ùúáùëò ‚àà P (X), ùê¥ùëò ‚àà ùê¥ùúá , for all ùëò ‚â• 0. ùëò

Proof. Intuitively speaking, the L.H.S of (38) is an expectation over the subset of sample paths over which ùëã0 = ùë• and when decision-making entity (in our case, the centralized scheduler) begins with knowledge of some p.m.f ùúá over the state. Clearly, this does not mean that the entity knows that ùëã0 = ùë•. But the expectation on the R.H.S indicates that the scheduler begins knowing that ùëã0 = ùë•, hence the ùõøùë• in the subscript. Obviously, the action taken by the decision-making entity when it has complete knowledge of the state (represented by ùõøùë•) cannot be worse than that taken when there is ambiguity about the state (represented by some p.m.f ùúá which might not be ùõøùë•). For details, refer Sec. 11.9 in the Appendix.

In short, the lemma says that while transitioning from conditioning to knowledge, the optimal cost cannot increase. Getting back to proving Eqn. (36), Lem. 9 immediately gives us inequality ùëê below, because ùê∑ = 0
9The discount factor is denoted by ùõº.

44

essentially means that queue ùëõ‚Äôs distribution is ùêµùëñùëõ(ùë£ùëö, ùúÜ). Inequality ùëê is explained in more detail after (39).
E ùêΩùëö‚àó ùêµ(ùë£ùëö); v‚àíùëö + 1; r‚àíùëö = 0 ùê∑ = 0
‚â•ùëê E ùêΩùëö‚àó ùêµ(ùë£ùëö); v‚àí{ùëö,ùëõ} + 1, ùë£ùëõ = ùë£ùëö + 1; r‚àíùëö = 0

=ùëë E ùêΩùëõ‚àó ùêµ(ùë£ùëö); v‚àíùëõ + 1; r‚àíùëõ = 0

=ùëí E ùêΩùëõ‚àó ùêµ(ùë£ùëö); v‚àíùëõ + 1; r‚àíùëõ = 0 ùê∑ = 0 . (39)

When the scheduler knows that both queue ùëö and queue ùëõ have the same number of packets, viz, ùêµ(ùë£ùëö), serving either queue gives the same expected cost, since both queues have statistically similar arrival processes. So, equality ùëë follows from the fact that two queues of length Bin(ùë£ùëö, ùúÜ), with equal arrival rates are stochastically indistinguishable. The R.H.S of equality ùëí is the expected cost of serving queue ùëõ, when the server knows that queue ùëö is distributed ùêµùëñùëõ(ùë£ùëö, ùúÜ) and the backlog of queue ùëö is actually a ùêµùëñùëõ(ùë£ùëö, ùúÜ) random variable, but that is exactly the R.H.S of equality ùëë! Contrast this with the L.H.S of inequality ùëê, where the server only knows that queue ùëõ is distributed ùêµùëñùëõ(ùë£ùëõ, ùúÜ), while conditioning on ùê∑ = 0 means that queue ùëõ is actually distributed ùêµùëñùëõ(ùë£ùëö, ùúÜ). So,
E ùêΩùëõ‚àó ùêµ(ùë£ùëö) + ùëü; v‚àíùëõ + 1; r‚àíùëõ = 0

‚àí ùêΩùëö‚àó ùêµ(ùë£ùëö); v‚àíùëö + 1; r‚àíùëö = 0 ùê∑ = 0 ‚â§ 0. (40)

Now, on to the R.H.S of inequality ùëè. Invoking Lem. 9 and noting that ùëüùëõ = ùëü means the scheduler knows that queue ùëõ has at least ùëü packets, we get
E ùêΩùëö‚àó ùêµ(ùë£ùëö); v‚àíùëö + 1; r‚àíùëö = 0 ùê∑ = ùëü

‚â•

E

ùêΩ‚àó
ùëö

ùêµ(ùë£ùëö); v‚àíùëö + 1; r{‚àíùëö,ùëõ} = 0, ùëüùëõ = ùëü

=ùëì E ùêΩùëõ‚àó ùêµ(ùë£ùëö) + ùëü; v‚àíùëõ + 1; r‚àíùëõ = 0

=ùëî E ùêΩùëõ‚àó ùêµ(ùë£ùëö) + ùëü; v‚àíùëö + 1; rùëõ = 0 ùê∑ = ùëü . (41)

Equality ùëì is explained as follows. In the space of policies we are considering, a server always Ô¨Årst serves all queues with positive ùëü and then returns to the incumbent. So, when it is known that ùëüùëõ = ùëü, the server will Ô¨Årst serve the ùëü packets in queue ùëõ and then return to queue ùëö. But that will result in the same mean cost as serving queue ùëõ exhaustively, when it is known that queue ùëõ‚Äôs backlog is distributed ùõøùëü ‚àó ùêµùëñùëõ(ùë£ùëö, ùúÜ). Equality ùëî uses the same logic as Equality ùëí in (39).
E ùêΩùëõ‚àó ùêµ(ùë£ùëö) + ùëü; v‚àíùëõ + 1; r‚àíùëõ = 0 ‚àí ùêΩùëö‚àó ùêµ(ùë£ùëö); v‚àíùëö + 1; r‚àíùëö = 0 ùê∑ = ùëü ‚â§ 0, ‚àÄ1 ‚â§ ùëü ‚â§ ùë£ùëõ ‚àí ùë£ùëö. (42)

From (40) and (42), the policy structure now follows.

11.8 Proof of Lem. 8
Given ùëò ‚â• 1 if ùëç is a random variable with p.m.f Bin(ùëò, ùúÜ) we deÔ¨Åne ùêµÀú(ùëò) as the p.m.f of (ùëç ‚àí 1)+. Let ùëãùëò (ùëò ‚â• 1), and ùëåùëõ (ùëõ ‚â• 1) be random variables with distributions ùêµÀú(ùëò), and Bin(ùëõ, ùúÜ), respectively. In what
45

follows, we will Ô¨Årst show that

ùë†ùë°

ùëãùëò + ùëåùëõ ‚â• ùëãùëò+1 + ùëåùëõ‚àí1, ‚àÄùëò ‚â• 1.

(43)

Since

the

L.H.S

of

Eqn.

43,

ùëãùëò

+ ùëåùëõ

ùëë
=

ùëãùëò

+ ùëå1

+ ùëåùëõ‚àí1

(where

ùëë
=

denotes

equality

of

distribution),

it

is

suÔ¨Écient

to prove that

ùë†ùë°
ùëãùëò + ùëå1 ‚â• ùëãùëò+1.

(44)

We show this by proving that

ùëÉ{ùëãùëò + ùëå1 ‚â§ ùëô} ‚â§ ùëÉ{ùëãùëò+1 ‚â§ ùëô ‚àí 1}, ‚àÄùëô ‚àà {0, 1, . . . , ùëò }.

(45)

We consider several cases

‚Ä¢ ùëô=0 while

ùëÉ{ùëãùëò+1 ‚â§ 0} = (1 ‚àí ùúÜ)ùëò+1 + (ùëò + 1) (1 ‚àí ùúÜ)ùëòùúÜ = (1 ‚àí ùúÜ)ùëò (1 + ùëòùúÜ) ,
ùëÉ{ùëãùëò + ùëå1 ‚â§ 0} = (1 ‚àí ùúÜ)ùëò + ùëò (1 ‚àí ùúÜ)ùëò‚àí1ùúÜ (1 ‚àí ùúÜ) = (1 ‚àí ùúÜ)ùëò (1 + (ùëò ‚àí 1)ùúÜ) < ùëÉ{ùëãùëò+1 ‚â§ 0}.

‚Ä¢ 1‚â§ùëô ‚â§ ùëò‚àí1

ùëÉ{ùëãùëò+1 = ùëô} = ùëòùëô ++ 11 ùúÜùëô+1 (1 ‚àí ùúÜ)ùëò‚àíùëô,

while

ùëÉ{ùëãùëò + ùëå1 = ùëô} =

ùëò ùúÜ(ùëô+1) (1 ‚àí ùúÜ) (ùëò‚àíùëô‚àí1) (1 ‚àí ùúÜ) ùëô+1

+

ùëò

ùëô
ùúÜ

(1

‚àí

ùúÜ)

(

ùëò

‚àíùëô)

ùúÜ

ùëô

=

ùëò

ùëò +

ùúÜùëô+1 (1 ‚àí ùúÜ) (ùëò‚àíùëô)

ùëô+1 ùëô

= ùëÉ{ùëãùëò+1 = ùëô}.

Hence, in this case, ùëÉ{ùëãùëò+1 ‚â§ ùëô} ‚â• ùëÉ{ùëãùëò + ùëå1 ‚â§ ùëô}.
‚Ä¢ ùëô=ùëò
ùëÉ{ùëãùëò+1 = ùëô} = ùúÜùëò+1, and ùëÉ{ùëãùëò + ùëå1 = ùëô} = ùëÉ{ùëãùëò = ùëò }ùëÉ{ùëå1 = 1}
= ùúÜùëò+1 = ùëÉ{ùëãùëò+1 = ùëô}.
(46)

Once again, ùëÉ{ùëãùëò+1 ‚â§ ùëò } ‚â• ùëÉ{ùëãùëò + ùëå1 ‚â§ ùëò }.

46

ùë†ùë°

ùë†ùë°

This proves Eqn. 44 and hence, Eqn. 43. By the same token, it is at once obvious that ùëãùëò +ùëåùëõ ‚â• ùëãùëò+1 +ùëåùëõ‚àí1 ‚â•

ùë†ùë°

ùëãùëò+2 + ùëåùëõ‚àí2 . . . ‚â• ùëãùëò+ùëõ, which means that,

ùêµÀú(ùëò + ùëõ)

ùë†ùë°
‚â§

ùêµÀú(ùëò) ‚àó ùêµùëñùëõ(ùëõ)

‚áí ùêµÀú(ùëò + ùëõ) ‚àó ùêµùëñùëõ(1, ùúÜ)

ùë†ùë°
‚â§

ùêµÀú(ùëò) ‚àó ùêµùëñùëõ(ùëõ) ‚àó ùêµùëñùëõ(1, ùúÜ)

ùë†ùë°

‚áí ùêµ(ùëò + ùëõ) ‚â§ ùêµ(ùëò) ‚àó B(ùëõ).

(47)

Lem. 8 follows by setting ùë£ùëö = ùëò and ùë£ùëõ = ùëò + ùëõ, in (47).

11.9 Proof of Lem. 9

For every ùëé ‚àà A denote by ùëùùëé (ùëß, ùúà) the stochastic transition kernel10 from P (X) √ó A ‚Ü¶‚Üí P (X). Such a kernel exists by Lem. 3.2 and Eqn. 3.7 in Chapter 4 of [HL89]. Now, observe that the R.H.S of 38

‚àû

‚àó ‚àëÔ∏Å

ùúã

ùëò
ùõº

ùëê

(

ùúáùëò

,

ùê¥ùëò

)

Eùõøùë•

ùëò =0

= ùëê(ùõøùë•, ùúã‚àó(ùõøùë•))

‚à´
+ùõº
P ( X)

‚àû
Eùúàùúã‚àó ‚àëÔ∏Å ùõºùëò‚àí1ùëê(ùúáùëò , ùê¥ùëò )
ùëò =1

√óùëù ùúã‚àó( ùõøùë•) (ùõøùë•, ùëëùúà)

#1
‚â§ ùëê(ùõøùë•, ùëé)

‚à´ +ùõº

‚àû
Eùúàùúã‚àó ‚àëÔ∏Å ùõºùëò‚àí1ùëê(ùúáùëò , ùê¥ùëò ) ùëùùëé (ùõøùë• , ùëëùúà),

P ( X)

ùëò =1

for all ùëé ‚àà ùê¥ùúá. Inequality #1 follows from the fact that ùúã‚àó is an optimal policy. Hence, the L.H.S of 38,

‚àû

‚àó ‚àëÔ∏Å

ùúã
Eùúá

ùõºùëò ùëê(ùë•ùëò , ùê¥ùëò ) | ùëã0 = ùë•

ùëò =0

#=2 ùëê(ùõøùë• , ùúã‚àó (ùúá))

‚à´
+ùõº
P (ùúí)

‚àû
Eùúàùúã‚àó ‚àëÔ∏Å ùõºùëò‚àí1ùëê(ùúáùëò , ùê¥ùëò )
ùëò =1

√óùëù ùúã‚àó (ùúá) (ùõøùë•, ùëëùúà)

‚àû

‚àó ‚àëÔ∏Å

‚â•

ùúã
E

ùëò
ùõº

ùëê

(

ùúáùëò

,

ùê¥ùëò

)

.

ùõøùë•

ùëò =0

Note that in the Ô¨Årst term of the R.H.S of equality #2, because of the conditioning on {ùëã0 = ùë•} the CMC is in state ùõøùë• which becomes the Ô¨Årst argument of ùëê(¬∑, ¬∑) and the controller or decision maker is only told ùúá, which becomes the second argument of ùëê(¬∑, ¬∑).

11.10 Solving the Time-Average Cost MDP
We use the technique described in [Sen89] to show that the SLQ policy is optimal for the long term timeaveraged cost criterion as well. We consider a sequence of discount factors {ùõºùëõ} ‚Üë 1 and the corresponding discounted optimal policies. We begin with the following result:
10Refer Chapter 4 of [HL89] for details.
47

Lemma 10. ( [Sen89]) Let {ùõºùëõ} be a sequence of discount factors increasing to 1, and let ùúã‚àó be the associated
ùëõ
sequence of discounted optimal stationary policies. There exists a subsequence {ùõºùëõ } and a stationary policy ùëò
ùúã‚àó that is a limit point of ùúã‚àó .
ùëõùëò
The proof of Lemma 10 can be found in [Sen89]. In our case, the assertion is easily seen to be true, since the SLQ policy is optimal for every ùõº ‚àà (0, 1). To invoke the theorem in [Sen89], we need to Ô¨Årst show that the conditions assumed therein are true. Towards this end let us Ô¨Årst limit our MDP‚Äôs state space to ùëÜ = N √ó NùëÅ √ó NùëÅ ‚àí1 √ó ùêº ‚àí ùëÜ0, where, ùëÜ0 = {ùë† ‚àà N √ó NùëÅ √ó NùëÅ ‚àí1 √ó ùêº : ùë£ùëñ = ùë£ ùëó = 0 for some ùëó ‚â† ùëñ or ùëü ùëó ‚â• 1 for some ùëó ‚àà ùêº}. The set ùëÜ0 contains states where multiple coordinates of V(ùë°) are zero and states with ùëü ùëó ‚â• 1. The former class of states is not allowed, since there can be at most one transmitter in any time slot. The latter are all transient states. ùëÜ0 obviously contains the set of transient states induced by the policies under consideration, and needs to be removed so that the resulting controlled DTMC, deÔ¨Åned on ùëÜ , can be irreducible.
Now, the theorem in [Sen89] makes assumptions, which in our case can be restated as follows. For any ùõº ‚àà (0, 1), and state (ùëû, V, r, ùëñ) ‚àà ùëÜ ,

‚Ä¢ A: ùêΩ‚àó ((ùëû, V, r) < ‚àû.
ùëñ

‚Ä¢

B:

Let11

V0

= 1 ‚àí ÀÜe1

and

deÔ¨Åne

‚Ñéùëñ,ùõº (ùëû, V, r)

:=

ùêΩ‚àó((ùëû,
ùëñ

V,

r)

‚àí

ùêΩ1‚àó ((0,

V0,

0).

There

exists

ùëÅ

> 0,

s.t.

‚Ñéùëñ,ùõº (ùëû, V, r) ‚â• ‚àíùëÅ ‚àÄ(ùëû, V, r, ùëñ) ‚àà ùëÜ .

(48)

‚Ä¢ C: For any given pair of states (ùë†, ùë°) ‚àà ùëÜ √ó ùëÜ , and action ùëé ‚àà ùêº, let ùëÉùë†ùë° (ùëé) denote the transition probability from state ùë† to state ùë° under action ùëé in the MDP (for further details, read Sec.11.6). There exists ùëÄùëñ (ùëû, V, r) ‚â• 0, s.t.

‚Ñéùëñ,ùõº (ùëû, V, r) ‚â§ ùëÄùëñ (ùëû, V, r) ‚àÄ(ùëû, V, r, ùëñ) ‚àà ùëÜ , and ùõº ‚àà (0, 1),

(49)

and, denoting by ùëÄùë° the R.H.S in the above equation for state ùë° ‚àà ùëÜ ,

‚àëÔ∏Å

ùëÄùë° ùëÉùë†ùë° (ùëé) < ‚àû, ‚àÄùë† ‚àà ùëÜ and ùëé ‚àà ùêº.

(50)

ùë° ‚ààùëÜ

Theorem 11. If the assumptions A, B and C hold, ùúã‚àó is optimal for the Averge Cost problem as well.

Theorem 11 is proved in [Sen89]. To see why A is true, deÔ¨Åne ùë†(0) = [ùëû, V, r, ùëñ] and consider

‚àûÔ£Æ

Ô£π

ùêΩ‚àó (ùë†(0))

=

min Eùúã

‚àëÔ∏Å ùëõ Ô£Ø ùõº Ô£ØùëÑùë¢

‚àëÔ∏Å

‚àëÔ∏Å

Ô£∫

(ùëõ) + ùúÜ

ùëâùëó (ùëõ) + ùëÖùëñ (ùëõ)Ô£∫

ùëñ

ùúã ùë† (0)

ùëõ‚àí1
Ô£Ø

Ô£∫

ùëõ=0 Ô£Ø

ùëó ‚â†ùë¢ùëõ‚àí1

ùëñ‚ààùêº

Ô£∫

Ô£∞

Ô£ª

‚àûÔ£Æ

ùëí

‚àëÔ∏Å Ô£Ø

‚àëÔ∏Å

‚â§

min

E

ùúã ùë†(

0)

ùõºùëõ Ô£Ø ùëÑùë¢ùëõ‚àí1 (0) + ùëõ + ùúÜ ùëõ +

ùëâùëó (0)

ùúã

Ô£Ø

ùëõ=0 Ô£Ø

ùëó ‚â†ùë¢ùëõ‚àí1

Ô£∞

‚àëÔ∏Å + ùëõ + ùëÖùëñ (0)
ùëñ‚ààùêº

ùëì ‚àë‚àûÔ∏Å Ô£Æ ‚àëÔ∏Å

‚â§

min

E

ùúã ùë†(

0

)

ùëõ
ùõº

Ô£ØÔ£Ø (ùëÑ (0)

+

ùëõ)

+

ùúÜ

ùëõ+

ùëâùëó (0)

ùúã

Ô£Ø

ùëõ=0 Ô£Ø

ùëó ‚â†ùë¢ùëõ‚àí1

Ô£∞

‚òÖ
< ‚àû,

‚àëÔ∏Å + ùëõ + ùëÖùëñ (0)
ùëñ‚ààùêº

11We deÔ¨Åne ÀÜeùëò as the vector with 0‚Äôs at all coordinates except the ùëòùë°‚Ñé, which is equal to 1.

48

where inequality ùëí follows from the fact that over ùëõ slots, the backlog of queue ùë¢ùëõ‚àí1 cannot have increased to more than ùëõ packets over its initial backlog, i.e., ùëÑùë¢ùëõ‚àí1 (0) + ùëõ. In inequality ùëì , ùëÑ (0) = maxùëò ‚ààùêº ùëÑùëò (0). Finally,

inequality ‚òÖ uses the fact that

‚àû

‚àëÔ∏Å

ùëõ
ùëõùõº

<

‚àû,

‚àÄùõº

‚àà

(0, 1).

(51)

ùëõ=0

In Lemma.7, we have already proven that ùêΩ‚àó is increasing in its Ô¨Årst coordinate. Now, keeping the incumbent the same, suppose one of the coordinates of V is increased,

ùêΩ‚àó (0; V; 0)

=

‚àëÔ∏Å ùúÜ ùëâùëò

+

ùõº min EùêΩ‚àó

(ùêµ(ùëâùëò ); ùëâùëò

=

0, V‚àíùëò

+

1; 0)

ùëñ

ùëò‚â†ùëñ ùëó

ùëò ‚â†ùëñ

‚â§

‚àëÔ∏Å ùúÜ(ùëâ + 1) + ùúÜ ùëâ

+ ùõº min

min

‚àó
EùêΩ

(

ùêµ(ùëâ

);

ùëô

ùëò

ùëò‚â†ùëñ,ùëô ùëó

ùëò

ùëò ‚â†ùëñ ,ùëô

ùëâùëò = 0, V‚àíùëò + 1 + ÀÜeùëô; 0) , ùêΩ‚àó (ùêµ(ùëâùëô + 1); ùëâùëô = 0, V‚àíùëò + 1; 0)
ùëô
= ùêΩùëñ‚àó (0; V + ÀÜeùëô; 0). (52)

A similar analysis proves that ùêΩ‚àó is increasing in the coordinates of r also. Finally, starting with a diÔ¨Äerent
incumbent, since ùêΩùëô‚àó (0; V; 0) = ùúÜ ‚àëÔ∏Å ùëâùëò + ùõº min EùêΩ‚àóùëó (ùêµ(ùëâùëò ); ùëâùëò = 0, V‚àíùëò + 1; 0) , (53)
ùëò ‚â†ùëô ùëò ‚â†ùëô

we see that if ùëâùëô in the Ô¨Årst equation of (52) is equal to ùëâùëñ in (53), then ùêΩ‚àó (0; V; 0) = ùêΩ‚àó (0; V; 0). This is

ùëô

ùëñ

achieved by noting that all since arrivals are statistically identical and independent one can simply route the

packets of queue ùëô to queue ùëñ and vice versa in every sample path. This doesn‚Äôt change the statistics of the

system in any way and proves that

ùêΩ‚àó((ùëû,
ùëñ

V,

r)

‚àí

ùêΩ1‚àó ((0,

V0,

0)

=

‚Ñéùëñ,ùõº (ùëû,

V,

r)

‚â•

0

‚àÄùëñ

‚àà

ùêº.

(54)

Proving assumption C is nontrivial, and Prop. 5 (pp.629) in [Sen89] gives a suÔ¨Écient condition for C to hold.
Lemma 12. Assume that the MDP has a stationary policy ùëì that induces an irreducible, positive recurrent Markov chain on the state space of the problem, viz, ùëÜ . Let ùëù ùëì (ùëû, V, r, ùëñ) denote the invariant distribution of the chain and let ùëê ùëì (ùëû, V, r, ùëñ) denote the non-negative cost in state s = [ùëû; V; r; ùëñ]. If

Ô£Æ

ùëÅÔ£π

‚àëÔ∏Å ùëù

(ùëû, V, r, ùëñ)ùëê

(ùëû, V, r, ùëñ) = E Ô£ØÔ£ØùëÑÀú + ùúÜ ‚àëÔ∏Å ùëâÀú

‚àëÔ∏Å Ô£∫ + ùëüÀú Ô£∫ < ‚àû

(55)

ùëì

ùëì

ùëò

ùëô

Ô£Ø

Ô£∫

s

Ô£Ø

ùëò ‚â†Àúùëñ

ùëô=1 Ô£∫

Ô£∞

Ô£ª

then assumption C is true. Here, ùëÑÀú, VÀú , Àúr and Àúùëñ are the random variables with joint distribution ùëù ùëì . Notice, however, from (10) that for all policies under consideration that are also stabilizing,

Ô£Æ

ùëÅÔ£π

ùëÅ

E Ô£ØÔ£ØùëÑÀú + ùúÜ ‚àëÔ∏Å ùëâÀú

‚àëÔ∏Å Ô£∫ + ùëüÀú Ô£∫

=

E

E

‚àëÔ∏Å ùëÑ

ùëÑÀú, VÀú

ùëò

ùëô

ùëò

Ô£Ø

Ô£∫

Ô£Ø

ùëò ‚â†Àúùëñ

ùëô=1 Ô£∫

ùëò =1

Ô£∞

Ô£ª

ùëÅ

‚àëÔ∏Å

= E ùëÑùëò,

(56)

ùëò =1

where [ùëÑ1, . . . , ùëÑ ùëÅ ] is the stationary queue-length vector of the system. We have already shown that ùúã‚àó is stabilizing and know that the policy discussed in Sec. 4.5.4, ùúã , is also stabilizing from the discussion therein.

49

Time Slot
ùë° ùë°+1 ùë°+2
ùë°+3 . . . ùë°

V1 (¬∑) (incumbent) [0, 9, 11, 12] [0, 10, 12, 13] [0, 11, 13, 14]
[0, 12, 14, 15]
[0, 11, 13, 14]

V2 (¬∑)
[0, 9, 11, 12] [0, 10, 12, 13] [1‚àó, 11, 13, 0] [0, 11, 13, 14] [0, 12, 14, 15]
[0, 11, 13, 14]

V3 (¬∑)
[0, 9, 11, 12] [0, 10, 12, 13] [0, 11, 13, 14] [0, 12, 14, 15]
[0, 11, 13, 14]

V4 (¬∑) (ùëéùëüùëî ùëöùëéùë•ùëñùëâùëñ (ùë°) = 4)
[0, 9, 11, 12] [0, 10, 12, 13] [0, 11, 13, 14]
[1‚àó, 12, 14, 0] ‚Üê Queue 4 nonempty
[1‚àó, 11, 13, 0] ‚Üê Queue 4 empty [0, 11, 13, 14]

Table 2: Illustrating the three types of CCA errors and the resulting ùëâ -vector misalignment. The network here comprises 4 nodes and the 4 columns represent local copies of the ùëâ -vector (i.e., Vùëñ (ùë°) is the copy of the ùëâ -vector at Node ùëñ). In the situation considered here, Node 1 is the incumbent and ùëéùëü ùëî ùëöùëéùë•1‚â§ùëñ‚â§4ùëâùëñ (ùë°) = 4. The coordinate at which CCA error occurs is denoted by an asterisk (‚àó). A red to blue transition implies the node detects (infers) a misalignment and also corrects it within the same time slot.

So, we set ùëì ‚â° ùúã , since ùúã is stationary and Markov, and observe that for any ùúÜ ‚àà [0, 1 ) queueing delay
ùëÅ

for such policies is Ô¨Ånite. Using Little‚Äôs law, we see that under ùúã , E

ùëÅ
ùëò=1 ùëÑ ùëò

=

ùëÅ
ùëò=1 EùëÑùëò

<

‚àû.

Since ùúã

is

stationary, this proves the claim and establishes the fact that ùúã‚àó is optimal for the average cost criterion as

well.

11.11 Proof of Prop. 6

Let Z+ denote the non negative integers. The proof uses a simple mean drift argument with a novel Lyapunov function. DeÔ¨Åne ùêø : Z2+ùëÅ ‚Ü¶‚Üí R+ as

ùëÅ

2

‚àëÔ∏Å

ùêø (ùë†(ùë°)) := ùëÑ ùëó (ùë° ‚àí ùëâùëó (ùë°)) + ùúÜ ùëóùëâùëó (ùë°) + ùëâùëó (ùë°)ùúÜ ùëó (1 ‚àí ùúÜ ùëó ).

(57)

ùëó =1

We will prove that a policy that is clearly suboptimal (refer Fig. 17), again, w.r.t. delay when compared to ùúãùêæ (meaning it idles more than ùúãùêæ ) is also stabilizing. This new policy, called ‚ÄúGated K Limited service‚Äù(GKLS) policy and denoted by ùúâùêæ , serves only those packets that were in the chosen queue at the beginning of service, for a maximum of ùêæ slots. Also, once a queue is chosen for service, the server stays at it (idling, if necessary), for ùêæ slots at the end of which ùëéùëüùëî ùëöùëéùë•1‚â§ùëñ‚â§ùëÅ (ùëÑùëñ (ùë° ‚àí ùëâùëñ (ùë°)) + ùúÜùëñùëâùëñ (ùë°)) is chosen for service for the next ùêæ slots.
For example, suppose ùêæ = 5 and queue 3 has been chosen for service. At the beginning of service, suppose ùëÑ3 = 2 and over the course of the 5 slots, it receives 4 more packets. Then ùúâùêæ serves only the 2 that were in Queue 3 at the beginning of service, does not serve any of the 4 new packets and idles for the remaining ùêæ ‚àí 2(= 3) slots. This is clearly suboptimal compared to ùúãùêæ which would have served 5 packets and left queue 3 with just 1 packet at the end of ùêæ = 5 slots.
Suppose at time ùë°, ùúâùêæ switches to queue ùëñ. For all other queues, after K slots, ùëâùëô (ùë° + ùêæ) = ùëâùëô (ùë°) + ùêæ, and ùëÑùëô (ùë° + ùêæ ‚àí ùëâùëô (ùë° + ùêæ)) = ùëÑùëô (ùë° ‚àí ùëâùëô (ùë°)). Therefore, at the end of ùêæ slots, the new state is ùë†(ùë° + ùêæ) = [ùëÑ1 (ùë° ‚àí ùëâ1 (ùë°)), . . . , ùëÑùëñ‚àí1 (ùë° ‚àí ùëâùëñ‚àí1 (ùë°)), ùëÑùëñ (ùë° + ùêæ), ùëÑùëñ+1 (ùë° ‚àí ùëâùëñ+1 (ùë°)), . . . , ùëÑ ùëÅ (ùë° ‚àí ùëâùëÅ (ùë°)), ùëâ1 (ùë°) + ùêæ, . . . , ùëâùëñ‚àí1 (ùë°) + ùêæ, 0, ùëâùëñ+1 (ùë°) + ùêæ, . . . , ùëâùëÅ (ùë°) + ùêæ]. Invoking the linearity of conditional expectation, computing the expected conditional drift can be split into contributions by the queue chosen for service at time ùë°, i.e., queue ùëñ, and that by the

50

Expected Delay (slots)

System with 20 queues 90
80 70 KLEQ (œÄK): K = 2
GKLS (ŒæK): k = 2 60
50
40
30
20
10
0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04 0.045 0.05
Œ£i Œªi (pkts/s)
Figure 17: Illustrating the suboptimality of the Gated K Limited service policy ( ùúâùêæ ).

other queues. For simplicity we drop the time indices and denote ùëâùëó (ùë°) by ùëâùëó for the remainder of the proof.

E [ùêø(ùë†(ùë° + ùêæ)) ‚àí ùêø(ùë†(ùë°))|ùë†(ùë°)]

=

E

ùëÑ2 (ùë°

+ ùêæ)

‚àí

(ùëÑùëñ (ùë°

‚àí ùëâùëñ)

+ ùúÜ ùëâ )2
ùëñùëñ

‚àí ùëâùëñùúÜùëñ (1 ‚àí ùúÜùëñ)

ùë†(ùë°)

+

ùëñ

‚àëÔ∏Å

E

ùëÑ ùëó (ùë° ‚àí ùëâùëó) + ùúÜ ùëó ùëâùëó + ùêæ

2 + ùëâùëó + ùêæ ùúÜ ùëó (1 ‚àí ùúÜ ùëó) ‚àí

ùëó ‚â†ùëñ

‚àëÔ∏Å ùëÑ ùëó (ùë° ‚àí ùëâùëó ) + ùúÜ ùëóùëâùëó 2 + ùëâùëó ùúÜ ùëó (1 ‚àí ùúÜ ùëó ) ùë†(ùë°) (58)
ùëó ‚â†ùëñ

The contribution to ùêø(ùë†(ùë° + ùêæ)) of all queues ùëó other than ùëñ is

‚àëÔ∏Å ùëÑ ùëó (ùë° ‚àí ùëâùëó ) + ùúÜ ùëó ùëâùëó + ùêæ 2 + ùëâùëó + ùêæ ùúÜ ùëó (1 ‚àí ùúÜ ùëó )
ùëó ‚â†ùëñ

= ‚àëÔ∏Å ùëÑ ùëó (ùë° ‚àí ùëâùëó ) + ùúÜ ùëóùëâùëó 2 + 2ùêæ ùëÑ ùëó (ùë° ‚àí ùëâùëó ) + ùúÜ ùëóùëâùëó ùúÜ ùëó
ùëó ‚â†ùëñ

+ùêæ2ùúÜ2 + ùëâùëóùúÜ ùëó (1 ‚àí ùúÜ ùëó ) + ùêæùúÜ ùëó (1 ‚àí ùúÜ ùëó ).

(59)

ùëó

Using (59), the second term on the R.H.S of (58) becomes

‚àëÔ∏Å

E

ùëÑ ùëó (ùë° ‚àí ùëâùëó) + ùúÜ ùëó ùëâùëó + ùêæ

2 + ùëâùëó + ùêæ ùúÜ ùëó (1 ‚àí ùúÜ ùëó)

ùëó ‚â†ùëñ

‚àí ‚àëÔ∏Å ùëÑ ùëó (ùë° ‚àí ùëâùëó ) + ùúÜ ùëóùëâùëó 2 + ùëâùëó ùúÜ ùëó (1 ‚àí ùúÜ ùëó ) ùë†(ùë°)
ùëó ‚â†ùëñ

= E 2ùêæ ùëÑ ùëó (ùë° ‚àí ùëâùëó ) + ùúÜ ùëóùëâùëó ùúÜ ùëó + ùêæ2ùúÜ2 + ùêæùúÜ ùëó (1 ‚àí ùúÜ ùëó ) ùë†(ùë°)
ùëó

= 2ùêæ ùëÑ ùëó (ùë° ‚àí ùëâùëó ) + ùúÜ ùëóùëâùëó ùúÜ ùëó + ùêæ2ùúÜ2 + ùêæùúÜ ùëó (1 ‚àí ùúÜ ùëó ),

(60)

ùëó

where the last equality follows since the term inside the expectation is a function of ùë†(ùë°). Proceeding to queue ùëñ, we see that

ùëÑ2(ùë° + ùêæ)

(‚àóùëé)
=

(ùëÑ

(ùë° ‚àí ùëâ ) + ùê¥

[ùë° ‚àí ùëâ

+ 1, ùë°] ‚àí ùêæ)+ + ùê¥

[ùë° + 1, ùë° + ùêæ]

2
,

ùëñ

ùëñ

ùëñ

ùëñ

ùëñ

ùëñ

(‚àóùëè)
‚â§ (ùëÑùëñ (ùë° ‚àí ùëâùëñ) + ùê¥ùëñ [ùë° ‚àí ùëâùëñ + 1, ùë°])2 + ùêæ2 + ( ùê¥ùëñ [ùë° + 1, ùë° + ùêæ])2

‚àí2 (ùëÑùëñ (ùë° ‚àí ùëâùëñ) + ùê¥ùëñ [ùë° ‚àí ùëâùëñ, ùë°]) (ùêæ ‚àí ùê¥ùëñ [ùë° + 1, ùë° + ùêæ]),

(61)

51

where, in equality (‚àóùëé), one Ô¨Årst needs to note that queue ùëñ has never been served since ùë° ‚àí ùëâùëñ. Also, ùê¥ùëñ [ùë•, ùë¶] denotes the cumulative arrivals to queue ùëñ over the time period [ùë•, ùë¶], and ùê¥ùëñ [ùë•, ùë•] is the arrival over the single slot ùë•. SpeciÔ¨Åcally, when the arrival process is Bernoulli, ùê¥ùëñ [ùë•, ùë¶] has the distribution Binomial(ùë¶ ‚àí ùë• + 1, ùúÜùëñ). Also, (‚àóùëè) follows from the fact that for any three nonnegative numbers ùë•, ùë¶ and ùëß, ((ùë• ‚àí ùë¶)+ + ùëß)2 ‚â§ ùë•2 + ùë¶2 + ùëß2 ‚àí 2ùë•(ùë¶ ‚àí ùëß). In what follows, we use the fact that if a random variable ùëã ‚àºBinomial(ùëö, ùëù), then Eùëã2 = ùëöùëù(1 ‚àí ùëù) + ùëö2ùëù2.
E ùëÑ2ùëñ (ùë° + ùêæ) ùë†(ùë°) ‚â§ E (ùëÑùëñ (ùë° ‚àí ùëâùëñ) + ùê¥ùëñ [ùë° ‚àí ùëâùëñ + 1, ùë°])2 + ùêæ2
+ ( ùê¥ùëñ [ùë° + 1, ùë° + ùêæ])2 ‚àí
2 (ùëÑùëñ (ùë° ‚àí ùëâùëñ) + ùê¥ùëñ [ùë° ‚àí ùëâùëñ + 1, ùë°])

√ó (ùêæ ‚àí ùê¥ùëñ [ùë° + 1, ùë° + ùêæ]) ùë†(ùë°)

(‚àóùëê)
=

ùëÑ2 (ùë° ‚àí ùëâ ) + 2ùúÜ ùëâ ùëÑ (ùë° ‚àí ùëâ ) + ùëâ ùúÜ (1 ‚àí ùúÜ )

ùëñ

ùëñ

ùëñùëñ ùëñ

ùëñ

ùëñùëñ

ùëñ

+ùëâ 2ùúÜ2 + ùêæ2 + ùêæùúÜùëñ (1 ‚àí ùúÜùëñ) + ùêæ2ùúÜ2

ùëñùëñ

ùëñ

‚àí2 (ùëÑùëñ (ùë° ‚àí ùëâùëñ) + ùúÜùëñùëâùëñ) ùêæ (1 ‚àí ùúÜùëñ) .

In (‚àóùëê), one needs to note that the arrivals that enter queue ùëñ after the last time queue ùëñ was served, viz., ùê¥ùëñ [ùë° ‚àí ùëâùëñ, ùë° + ùêæ], are independent of ùëÑùëñ (ùë° ‚àí ùëâùëñ). With this, the contribution of queue ùëñ to the expected drift (the Ô¨Årst term on the R.H.S of (58)) is

E

ùëÑ2 (ùë°

+ ùêæ)

‚àí

(ùëÑùëñ (ùë°

‚àí ùëâùëñ)

+ ùúÜ ùëâ )2
ùëñùëñ

‚àí ùëâùëñùúÜùëñ (1 ‚àí ùúÜùëñ)

ùë†(ùë°)

ùëñ

‚â§ ùêæ2 + ùêæùúÜùëñ (1 ‚àí ùúÜùëñ) + ùêæ2ùúÜ2
ùëñ

+2ùêæùúÜùëñ (ùëÑùëñ (ùë° ‚àí ùëâùëñ) + ùúÜùëñùëâùëñ) ‚àí 2ùêæ (ùëÑùëñ (ùë° ‚àí ùëâùëñ) + ùúÜùëñùëâùëñ)

(62)

We are now in a position to compute the expected drift. DeÔ¨Åne ùúñ := 1 ‚àí ùëó ùúÜ ùëó , strictly positive, by assumption. Using (60) and (62) in (58), we get

E [ùêø(ùë†(ùë° + ùêæ)) ‚àí ùêø(ùë†(ùë°))|ùë†(ùë°)] ‚â§

ùëÅ

ùëÅ

ùêæ (ùêæ ‚àí 1) ‚àëÔ∏Å ùúÜ2ùëó + ùêæ ‚àëÔ∏Å ùúÜ ùëó + ùêæ2

ùëó =1

ùëó =1

ùëÅ
‚àëÔ∏Å ‚àí2ùêæ (ùëÑùëñ (ùë° ‚àí ùëâùëñ) + ùúÜùëñùëâùëñ) 1 ‚àí ùúÜùëô
ùëô=1
< ‚àíùúñ,

whenever

ùêæ (ùêæ ‚àí 1) ùëöùëéùë•ùëñ (ùëÑùëñ (ùë° ‚àí ùëâùëñ) + ùúÜùëñùëâùëñ) >

ùëÅùëó=1 ùúÜ2ùëó + ùêæ 2ùêæùúñ

ùëÅ ùëó =1

ùúÜùëó

+

ùêæ2

1

+,

2ùêæ

Invoking the Foster Lyapunov theorem [FMM95] we see that the DTMC {ùë†(ùêæùë°), ùë° ‚â• 0} is positive recurrent.

To show that ùë†(ùë°) is positive recurrent as well, we invoke the following lemma.

Lemma 13. Let {ùëã (ùë°), ùë° ‚â• 0} be an aperiodic and irreducible DTMC over a countable state space. DeÔ¨Åne ùëå (ùë°) := ùëã (ùêæùë°), ‚àÄùë° ‚â• 0, for some positive integer ùêæ. If ùëå (ùë°) is positive recurrent, then so is ùëã (ùë°).

Proof. Given any ùëó ‚àà N, suppose the mean recurrence time of ùëó in ùëå (ùë°) is denoted by ùúà(ùêæ) , and in ùëã (ùë°) by
ùëó
ùúà ùëó . Clearly, starting from any state ùëó, every time ùëã (ùêæùë°) hits ùëó, so does ùëã (ùë°). This means that ùúà(ùëóùêæ) ‚â• ùúà ùëó and since ùúà(ùëóùêæ) < ‚àû, so is ùúà ùëó , showing that ùëã (ùë°) is also positive recurrent.

Thus, ùë†(ùë°) is also positive recurrent, and the proof of Prop. 6 concludes.

52

11.12 Channel Errors and Fading

Until now, we have assumed that all transmission attempts succeed ùë§.ùëù.1. In this section, we consider a system similar to the one described in [TE93]. In addition to the system described in Sec. 2, we also specify that every transmission from queue ùëñ succeeds with probability ùëùùëñ independent of all other transmissions. SpeciÔ¨Åcally, fading or transmission errors are independent across time slots. This necessitates a revision of Eqn. 2, provided in Eqn. (63) wherein the random variables ùê∂ùëñ (ùë°), that represent the fade state of the channel between node ùëñ and the receiver, are modelled as Bernoulli random variables i.i.d across time and independent across queues.

ùëÑùëñ (ùë° + 1) = (ùëÑùëñ (ùë°) ‚àí ùê∂ùëñ (ùë°)ùê∑ùëñ (ùë°))+ + ùê¥ùëñ (ùë° + 1),

ùëÑùëñ (0) = ùê¥ùëñ (0).

(63)

The coeÔ¨Écient of ùê∑ùëñ (ùë°) in (63) is ‚àíùê∂ùëñ (ùë°) ‚àà {0, ‚àí1}, meaning Queue ùëñ‚Äôs transmissions are assumed to succeed

whenever it is scheduled (ùê∑ùëñ (ùë°) = 1) and its channel is ‚ÄúON‚Äù (ùê∂ùëñ (ùë°) = 1). We assume the system only gets

to know whether a transmission succeeded or not at the end of a slot and has no knowledge of the current

channel state at the scheduling instants. Since each packet at Queue ùëñ takes, on the average, 1/ùëùùëñ slots to

be transmitted (i.e., its service time is Geometric with mean 1/ùëùùëñ), the capacity region of such a system is

given by

ùëÅ

Œõ :=

ùùÄ

‚àà

ùëÅ
R+

‚àëÔ∏Å ùúÜùëñ

<1

,

(64)

ùëñ=1 ùëùùëñ

It can be shown that the proof of Prop. 2 remains valid even when the service time of Queue ùëñ is ùêµùëñ and
ùëñùëÅ=1 ùúÜùëñEùêµùëñ < 1. Setting Eùêµùëñ = ùëù1ùëñ we see that the LEQ policy, clearly, is still throughput optimal. Note that the LEQ scheduler does not need to know the fading probabilities {ùëù1, ùëù2, ¬∑ ¬∑ ¬∑ , ùëùùëÅ } to stabilize the system.

11.13 Handling Alarm TraÔ¨Éc: The QZMACùëé protocol
Alarm traÔ¨Éc is particularly important in in-network processing, wherein the data generated by the sensors is partially processed within the network before reaching the sink etc. [LRZ03, YG02, YHE02]. This is done, as mentioned earlier, to detect abnormal behavior in the processes begin monitored by the WSN and when such conditions are detected, the network generates alarm packets. To study the eÔ¨Äects of applications generating alarm packets that need to be delivered with utmost priority, we Ô¨Årst modify the system described in Sec. 2. Instead of a single arrival stream, every queue now has two arrival streams. One carrying non alarm traÔ¨Éc (which we will call data traÔ¨Éc) and another carrying alarm packets. The Bernoulli ùúÜùëñ input process is split (in a memoryless manner) with a fraction 1 ‚àí ùõºùëñ entering the data stream and a fraction ùõºùëñ entering the alarm packet stream. Given that alarm packets are generated very rarely ùõºùëñ is much smaller than 1 ‚àí ùõºùëñ. In this case, we modify QZMAC as follows. We include an alarm minislot (ùëáùëé) at the beginning of every slot. Queues with alarm packets can use this slot to send out a high power jamming signal to inform the others that alarm packets are in the system. With this, we modify QZMAC to accommodate such traÔ¨Éc and call the resulting protocol QZMACùëé. So, at the beginning of slot ùë°
‚Ä¢ The slot begins with the alarm minislot ùëáùëé. Every queue that has an alarm packet sends out a jam signal.
‚Ä¢ If the queues do not sense any power in ùëáùëé, QZMACùëé operates exactly like QZMAC in slot ùë°.
‚Ä¢ If the queues do sense power in ùëáùëé, normal operation according to QZMAC is suspended for slot ùë°.

53

ùê¥1 (ùë°) ùê¥2 (ùë°)

ùê∫ùëíùëú [ùëã ] /ùê∑/1

ùê¥ùëÅ (ùë°) (a) Operation of the idealized full knowledge scheduler.

ùê¥1(ùëé) (ùë°) ùê¥2(ùëé) (ùë°) ùê¥ùëÅ (ùë°)
ùê¥1 (ùë°) ùê¥2 (ùë°) ùê¥ùëÅ (ùë°)

Alarm Packets

Higher Priority

Data Packets

Lower Priority (Serve only if alarm queue is empty)

(b) Operation of the idealized full knowledge scheduler with pri-

ority service for alarm packets. With alarm traÔ¨Éc, it becomes a

priority queue.

(
ùê¥

ùëé

)

(

ùë°

)

is the alarm packet entering queue ùëñ at

ùëñ

time t.

Figure 18: Operation of the idealized full knowledge scheduler with priority service for alarm packets.

‚Äì All queues with alarm packets back oÔ¨Ä as usual over {ùëáùëé + ùëáùëù + 1, ¬∑ ¬∑ ¬∑ , ùëáùëé + ùëáùëù + ùëáùëê } and if a winner emerges, it transmits its alarm packet.
‚Äì If no winner emerges, the system still has alarm packets, which means the protocol goes into alarm mode in slot ùë° + 1 as well.
‚Äì This continues until there are no alarm packets left in the system.

11.13.1 Performance of QZMAC with Alarm TraÔ¨Éc
As can be seen from Fig. 19a, when alarm traÔ¨Éc is light QZMACùëé provides the same delay to alarm packets as the full knowledge scheduler (the plain red and plan blue curves overlap signiÔ¨Åcantly). This is because alarm packets are given maximum priority in QZMACùëé. Queues with alarm packets contend for the channel and since their arrival rate (ùõºùëñùúÜùëñ) is small, these packets essentially see a service time of 1 slot. Moreover, the delay to data traÔ¨Éc (blue-with-diamonds curve) is comparable to that without any alarm traÔ¨Éc (dashed green curve), i.e., plain QZMAC. However, if the alarm traÔ¨Éc load becomes signiÔ¨Åcant compared to data traÔ¨Éc, the performance delivered to alarm packets (solid red curve at the bottom of Fig. 19b) is not aÔ¨Äected much due to priority queueing (this delay does show an increase near saturation from 1.005 slots to 1.357 slots, but this is still acceptable). However, the delay of data packets (blue-with-diamonds curve) degrades considerably and, as Fig. 19b shows, is much worse than that of QZMAC without any alarm traÔ¨Éc (dashed green curve). The curves in red are obtained by the full-knowledge scheduler with priorities (see Fig. 18b).

11.14 EÔ¨Äects of Nonidealities in Clear Channel Assessment
As mentioned earlier, in standard hypothesis testing parlance, the event when a CCA fails despite there being no activity on the channel is called a ‚ÄúFale Alarm,‚Äù while the event when the CCA is successful even when a node in the network is transmitting is called a ‚ÄúMiss.‚Äù We denote the corresponding probabilities by ùëùùêπ ùê¥ and ùëùùëöùëñùë†ùë† respectively. Our extensive experimentation, as described in Sec. 8, has revealed the following facts

54

Symmetric system with 30 queues (Œ± = 1%) Geo[X]/D/1 (without alarm traffic) Geo[X]/D/1 (alarm) Geo[X]/D/1 (data) QZMAC (alarm)
a QZMAC (data)
a QZMAC (without alarm traffic) Geo[X]/D/1 (without alarm traffic); black curve
Geo[X]/D/1 (data); red curve
QZMAC (alarm) overlaps with Geo[X]/D/1 (alarm) a

0.005

0.01

0.015

0.02

Œª (pkts/slot)

0.025

0.03

Delay (slots)

90 80 70 60 50 40 30 20 10
0 0

Symmetric system with 30 queues (Œ± = 33%)
Geo[X]/D/1 (without alarm traffic) Geo[X]/D/1 (alarm) Geo[X]/D/1 (data) QZMAC (alarm)
a QZMAC (data)
a QZMAC (without alarm traffic)
QZMAC (alarm) overlaps with Geo[X]/D/1 (alarm) a

0.005

0.01

0.015

0.02

Œª (pkts/slot)

0.025

0.03

0.035

(a) Performance of QZMACùëé with ùõºùëñ = 0.01 for all ùëñ, i.e., 1% (b) Performance of QZMACùëé with ùõºùëñ = 0.33 for all ùëñ, i.e., 33%

alarm traÔ¨Éc.

alarm traÔ¨Éc.

Figure 19: Performance of QZMACùëé with diÔ¨Äerent alarm traÔ¨Éc arrival rates.

‚Ä¢ For networks with diameter up to 8 meters, ùëùùêπ ùê¥ ‚âà 0. This happens because the noise Ô¨Çoor of modern sensors is low enough (-110 dBm for a 2MHz bandwidth) that no CCA failure triggers when the channel is free, and
‚Ä¢ In any given time slot (not minislot), at most one CCA ‚ÄúMiss‚Äù occurs.
Therefore, going forward, our analysis will assume that only ‚ÄúMiss‚Äù events occur and at most one node‚Äôs CCA can register a spurious failure in any time slot. Table 2 illustrates the three types of misalignment that can occur. In the sequel, we will refer to them as ‚ÄúM1,‚Äù ‚ÄúM2‚Äù and ‚ÄúM3‚Äù errors. We now describe them in detail and explain how each type is resolved. Recall that the node currently transmitting is called the incumbent and in time slot ùë°, ùëñ‚àó = ùëéùëüùëî ùëöùëéùë•ùëñ‚àà[ùëÅ ]ùëâùëñ (ùë°).
M1. This is the situation in slot ùë° + 2 in Table 2. The CCA of Node ùëó ( ùëó ‚â† ùëñ‚àó) succeeds, and it assumes that Node ùëñ‚àó will now transmit. However, upon decoding the header, the node discovers that the incumbent is nonempty, infers that a CCA Miss has occurred and corrects its copy of the V-vector.
M2. This is the situation in slot ùë° + 3 in Table 2. The ùëñ‚àó Node assumes that the incumbent is empty and, being nonempty, begins transmitting. The transmissions from the two nodes now collide and further provisions are now required within QZMAC to extricate the network from this state. The subroutine discussed in Sec. 7.2 is designed to accomplish this.
M3. This is the situation in slot ùë° in Table 2. This case is similar to M2., but now, Node ùëñ‚àó is empty. The node then decodes the header of the packet, detects the CCA miss and corrects its copy of the V-vector.
We thus see that two of the three potential types of misalignment can be detected and rectiÔ¨Åed quite easily, while only one necessitates modiÔ¨Åcation to QZMAC. In Sec. 7.2 we discuss this modiÔ¨Åcation. Furthermore, as the simulation results in Fig. 20 show, even at a miss rate ùëùùëöùëñùë†ùë† = 3 √ó 10‚àí4, which is 100 times larger than the measures miss probability, the largest increase in mean delay due to the modiÔ¨Åcation is 1.5266 slots (‚âà 4.32%), which is quite minimal.

55

Impact of CCA errors on QZMAC (symmetric system 30 queues) 120

p miss =3 10 -6

100

p =3 10 -4

miss

p miss =3 10 -3

80 p miss =3 10 -2

Perfect CCA

60

Expected Delay (slots)

40

20

0 0.025

0.026

0.027

0.028

0.029

0.03

(pkts/slot)

0.031

0.032

0.033

Figure 20: Comparing mean delay with and without CCA errors. We ran QZMAC for 5.25 √ó 106 slots with ùêæùë° = 5 slots. The
curve in red shows the performance of QZMAC with the RESET subroutine described in Sec. 7.2. Mean delay loss with due to imperfect CCA is at most 1.5266 slots (occurring at ùúÜ = 0.0325) even up to a CCA miss probability of 3 √ó 10‚àí4, which is quite
negligible.

56

