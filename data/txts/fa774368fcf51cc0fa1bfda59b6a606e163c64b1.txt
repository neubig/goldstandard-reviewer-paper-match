1
Control Synthesis for Permutation-Symmetric High-Dimensional Systems With Counting Constraints
Petter Nilsson, Member, IEEE, and Necmiye Ozay, Member, IEEE.

arXiv:1706.07863v2 [cs.SY] 10 Jul 2018

Abstract—General purpose correct-by-construction synthesis methods are limited to systems with low dimensionality or simple speciﬁcations. In this work we consider highly symmetrical counting problems and exploit the symmetry to synthesize provably correct controllers for systems with tens of thousands of states. The key ingredients of the solution are an aggregate abstraction procedure for mildly heterogeneous systems, and a formulation of counting constraints as linear inequalities.
I. INTRODUCTION
A UTOMATED controller synthesis for systems subject to an a priori given speciﬁcation is an attractive means of controller design; such correct-by-construction synthesis methods have attracted considerable interest in the past years [1]. However, all methods that are capable of solving general problems face fundamental limitations in terms of the system dimensionality and speciﬁcation complexity that can be handled. A large body of work resorts to abstraction procedures [2], where a ﬁnite representation of the system is obtained for which synthesis techniques for ﬁnite-state systems can be applied, but naive grid-based abstraction methods quickly run into the curse of dimensionality since, in general, the number of discrete states grows exponentially with system dimension. Other methods operate directly on a continuous state space but also “blow up” when the representation and treatment of high-dimensional sets become overwhelmingly expensive.
Ways to overcome these limitations in the abstraction step have been proposed. A large problem can sometimes be decomposed into several lower-dimensional problems [3], [4], where each subproblem is easier to solve. Such methods typically require the decomposition to be given, and that the coupling between the subproblems is relatively weak. Similarly, compositional abstraction procedures have been suggested as a method to construct abstractions with a size that does not scale exponentially with dimensionality [5], [6]; to capture the dynamics more accurately the abstract subsystems can be made partly overlapping [7]. These compositional approaches account for dynamic coupling between subsystems; as a contrast, we consider in this paper subsystems that are dynamically independent but coupled through a common speciﬁcation. Other work has exploited monotonicity [8], [9] to alleviate the curse of dimensionality when constructing an
P. Nilsson is with the Department of Mechanical and Civil Engineering at California Institute of Technology, Pasadena, CA USA. Email: pettni@caltech.edu. N. Ozay is with the Electrical Engineering and Computer Science Department at the University of Michigan, Ann Arbor, MI USA. Email: necmiye@umich.edu

abstraction, and it has been found that under certain stability conditions discretization can be circumvented completely by constructing an abstraction whose states are a ﬁnite-horizon input history [10], [11].
In this work we explore a different approach to tackle highdimensionality: exploitation of symmetries. The system we consider is the aggregate system consisting of N almosthomogeneous switched subsystems, where N can be very large. Due to homogeneity the overall system exhibits symmetries in the dynamics which can be leveraged to enable synthesis for a special type of symmetric constraints called counting constraints. Like many existing methods in the literature, our solution approach is abstraction-based, but with the crucial difference that we construct only one abstraction that is used for all subsystems, thus roughly reducing the number of states in the abstraction from O(1/ηNnx ) in the na¨ıve approach to O(1/ηnx ), where nx is the dimension of a single subsystem and η the precision. Our main contributions are not abstraction construction itself, but showing how a single abstraction can be utilized for control synthesis purposes.1 We are able to account for mild heterogeneity among the subsystems by assuming certain stability conditions. Utilizing a single abstraction for multiple subsystems allows us to synthesize controlled trajectories for problems of very high dimension that exhibit these symmetries—we demonstrate the method on a 10, 000-dimensional switched system with 210,000 modes. If there are several distinct classes of subsystems, one abstraction can be constructed for each class; and complexity increases linearly with the number of classes.
This work is motivated by the problem of scheduling of thermostatically controlled loads. Examples of TCLs include air conditioners, water heaters, refrigerators, etc., that operate around a temperature set point by switching between being on and off. TCL owners are typically indifferent to small temperature perturbations and accept temperatures in a range around their desired set point; this range is called the dead band. The idea behind TCL scheduling is that an electric utility company can leverage the implied ﬂexibility–which becomes meaningful for large collections of TCLs–to shape aggregate demand on the grid. Previous work has resulted in control algorithms based on broadcasting a universal set-point temperature [12], Markov chain bin models [13], [14], and
1We consider here the problem of synthesizing open-loop inﬁnite-horizon trajectories that satisfy counting constraints for a given initial condition, rather than the more general problem of synthesizing feedback controllers that enforce speciﬁcations for sets of initial conditions.

2

priority stacks [15], with the objective to track a power signal. However, they do not take into account any hard constraints on aggregate power consumption (i.e., the number of TCLs in mode on), which is crucial to do to avoid overloading the grid or underutilizing the power generated by renewable resources.
The fundamental problem in TCL scheduling is to simultaneously meet local safety constraints (i.e., maintain each TCL in its deadband), and global aggregate constraints. These constraints are special instances of counting constraints, which is the type of constraints we consider in this work. The TCL scheduling example will be used throughout the paper to motivate our discussion:
Example 1. Let {xn}n∈[N] be the states of a family of N switched systems of the following form:
d dt xn(t) = fσn(t) (xn(t), dn(t)) , σn(t) ∈ {on, off}, (1) where fon and foff are functions R × D → R for some bounded disturbance set D. For a desired dead band [a, a], and bounds [K, K] on the aggregate number of TCLs that are in mode on, synthesize switching protocols that enforce
xn(t) ∈ [a, a] for all n ∈ [N ] and all t ∈ R+, (2) For all t ∈ R+, at least K and at most K
(3) of the TCLs are in mode on.
Our approach can be seen as a marriage between “bin” abstraction previously used in the TCL literature, and schedule search via integer programming previously considered e.g. for intersection controllers [16]—generalized to arbitrary incrementally stable systems and an inﬁnite horizon.
A preliminary version of this work appeared in [17] where the mode-counting problem was introduced for homogeneous collections of systems. In this paper we generalize the counting problem to encompass both mode- and state-counting constraints; make the construction of the abstractions robust to model deviations—thus allowing mild heterogeneity; improve the rounding scheme that enables search for solutions via (noninteger) linear programming; and sharpen analytical results. A different extension of counting problems that allows for a richer class of speciﬁcations—temporal logic formulas deﬁned over counting propositions—was reported in [18].
A. Overview and Paper Structure
We give a high-level overview of the proposed solution approach to the problem of synthesizing controllers for large collections of systems with counting constraints, namely the counting problem as formally deﬁned in Section III. By exploiting the fact that the collection is almost homogeneous, we ﬁrst construct a single ﬁnite abstraction that approximates all the systems in the collection (Section IV). By means of this abstraction, we transform a continuous-state counting problem into a discrete one. We then treat this ﬁnite abstraction as a histogram where each abstract state corresponds to a bin of the histogram and counts the number of systems whose continuous-state is in some equivalence class associated with that abstract state (Section V). As the continuous states evolve in time according to the chosen control inputs, the counts on this histogram also evolve according to certain aggregate

dynamics. In particular, the evolution of the histogram can be represented as a constrained linear system over an integer lattice, and the counting constraints become linear constraints on the states and input of the aggregate system (Section V-A). This representation allows us to reduce the discrete counting problem to the feasibility of an integer linear program (Section V-C). Through this integer linear program, we search for inputs to steer the systems to periodic trajectories, captured by the cycles of the abstraction graph, so that the satisfaction of the counting constraints can be guaranteed indeﬁnitely. We then analyze this integer linear program and a relaxation of the integrality constraints, and their relation to the (in)feasibility of the original problem (Section VI). An extension of the theory to the multi-class setting is brieﬂy presented in Section VII. To highlight the applicability of the method, one numerical example and one application-motivated example are provided in Section VIII before the paper is summarized in Section IX. In an effort to improve readability, technical proofs are deferred to the appendix.

II. NOTATION AND PRELIMINARIES

We introduce some notation that is used throughout the

paper. The set of real numbers is denoted R, the set of positive

reals R+, and the set of non-negative integers N. To express a

ﬁnite set of positive integers, we write [N ] = {0, . . . , N − 1}.

The indicator function of a set X is denoted 1X (x) and is

equal to 1 if x ∈ X and to 0 otherwise. The identity function

on a set A is written as IdA. For two sets X and Y , we write

the Minkowski sum as X ⊕ Y = {x + y : x ∈ X, y ∈ Y }, and

the Minkowski difference X Y = {x : {x} ⊕ Y ⊂ X}. Set complement is denoted XC .

To denote the ﬂoor and ceiling of a number we write · and

· . We use the same notation for vectors, where the operations

are performed component-wise. We write the inﬁnity norm as

· ∞ and the 1-norm as · 1. The -ball in p−norm centered

at the point x is denoted as Bp(x, ) = {y : y−x p ≤ }. The

vector of all 1’s is written as 1. For a function f : X → R

with a ﬁnite domain we abuse notation and write f 1 =

x∈X |f (x)| for the “1-norm” of the ﬁnite image set. The function that is constantly equal to 0 is written 0.

Given an ODE ddt x(t) = fµ(x(t), d(t)), where d(t) is an uncontrolled input, the corresponding ﬂow operator is denoted

φµ(t, x, d) and has the properties that φµ(0, x, d) = x,

d dt

φ

µ

(t,

x,

d)

=

fµ(φµ(t, x, d), d(t)).

A

KL-function

β

:

R+ × R+ → R+ is characterized by being strictly increasing

from 0 in the ﬁrst argument and decreasingly converging to 0

in the second argument.

A. Transition Systems and Simulations
We employ the following deﬁnition for a transition system, which captures systems with both continuous and discrete state spaces.
Deﬁnition 1. A transition system (TS) is a tuple Σ = (Q, U, −→, Y ), where Q is a set of states, U a set of actions (inputs), −→⊂ Q × U × Q a transition relation, and Y : Q −→ Y an output function. We say that Σ is a deterministic ﬁnite transition system (DFTS) if i) transitions

3

are deterministic, i.e., if (q, µ, q ) ∈ −→ and (q, µ, q ) ∈ −→, then q = q , and ii) Q is ﬁnite.
For simplicity, existence of a transition (q, µ, q ) ∈−→ is written q −µ→ q . By a trajectory of a transition system, we mean a sequence x(0)x(1)x(2) . . . of states in Q with the
σ(s)
property that x(s) −→ x(s + 1) for some σ(s) ∈ U, for all s ∈ N.
In this paper we restrict attention to ﬁnite input sets U; such transition systems are obtained when a continuous-time switched system is time-discretized, and in this case the inputs are the modes of the switched system. A switching protocol is then a function π that generates control inputs from information about the current state2. A trajectory generated by a switching protocol π is a trajectory where σ(s) is generated by π.
For two systems with the same input space U and normed output space Y, we adopt the following notion of system bisimilarity [19].
Deﬁnition 2. Two transition systems (Q1, U , −→1, Y1) and (Q2, U , −→2, Y2) are -approximately bisimilar if there exists a relation R ⊂ Q1 × Q2 such that the sets R(q1) = {q2 : (q1, q2) ∈ R} and R−1(q2) = {q1 : (q1, q2) ∈ R} are nonempty for all q1, q2, and such that for all (q1, q2) ∈ R,
1) Y1(q1) − Y2(q2) ∞ ≤ , 2) if q1 −→µ 1 q1, there exists q2 −→µ 2 q2 s.t (q1, q2) ∈ R, 3) if q2 −→µ 2 q2, there exists q1 −→µ 1 q1 s.t (q1, q2) ∈ R.
B. Graphs
The following standard notions are used for a directed graph G = (Q, E) with node set Q and edge set E ⊂ Q × Q. A path in G is a list of edges (q0, q1)(q1, q2) . . . (qJ−1, qJ ). The distance between two nodes q0 and qJ is the length of the shortest path connecting the two. The graph diameter diam(G) is the longest distance between two nodes in the graph. If the ﬁrst and last nodes in a path are equal, i.e. qJ = q0, the path is a cycle. A cycle is simple if it visits every node at most one time. For a subset of nodes D ⊂ Q (or the corresponding subgraph, which we use interchangeably), it is said to be strongly connected if for each node pair (q, q ) ∈ D, there exists a path from q to q . Any directed graph can be decomposed into strongly connected components. The period of a subgraph D is the greatest common divisor of the lengths of all cycles in D. A subgraph D is called aperiodic if it has period one.
III. THE COUNTING PROBLEM
We ﬁrst deﬁne the concept of a counting constraint.
Deﬁnition 3. A counting constraint (X, R) for a collection of N subsystems numbered from 0 to N − 1, with the same state space Q and input space U , is a set X = XQ × XU with XQ ⊂ Q and XU ⊂ U , and a bound R. We say that the counting constraint is satisﬁed by state-input pairs (qn, µn),
2A switching protocol may also have internal memory states.

n ∈ [N ], if the number of pairs that fall in X is less than or equal to R:
1X (qn, µn) ≤ R.
n∈[N ]
Remark 1. For simplicity of exposition we restrict attention to counting sets in the form of a product of a set XQ in state space and a set XU in mode space. However, our solution method in Section V can handle more general subsets of Q×U.
This notion of constraint extends that in [17] by allowing X to be a subset of Q × U, instead of restricting it to a singleton subset of U. This generalization permits counting constraints that include the state space, as opposed to only counting the number of systems using each input (i.e., mode-counting).
Example 2. The TCL scheduling constraints (2) and (3) ﬁt into this class. Let the output space be equal to the state space, i.e. Y = R and Y (x) = x. Then the following counting constraints specify that the number of TCLs that are in mode on at time t should be in the interval [K, K]:

1R×{on} (xn(t), σn(t)) ≤ K,
n∈[N ]
(4) 1R×{off} (xn(t), σn(t)) ≤ N − K.
n∈[N ]
In addition, the dead band constraints (2) can be imposed by the counting constraint

1[a,a]C ×{on,off} (xn(t), σn(t)) ≤ 0.

(5)

n∈[N ]

The goal of this work is to synthesize controllers that satisfy counting constraints for a collection of switched systems with states xi(t), i ∈ [N ], governed by dynamics

d

dt xi(t) = fσi(t)(xi(t), di(t)), σi : R → U ,

(6)

for xi(t) ∈ Rnx and a disturbance signal di(t) assumed to take values in a set D. Although the system description is identical for all N systems in the family, the disturbance can

model mild heterogeneity such as modeling inaccuracies and parameter variations (e.g., di(t) = di) across subsystems.
We assume that the vector ﬁelds and the disturbance signals

satisfy standard assumptions for existence and uniqueness of

solutions. In addition, we assume that the vector ﬁelds exhibit

a certain form of stability [20].

Assumption 1. For each µ ∈ U, the vector ﬁeld fµ(x, d) is

C1 in x and continuous in d. Furthermore, the nominal system

d dt

x

=

fµ(x,

0)

is

forward-complete

and

incrementally

stable.

That is, there exists a KL-function βµ such that

φµ(t, x, 0) − φµ(t, y, 0) ∞ ≤ βµ ( x − y ∞, t) . (7)
Note that the vector ﬁeld fµ(x, d) being C1 in x implies that fµ(x, d) is Lipschitz in x (with some Lipschitz constant Kµ) when the states are constrained to a compact set.
Furthermore, we assume that the disturbance signal is continuous, and that its effect is bounded in an absolute sense.

4

Assumption 2. The disturbance signal d : R → D is continuous. Furthermore for all µ ∈ U, compared to the nominal vector ﬁelds without disturbance, the effect of the disturbance is less than δ¯µ:
fµ(x, d) − fµ(x, 0) ∞ ≤ δ¯µ, ∀d ∈ D.

of Problem 1 is referred to as the continuous-state counting problem. Since Στ is a non-deterministic, inﬁnite transition system, this is a difﬁcult problem to solve. In the following we construct a DFTS Στ,η that is approximately bisimilar to Στ , and relate the corresponding problem instances.

To leverage the notion of bisimilarity we consider the timesampled counterpart of (6), and deﬁne the problem we want to solve in terms of the resulting transition system rather than the ODE. An ODE solution where state counting constraints are violated in between samplings (but satisﬁed at sample instants) is still a valid solution to a time-sampled counting problem. If such inter-sample violations are unacceptable, the counting sets can be contracted by some margin determined by the dynamics to ensure satisfaction for all t ∈ R+ [21].
We proceed with a problem deﬁnition for transition systems. Consider a family of N identical subsystems with dynamics given by a transition system and some initial conditions {xn(0)}n∈[N]. The problem we seek to solve is the following:
Problem 1. Consider N subsystems, all governed by the same transition system ΣT S = (Q, U , −→, Y ), where U is ﬁnite, and assume that initial states {xn(0)}n∈[N] and L counting constraints {Xl, Rl}l∈[L] are given. Synthesize individual switching protocols {πn}n∈[N] such that the generated actions σn(0)σn(1)σn(2) . . . and trajectories xn(0)xn(1)xn(2) . . . for n ∈ [N ] satisfy the counting constraints

1Xl (xn(s), σn(s)) ≤ Rl, ∀s ∈ N, ∀l ∈ [L]. (8)
n∈[N ]
Let (N, ΣT S, {xn(0)}n∈[N], {Xl, Rl}l∈[L]) denote an instance of this problem.
Na¨ıvely, if Q is a nq-dimensional space, the overall system can be viewed as a N × nq-dimensional hybrid system with |U|N modes and is thus beyond the reach of standard synthesis techniques for large N . However, from a speciﬁcation point of view it does not matter which subsystems that contribute to the summation in (8), so Problem 1 exhibits subsystem permutation symmetry in its speciﬁcation. In addition, there is also subsystem permutation symmetry in the dynamics since all subsystem states are governed by the same transition system. As an implication there is no need to keep track of identities of individual subsystems—they are all equivalent from both a dynamics- as well as from a speciﬁcation-point of view. This symmetry (i.e., permutation invariance) is the key to solving large-scale counting problems.
In the following, we construct the time-sampled analogue of (6) in order to leverage the notion of bisimilarity. We also restrict the domain to a bounded set X ⊂ Rnx and let the τ -sampled counterpart of (6) conﬁned to X be

Στ = (X , U , −→, IdRd ),

(9)

τ

where x −µ→ x if and only if there exists d : [0, τ ] → D such
τ
that x = φµ(τ, x, d). The instance

(N, Στ , {xn(0)}n∈[N], {Xl, Rl}l∈[L])

(10)

IV. ABSTRACTING THE CONTINUOUS-STATE COUNTING PROBLEM
We ﬁrst recall the abstraction procedure from [22] to create a ﬁnite-state model of (6). Under the assumptions outlined above, we establish approximate bisimilarity between the continuous-state system and its ﬁnite-state abstraction, which enables us to state results in Section IV-B relating the solvability of the corresponding counting problems.

A. Abstraction Procedure
Consider a system of the form (6). For a state discretization parameter η > 0 we deﬁne an abstraction function κη : X → X as κη(x) = η · x/η + (η/2)1. This function is constant on hyperboxes of side η, and its image of the compact set X is ﬁnite. The abstraction function deﬁnes the (τ, η)-discretized counterpart of (6) as the transition system

Στ,η = κη(X ), U , −→, IdRd ,
τ,η

where q −µ→ q if and only if κη(φµ(τ, q, 0)) = q .
τ,η
The domain X is partitioned into uniform boxes of size η that represent discrete states, and transitions are established by simulating each mode, without disturbance, during a time τ , starting at the center of the boxes. As opposed to Στ , the resulting transition system Στ,η is ﬁnite and deterministic—for each state q and action µ there exists (at most) one successor state q . This makes the resulting abstract counting problem easier to solve. Similarly to a result from [22] we can now show that an abstraction constructed in this way is bisimilar to the time-sampled system (9) if a certain inequality holds.

Proposition 1. Assume that Assumptions 1 and 2 hold, i.e., for all µ ∈ U there are Lipschitz constants Kµ, KL-functions βµ, and disturbance effect bounds δµ associated with the modes of (6). Then, if for all µ ∈ U,

βµ( , τ ) + δµ

eKµτ − 1

η +≤

,

(11)

Kµ

2

the (τ, η)-discretized abstraction Στ,η and the τ -sampled system Στ are -approximately bisimilar.
The trajectories of -approximately bisimilar systems remain within distance of each other [19], and the additional term Kδµµ eKµτ − 1 in (11) introduces a robustness margin that allows the same abstraction to be bisimilar to a family of mildly heterogeneous subsystems. Using these facts we can establish relations between existence of solutions of the counting problem in the continuous-state and discrete-state settings.

5

B. Relations Between the Continuous-State and Discrete-State Counting Problems
If -approximate bisimilarity holds, trajectories of Στ,η and Στ are guaranteed to remain -close when initial states are -close and corresponding actions are chosen. Therefore, solvability of the counting problem is equivalent for the two up to an approximation margin . To make precise statements we introduce functions G± that expand (resp. contract) a counting set X = XX × XU in X -space before quantization:
G+ (XX × XU ) = κη XX ⊕ B∞(0, ) × XU , G− (XX × XU ) = κη XX B∞(0, ) × XU .
Now we can describe how solutions of the counting problem can be mapped between the time-sampled system Στ and the time-sampled and state-quantized system Στ,η.
Theorem 1. Let Στ and Στ,η be the time-sampled and time-sampled and state-quantized systems constructed from a system on the form (6), such that Στ and Στ,η are approximately bisimilar. Let κη be the abstraction function for Στ,η.
If there exists a solution to the instance
N, Στ,η, {κη(xn(0))}n∈[N], {G+ (Xl), Rl}l∈[L] (12)

of Problem 1, then there exists a solution to the instance

(N, Στ , {xn(0)}n∈[N], {Xl, Rl}l∈[L]).

(13)

An converse result can also be obtained, with the only difference that an additional correction η/2 is required to account for counting sets that are inﬂated by quantization.
Theorem 2. Under the same assumptions as in Theorem 1, if there is no solution to the instance

N, Στ,η, {κη(xn(0))}n∈[N],

G −(

+

η 2

)

(Xl

),

Rl

(14)

l∈[L]

of Problem 1, then there is no solution to the instance

N, Στ , {xn(0)}n∈[N], {Xl, Rl}l∈[L] .

(15)

Example 3 (continued). We proceed with the TCL scheduling problem by adjusting the constraints. The mode-counting constraints (4) lack a state space part, and are therefore not modiﬁed. However, by Theorem 1 the local safety constraints (5) must be expanded to

1[a+ ,a− ]C ×{on,off} (ξn(s), σn(s)) ≤ 0,
n∈[N ]
in order for a solution of the discrete-state instance to be mappable to a valid solution of the continuous-state instance of Problem 1. Similarly, by Theorem 2, if it can be shown that the discrete-state instance obtained by contracting the counting set to [a − − η/2, a + + η/2]C before discretizing is infeasible, then also the original problem is infeasible.

V. SOLVING THE DISCRETE-STATE COUNTING PROBLEM
Having described the reduction of a continuous-state instance of Problem 1 to a deterministic discrete-state instance, we proceed with a solution procedure for the latter. Consider a DFTS ΣDF T S = (Q, U , −→, Y ); it may be the result of a continuous-state abstraction or just represent a discrete structure onto which a counting problem is deﬁned. A DFTS can alternatively be viewed as a directed graph G = (Q, −→), where Q is a set of nodes and −→ is a set of edges, and each edge is labeled with an action from U. This dual viewpoint allows us to leverage graph-theoretical concepts to investigate the aggregate system; in the following we use the transition system viewpoint and the graph viewpoint interchangeably. We ﬁrst deﬁne aggregate dynamics which take the form of a constrained linear system. The solution method is then presented in the form of a linear feasibility problem over aggregate states.

A. Aggregate Dynamics as a Linear System
Consider a total of N subsystems whose dynamics are governed by a DFTS ΣDF T S = (Q, U , −→, Y ).
We introduce |Q| aggregate states labeled wq for q ∈ Q, that describe the number of individual systems that are at state q. By also introducing control actions rqµ that represent the number of systems at state q using action µ, the aggregate dynamics can be written as

wq(s + 1) =

rqµ (s), q ∈ Q,

(16)

µ∈U q ∈Nqµ

where Nqµ = q ∈ Q : q −µ→ q is the set of predecessors of q under the action µ. We constrain the control actions rqµ such that for all µ ∈ U,

rqµ(s) ≥ 0,

rqµ(s) = wq(s),

(17)

µ∈U

which ensures the continued positivity of the states: wq(s + 1) ≥ 0 for q ∈ Q. Furthermore, the invariant w(s) 1 = N holds over time, where N is the total number of subsystems.
In the following, we use the compact notation

Γ : w(s + 1) = Br(s),

(18)

to denote this system, where B is composed of the incidence matrices Aµ, µ ∈ U of the system graph. The state space W and (state-dependent) admissible control set R of this system are then
W = w ∈ N|Q| : w 1 = N ,
R(w) = r ∈ N|Q||U| : (17) holds for (w, r) .

When the discrete-state counting problem is obtained via the abstraction procedure in Section IV, the aggregate dynamics (16) can be seen as a time-varying histogram, where each bin in the histogram represents the number of subsystems in a given area of the state space, as illustrated in Fig. 1.
Counting constraints become linear constraints on these aggregate states, so our problem can be rephrased as a

6

wq

X 4 3

2

1

0

q4

q5

q6

q7

q0

q1

q2

q3

Fig. 1. Illustration of how the aggregate dynamics can be interpreted as a time-
varying histogram. The continuous state space X is partitioned into abstract
states q0, . . . , q7, and the aggregate states wq count the number of subsystems (black dots) present in each abstract state. In this example, wq0 = 1 and wq4 = 4, since there is one subsystem in q0 and four subsystems in q4. As time evolves, the subsystems move around in X , and the aggregate states
follow the dynamics (16).

linear feasibility problem. However, the feasibility problem is inﬁnite-dimensional since we are searching for solutiontrajectories over an inﬁnite horizon. To limit the search to a ﬁnite-dimensional space we consider solutions that consist of a ﬁnite preﬁx trajectory and a periodic sufﬁx trajectory. While the preﬁx trajectory is just a trajectory of the aggregate dynamics, we consider sufﬁx trajectories that are deﬁned in terms of cycle assignments.
B. Cycle assignments
We consider cycles C of the form
C = (q0, µ0, q1)(q1, µ1, q2) . . . (qI−1, µI−1, q0), (19)
of length given by |C| = I, where (qi, µi, qi+1) ∈−→. A cycle assignment assigns “weights” (or numbers) of subsystems to each node along a cycle. If the graph represents an abstraction, the assignment counts the number of subsystems whose continuous states are in the vicinity of the abstract states on this cycle.
Deﬁnition 4. An assignment to a cycle C is a function α : [|C|] → R+. If α(i) ∈ N for all i ∈ [|C|], α is an integer assignment.
For now we will only be concerned with integer assignments that represent a number of subsystems. However, later in the paper we will study relaxed non-integer solutions consisting of assignments that are not necessarily integral.
An assignment assigns subsystems to a cycle, so that the state of a subsystem circulates along the abstract states on this cycle as time progresses (provided that the appropriate actions are chosen). The movement corresponds to a circular shift of the assignment.
Deﬁnition 5. For an assignment α we deﬁne its s-step circulation, denoted α s : [|C|] → R+, as the shifted function
α s(i) = α ((i − s) mod |C|) .
The periodicity is manifested by the relation α (|C|+s) = α s. To capture how counting quantities vary during the circulation we introduce the following notation for the matching of a cycle and a circulated assignment.

q4 2 µ4

q3 µ3
3
µ2

q4 3 µ4

q3 µ3
4
µ2

6 µ0 5 µ1 4

q0

q1

q2

X

2 µ0 6 µ1 5

q0

q1

q2

X

Fig. 2. Illustration of how an assignment α = [6, 5, 4, 3, 2] circulating in a
cycle C = (q0, µ0, q1) . . . (q4, µ4, q0) contributes to a counting set X = {(q1, µ1), (q2, µ2), (q3, µ3)}. When the assignment is unshifted (left), the X-count is C, α X = 5 + 4 + 3 = 12, and when the assignment has circulated one step, the X-count becomes C, α 1 X = 6 + 5 + 4 = 15.

Deﬁnition 6. For a cycle C and an assignment α : [|C|] → R+ the X-count at time s of a counting set X is deﬁned as

C, α s X =
i∈[|C |]

α s(i) 0

if (qi, µi) ∈ X, (20) otherwise.

If the cycle C includes elements from a set X coming from a counting constraint, (20) counts the number of subsystems contributing to the counting constraint at time s, assuming that the subsystems make up the assignment α at time zero and circulate in the cycle C. The concept is illustrated in Fig. 2.
Next we introduce a function that returns the highest count over all circulations for given cycle-assignment pairs.

Deﬁnition 7. The maximal X-count for a cycle C with assignment α, denoted maxcntX (C, α), is the maximal number of subsystems simultaneously in X when α is circulated around C:
maxcntX (C, α) = max C, α s X .
s∈N
The maximal X-count can be computed as the maximum entry in a matrix-vector product maxcntX (C, α) =
BCX α ∞, where BCX ∈ {0, 1}|C|×|C| is a circulant binary matrix.

Example 4. Going back to cycle and assignment in Fig. 2, it can be seen that the maximal X-count occurs for s = 1, and that maxcntX (C, α) = 15. The same value is obtained as the
inﬁnity norm of the matrix-vector product

0 1 1 1 0 6 12

1 1 1 0 0 5 15

BCX α ∞ =

 1

1

0

0

  1 4

=

 13

= 15,



   

1 0 0 1 1 3 11

00111 2 ∞ 9 ∞

where the ﬁrst row of the matrix has ones at positions in C corresponding to states in X (i.e. q1, q2, and q3), and the remaining rows are shifted to form a circulant matrix.

Our solution method to the counting problems requires consideration of multiple assignments that circulate in different cycles. For this reason we introduce the joint maximal count of assignments to cycles.

Deﬁnition 8. The maximal joint X-count for a set of cycles {Cj}j∈J and a matching set of assignments {αj}j∈J , denoted

7

maxcntX ({Cj}j∈J , {αj}j∈J ), is the maximal number of subsystems simultaneously in X when the assignments {αj}j∈J are synchronously circulated around the cycles {Cj}j∈J :

maxcntX ({Cj }j∈J , {αj }j∈J ) = max

Cj , αj s X .

s∈N

j∈J

Also the maximal joint X-count can be expressed as the maximal element in a sum of matrix-vector products.

Proposition 2. The maximal joint X-count satisﬁes

maxcntX({Cj }j∈J , {αj}j∈J )=

(1kj⊗BCXj )αj , (21)

j∈J

∞

where kj = lcm ({|Cj|}j∈J ) /|Cj|, lcm is the least common multiple, 1k is the length k column vector of all ones, and ⊗ is the Kronecker product.

The matrices in (21) are large if the least common multiple is large, which illustrates that relative assignment circulations must be taken into account. We elaborate further on these matters, and how they are connected to graph periodicity, in Section V-D below.

C. Solution to the Discrete-State Counting Problem Consider now a problem instance

(N, ΣDF T S , {ξn(0)}n∈[N], {Xl, Rl}l∈[L])

(22)

and let w(0) be the aggregate initial state

wq(0) = 1 if ξn(0) = q, (23) n∈[N] 0 otherwise.
We restrict attention to solutions of a particular form; it is shown in later sections that this is without loss of generality.

Deﬁnition 9. A trajectory for an aggregate initial state w(0) is of preﬁx-sufﬁx type if it consists of a ﬁnite number of inputs r(0), . . . , r(T − 1), and a set of cycles {Cj}j∈J with assignments {αj}j∈J such that the cycles are populated with their respective cycle assignments at time T .

Given aggregate initial states w(0), a set {Cj}j∈[J] of cycles in G, and a preﬁx horizon T , preﬁx-sufﬁx trajectories can be extracted from feasible points of the following linear feasibility problem:

ﬁnd α0, . . . , αJ−1 (cycle assignments),

r(0), . . . , r(T − 1) (aggregate inputs),

w(1), . . . , w(T ) (aggregate states),

s.t.

1Xl (q, µ) rqµ(s) ≤ Rl, s ∈ [T ], l ∈ [L],

q∈Q µ∈U

maxcntXl ({Cj }j∈J , {αj }j∈J ) ≤ Rl, l ∈ [L],

wq(T ) =

Cj , αj {q}×U ,

q ∈ Q,

j ∈[J ]

w(s + 1) = Br(s),

s ∈ [T ],

rqµ(s) = wq(s),
µ∈U
rqµ(s) ≥ 0,

s ∈ [T ], q ∈ Q, s ∈ [T ], q ∈ Q, µ ∈ U.

(24a) (24b) (24c)
(24d) (24e) (24f)

The constraints (24a) and (24b) enforce counting constraints in the preﬁx and sufﬁx phases, and (24c) ensures that the preﬁx and sufﬁx phases are adequately connected. The remaining constraints (24d)-(24f) certify that the preﬁx trajectory is dynamically feasible with respect to (16).
The number of variables and (in)equalities in (24) are O(T |Q||U | + j∈[J] |Cj|) and O (LT + L lcm ({|Cj|}j∈J ) + T |Q|), respectively (not counting positivity constraints that solvers handle easily). Crucially, these numbers do not depend on the total number of subsystems N which makes the approach suitable for large N and moderate-sized graphs.
The set {Cj}j∈J of cycles is an input to the optimization problem (24); the solver selects good cycles within this set by setting the assignments of the rest to zero. Section VI presents results regarding when an input cycle set is “sufﬁciently rich” not to compromise the existence of solutions. On the other hand, in practice, we ﬁnd that randomly sampling a set of cycles is sufﬁcient for feasibility in many problems.
D. Size Reductions of the Linear Program
As we point out next, there are certain ways to further decrease the number of variables and/or inequalities—sometimes without loss of generality.
First of all, state-mode pairs in G with mandated 0-count can be pruned from G to decrease the number of aggregate variables. Speciﬁcally, we can construct a pruned graph G˜ in the following way: if (q, µ) ∈ Xl and Rl = 0, then remove the action µ at q. If this results in nodes in G˜ with no outgoing edges, prune these nodes together with incoming edges and repeat until all nodes have at least one valid action. This procedure is equivalent to ﬁnding the largest controlledinvariant set contained in XlC .
Secondly, the following result drastically reduces the number of sufﬁx counting constraint inequalities in (24b).
Proposition 3. The joint X-count for two cycles C0 and C1 with co-prime length, i.e. gcd(|C0|, |C1|) = 1, can be computed as
maxcntX ({C0, C1}, {α0, α1}) = maxcntX (C0, α0) + maxcntX (C1, α1) .
Proof. If |C0| and |C1| are coprime, by the Chinese Remainder Theorem [23], the equations k1 = s mod |C1| and k2 = s mod |C2| have a unique solution s < |C0||C1| for every pair k1 < |C1|, k2 < |C2|. It follows that every circulation of α0 in C0 at some point coincides with every circulation of α1 in C1; hence the maximal joint X-count is equal to the sum of individual maximal X-counts for the two cycles.
The proof illustrates that if there is no periodicity, every relative assignment position will eventually be attained, including the worst-case relative assignment position which is exactly the combined worst-case absolute positions of individual cycles. However, in the presence of periodicity only a subset of all relative positions will be attained and representing the worst-case within this subset is not as straight-forward.

8

More generally, if the cycle set can be partitioned into
sets of cycles with mutually co-prime length, the number of
inequalities can be reduced. That is, for sets of cycles {Cj}j∈J and {Cj }j ∈J with the property that gcd(|Cj|, |Cj |) = 1 for all pairs j ∈ J, j ∈ J , it holds that

maxcntX ({Cj }j∈J∪J , {αj }j∈J∪J )

= maxcntX ({Cj }j∈J , {αj }j∈J )

(25)

+ maxcntX ({Cj }j∈J , {αj }j∈J ) .

Example 5. To exemplify this reduction, consider a set of cycles with lengths ranging from 2 to 20. We have lcm([21]) = 232792560 and lcm([21] \ {11, 13, 17, 19}) + 11 + 13 + 17 + 19 = 5100. The number 232792560 is the number of inequalities in the na¨ıve approach (21), which by (25) can be drastically reduced to 5100 if the cycles of prime lengths 11, 13, 17, and 19 are considered separately.

If the number of constraints is still prohibitively large, it can be replaced by a conservative constraint as follows.

Remark 2. The constraint (24b) can be substituted by the conservative constraint

maxcntXl ({Cj }j:|Cj|=i, {αj }j:|Cj|=i) ≤ Rl,
i∈N

∀l ∈ [L],

which groups cycles by cycle length i and disregards effects
from periodicity. The number of constraints in this case be-
comes L(1 + j∈J {|Cj|}) 1) instead of L lcm ({|Cj|}j∈J ), where j∈J {|Cj|} is the set of cycle lengths without repetition.

While the total number of subsystems N does not impact the number of inequalities or constraints, it might affect the performance of integer linear program solvers since the number of candidate integer points grows with N . In addition, the converse results in Section VI depend on N —in order to prove infeasiblity of the problem very large horizons T and/or cycle sets may be required. If N is prohibitively large for this purpose it can be scaled down if a certain divisibility condition holds: if there is a common divisor S that divides wq(0) for all q ∈ Q, and that divides Rl for all l ∈ [L], then there is a 1-1 correspondence between solutions of (24) and solutions of its analogue obtained from the substitutions w(0) → w(0)/S and Rl → Rl/S. The correspondence simply consists in scaling r, w, and the assignments α with the same S.

E. Control strategy extraction
We conclude the section by giving a switching protocol that solves the instance (22) from a feasible solution of (24).
Theorem 3. If {r(s)}s∈[T ], {w(s)}s∈[T +1], {αj }j∈[J] is a feasible solution of (24), then input selection according to the switching protocol in Algorithm 1 is recursively feasible, and solves the instance (22).
Remark 3. The switching protocol in Algorithm 1 depends only on the current states {ξn(s)}n∈[N] and on auxiliary information from the solution of (24). However, for implementation central coordination is required at each time step. The coordination requirement can be relaxed by simulating the system

Algorithm 1: Switching protocol.

Data: Time s, current state ξn(s) for n ∈ [N ]

Result: Switching signals σn(s) for n ∈ [N ]

1 if s < T then

2 Select σn(s) s.t. for all q ∈ Q, µ ∈ U ; 1{(q,µ)} (ξn(s), σn(s)) = rqµ(s);
n∈[N ]

3 else

4 Select σn(s) s.t. for all q ∈ Q, µ ∈ U ;

n∈[N] 1{(q,µ)} (ξn(s), σn(s)) =

j ∈[J ]

Cj , αj s−T

{(q,µ)}
;

5 end

up to time T and assigning an individual preﬁx and sufﬁx to each subsystem. Then decentralized open-loop controllers can be constructed that realize these individual preﬁx-sufﬁx paths and mimic the performance of the centralized protocol without communication requirements.
VI. ANALYSIS OF THE PROPOSED LINEAR PROGRAM
Theorem 3 establishes that solving (24) provides a correct solution to a deterministic discrete instance of Problem 1. We now discuss completeness of the solution approach and specify the information that can be obtained from (in)feasibility of (24) when it is solved as an integer linear program, and when integer constraints are relaxed to obtain more efﬁciently solvable linear programs. Table I summarizes the results of this section.
A. Graph Properties and Aggregate Controllability
We start by connecting properties of the induced graph G = (Q, −→) to a notion of reachability in the aggregate dynamics (18). These results are used in the proof of Theorem 6 below, but are also interesting in their own right since they admit a characterization of reachability in the aggregate picture.
We ﬁrst deﬁne a concept of controllability on a subset of nodes D ⊂ Q for the aggregate dynamics Γ. Similarly as for controllability of linear systems on a subspace, controllability of Γ on D means that the system can be steered between any two aggregate states with support on D.
Deﬁnition 10. A subset of nodes D ⊂ Q is completely controllable for Γ if for any two states w, w with support3 on D such that w 1 = w 1, there exists a ﬁnite horizon T , states w(s), and controls r(s) satisfying (17), such that w(0) = w, w(T ) = w , and w(s + 1) = Br(s) for s ∈ [T ].
Theorem 4. If a strongly connected component D is aperiodic, it is completely controllable for Γ in (18).
Proof. It is known that the incidence matrix AD of an aperiodic, strongly connected graph D is primitive [24], i.e., there exists an integer T such that all entries of ATD are positive. This means that for each node pair (qj, ql), there exists a path of length T that connects them. Thus, by sending pjl systems
3A state w having support on D means that wq = 0 for q ∈ D.

9

TABLE I GIVEN FEASIBILITY OR INFEASIBLITY OF (24) IN VARIOUS CONFIGURATIONS, THIS TABLE LISTS THE INFERENCES THAT CAN BE MADE ACCORDING TO
RESULTS IN SECTION VI.

LP/ILP
ILP LP ILP
LP

Feasible?
Yes Yes No
No with -relaxation

Cycle set
Any Any C : |C| ≤ |Q| |Q|+NN−1 {C : C simple}

T
Any Any
|Q|+N −1 N
(diam(G)2 +1)N

Result
Solution Approximate solution No solution exists
No solution exists

Why?
Theorem 3 Theorem 7,8 Theorem 5
Theorem 6

q4

q0

q3

q1

q2

Fig. 3. A graph with two cycles and period 2. The cycles are {q0, q1, q2, q3} and {q0, q4} of length 2 and 4, respectively. Since gcd(2, 4) = 2, the period of the graph is 2.

along paths qj → ql such that l pjl = wj and j pjl = wl, the state at time T is equal to w . We can deﬁne aggregate controls r(s) that realize these paths by switching the correct number of systems at each node over time.
In the case of periodicity, it is not possible to reach every state since the parity structure of the initial state is preserved along the trajectories. However, within this restriction, the system is still controllable in a certain sense. If a strongly connected component D has period P , its nodes can be labeled with a function LP : D → [P ] such that a node q1 with LP (q1) = p only has edges to nodes q2 with LP (q2) = (p+1) mod P . Let D0, . . . , DP −1 be the subsets of nodes induced by the equivalence relation q1 ∼ q2 iff LP (q1) = LP (q2).
Corollary 1. The subsets of nodes Dp for p ∈ [P ] as constructed above are completely controllable for Γ.
Proof. We can connect the nodes in Di with edges that correspond to paths of length P in D. By construction, the resulting graphs are aperiodic, so the previous result applies.
It is well known that if a discrete-time linear system is completely controllable, its reachable set for a time s ≥ n, where n is the system dimension, is the entire state-space; otherwise, it is an afﬁne subspace that depends on s and the initial state. The preceding results show a corresponding result for the aggregate dynamics Γ—a linear system with input constraints evolving on an integer lattice. The controllability in this setting is entirely characterized by the properties of the graph representing the abstraction. For the controllable case (aperiodic graph), the reachable set of Γ at a time s ≥ T , where T is the controllability horizon from the proof of Theorem 4, is the set of all positive integer-valued vectors w that satisfy w 1 = N . In case of periodicity with a period P , it is the intersection of this lattice set with an afﬁne subspace that depends on (s mod P ) and the parity structure of the initial state.

Example 6. Consider the graph in Figure 3, it consists of two cycles of length 2 and 4, so the period is 2. The two equivalence classes induced by the periodicity are {q0, q2} and {q1, q3, q4}; all subsystems in the ﬁrst class move to the second, and vice versa. Consider an initial state such that
wq0 (0) + wq2 (0) = c0, wq1 (0) + wq3 (0) + wq4 (0) = c1.
Due to periodicity, this parity structure is preserved in the sense that
wq0 (s) + wq2 (s) = c0, if s is even, c1, if s is odd,
and conversely for wq1 (s)+wq3 (s)+wq4 (s). However, within this restriction Corollary 1 implies that any assignment is reachable when s is large enough.

B. Converse Results
The ﬁrst result states that the restriction to preﬁx-sufﬁx form is without loss of generality, provided that the preﬁx horizon is sufﬁciently large, and that the sufﬁx cycle set is sufﬁciently rich.

Theorem 5. Suppose that there is a solution to the instance (22). Then there is a feasible solution to (24) with a preﬁx length T of at most |Q|+NN−1 and a sufﬁx consisting of cycles of length at most |Q| |Q|+NN−1 .
The upper bounds in Theorem 5 yield large feasibility problems; next we present a result that restricts the analysis to much smaller quantities. The key observation is that an assignment can be “averaged” over its cycle without violating any counting bounds. The averaging idea is illustrated in Fig. 4 and captured in the following deﬁnition.

Deﬁnition 11. For a cycle C, a graph period P dividing |C|, and total weights N0, . . . , NP −1, the P -average assignment α¯{Np}p∈[P ] is deﬁned as

N(i mod P ) α¯{Np}p∈[P ] (i) = |C|/P ,

∀i ∈ [|C|].

In the case P = 1, this assignment has a constant X-count for any cycle, more precisely;

C, α¯Ns0 X = = |NC0| C, 1 X (26)

for all s, where C, 1 X simply counts the number of nodeaction pairs in C that are in the counting set X. As a consequence, for any assignment α, it holds that

maxcntX C, α¯ α 1 ≤ maxcntX (C, α). (27)

10

i

012345

α 201432
α¯12 2 2 2 2 2 2 α¯{3,9} 1 3 1 3 1 3 α¯{2,4,6} 1 2 3 1 2 3

Fig. 4. Illustration of a non-average assignment α : [6] → N, and three averaged assignment with periods 1 (aperiodic), 2, and 3. All assignments have total weight 12, i.e. α 1 = α¯12 1 = α¯{3,6} 1 = α¯{2,4,6} 1 = 12. Note that average assignments are not necessarily integral.

In other words, if the averaged assignment for a given total weight does not satisfy counting bounds, no assignment does.
A more general result (Lemma 1 in the appendix) shows that a cyclic integer sufﬁx can be mapped into a (possibly non-integer) sufﬁx deﬁned on simple cycles via averaging. It turns out that these averaged assignments can be reached by an inﬁnitesimal relaxation of the counting bounds since they preserve the parity structure of the initial condition. The controllability results in Section VI-A do not take counting constraints into account; when such constraints are present they may conﬂict with controllability. Nevertheless, by introducing an arbitrarily small relaxation of the counting constraints we can ensure that controllability is preserved. The magnitude of the relaxation does however impact the worst-case time required to control the aggregate system to a new state.
Theorem 6. Suppose that there exists an integer solution to the instance (N, ΣDF T S, {ξn(0)}n∈[N], {Xl, Rl}l∈[L]). Let diam(G) be the diameter of the induced graph. Then, if every counting constraint (Xl, Rl) is relaxed with an absolute factor to (Xl, Rl + ), the non-integer version of the linear program (24) with preﬁx horizon (diam(G)2+1)N and the cycle set consisting of all simple cycles, is feasible.
C. Rounding of Non-Integer Solution
If the linear program (24) is too large to be solvable as an integer program it may still be possible to solve it using a standard LP solver and round the result to obtain an integer solution. One option is to use a probabilistic discrepancyminimizing rounding procedure (e.g. [25]) which allows speciﬁed relationships to be preserved after rounding; thus introducing a counting constraint violation but maintaining the validity of the solution (e.g. dynamics, preﬁx-sufﬁx connection). Here we instead propose a heuristic to round only the sufﬁx part of the solution and analyze its performance under certain assumptions on cycle structure. For a given integer sufﬁx, the preﬁx part of (24) can be solved to ﬁnd a matching preﬁx—a problem that is typically much smaller.
Counting constraints may be violated as a result of the rounding; we give bounds for the magnitude of the worstcase violation. Given an aperiodic graph and (non-integer) cycle-assignment pairs {Cj, αj}j∈[J] that satisfy the counting constraints, we propose the following rounding procedure:
Step 1: Assign an integer number of subsystems to each cycle that is close to the original weight, i.e., ﬁnd integers Nj s.t.
j∈[J] Nj = j∈[J] αj 1 and s.t. Nj is close to αj 1. This can easily be achieved in a way s.t. |Nj − αj 1| ≤ 1.

d

d

d

012345601
Fig. 5. Illustration of the pseudo-periodic assignment for |Cj | = 7, αj 1 = 3. The subsystems are ﬁrst placed in non-integer positions separated
by a distance d (open circles), and then rounded into integer positions (ﬁlled circles). The ﬁnal pseudo-periodic assignment is [1, 0, 1, 0, 1, 0, 0].

Step 2: Find individual integer assignments with total weight Nj that are close to the average assignments, i.e., ﬁnd integer assignments α˜j s.t. α˜j 1 = Nj and s.t. αj is close to α¯Nj .
To this end, we let κ1 and κ2 be the quotient and remainder when dividing Nj by |Cj|, i.e. κ1 = Nj/|Cj| and κ2 = Nj mod |Cj|. Then let d = |Cj|/κ2. We consider the pseudoperiodic assignment α˜j deﬁned as follows:
α˜j(i) = κ1 + 1, for i ∈ { dk }k∈[κ2] , (28) α˜j(i) = κ1, otherwise.
This assignment is pseudo-periodic in the sense that the 1’s are evenly distributed with distance d before they are rounded to integer points, as illustrated in Fig. 5. It is easy to see that
α˜j 1 = Nj . Step 3: Find a preﬁx using (24) that steers to {Cj, α˜j}j∈[J].
If the graph is periodic the rounding can be done so as to preserve the parity structure of the original solution and guarantee reachability, but the details are omitted here. Assuming aperiodicity, we want to compare the counting bounds for the rounded solution with the counting bounds for the original solution. First we give a result that assumes a certain structure of a cycle, namely that all nodes that contribute to the counting set X are placed in sequence in the cycle. Such structure is often present in practical examples, as connected counting regions tend to lead to consecutive parts in cycles.
Proposition 4. Let RCX = C, 1 X be the number of nodes in a cycle C that contribute to X-counting. If all such nodes are consecutive, i.e., (qi, µi) ∈ X for i ∈ [RCX ] and (qj, µj) ∈ X for j ∈ [|C|] \ [RCX ], then the rounding procedure (28) satisﬁes
maxcntX (Cj, α˜j) ≤ maxcntX (Cj, α¯Nj ) + 1.

Proof. When the assignment α˜j circulates in Cj, exactly RCX

contiguous indices of α˜j contribute to the X-count. We bound

the number of contributing indices with value κ1 + 1. Let

[

i0

,

i0

+

R

X C

−

1]

be

a

(circular)

sequence

representing

RCX

con-

tributing indices. Consider Fig. 5; any point that ends up in the

sequence after left-rounding must satisfy dk ∈ [i0, i0 + RCX ),

where k ∈ [κ2]. Since each left-closed, right-open interval of

length d captures exactly one point of the form dk, there are

at most RCX /d such points. Therefore by (26),

maxcntX (Cj , α˜j ) ≤ κ1RCX + RdCX ≤ κ1RCX + RdCX + 1

≤ RCX (κ |C | + κ ) +1 = maxcntX (C , α¯ ) + 1.

|Cj | 1 j

2

j Nj

Corollary 2. If CNjj has at most p X-segments (consecu-

tive nodes taking values in X), the rounding (28) satisﬁes maxcntX (Cj, α˜j) ≤ maxcntX (Cj, α¯Nj ) + p.

11

Proof. Follows from applying Proposition 4 to each of the p segments.

We now incorporate these results into a bound on the counting constraint violation in the overall rounding procedure. Again, this bound does not depend on the total number of subsystems N . The difference between the original counting bounds and their relaxed counterparts therefore becomes insigniﬁcant as N grows.

Theorem 7. For a given counting constraint (X, R) satisﬁed by {αj}j∈[J], the following bound holds for the overall sufﬁx rounding procedure

maxcntX (Cj, α˜j) ≤ R + J + pXj ,

j ∈[J ]

j ∈[J ]

where pXj is the number of X-segments in the j’th cycle. Thus the relaxed counting constraint (X, R + J + j∈[J] pXj ) is guaranteed to be satisﬁed by the rounded sufﬁx {α˜j}j∈[J].
Proof. By the rounding procedure, Corollary 2, and (27),
maxcntX (Cj, α˜j) ≤ maxcntX (Cj, α¯Nj ) + pXj ≤ maxcntX (Cj , α¯ αj 1 ) + 1 + pXj .
Noting that maxcntX (Cj, α¯ αj 1 ) ≤ maxcntX (Cj, αj) and summing over j ∈ [J] gives the result.

If the structure required in Proposition 4 is not present, the following is a worst-case bound on the counting constraint violation due to rounding.

Theorem 8. The rounding (28) satisﬁes

maxcntX (Cj, α˜j) ≤ maxcntX Cj, α¯N + |Cj| .

j

4

Proof. We assume that Nj < |Cj|, since any multiple of |Cj| can be assigned as the average assignment. The number of nodes contributing to the X-count is upper bounded by min(RCX , Nj), hence,

maxcntX (Cj, α˜j) − maxcntX Cj, α¯Nj

≤ min(RX , Nj) − Nj RX

C

|Cj | C

= |C | min RCX 1− Nj , Nj 1− RCX

j

|Cj |

|Cj| |Cj|

|Cj |

≤ |Cj| , 4

where the last step follows from maxa,b∈[0,1] min(ab, (1 − a)(1 − b)) = 1/4.

These rounding bounds can be precomputed (using all cycles used in the LP instead of all cycles with non-zero assignments) and the counting constraints can be strengthened accordingly to ensure that the original constraints are satisﬁed after rounding.

VII. EXTENSION TO STRONG HETEROGENEITY
Up until now we considered mild heterogeneity in the continuous dynamics, which allowed us to construct a single abstraction that captures all the possible behaviors. If there is signiﬁcant heterogeneity in the collection of subsystems, this

may no longer be possible while maintaining a good level of approximation.
To alleviate this shortcoming, we can extend our synthesis method to a multi-class setting where each subsystem belongs to a particular class, and each class has only mild heterogeneity among its members. One abstraction per class can then be constructed, and the counting problem can be solved jointly for the different classes. In addition, counting constraints can be extended to capture class identity. For instance, we can posit that at least R1 subsystems of class 1 be present in a given area, or guarantee that no more than R2 subsystems of class 2 are in a particular dynamic mode.
To formalize these ideas, consider H transition systems Σh = (Qh, U h, −→h, Y h) for h ∈ [H]. Then the multi-class counting problem is as follows:

Problem 2. Consider N subsystems divided in H classes

such that class h has Nh members, and h∈[H] Nh = N . Subsystems in class h are governed by the transition system

Σh. Assume that for all h ∈ [H], initial states {xhn(0)}n∈[Nh]

are given.

Given L counting constraints { h∈[H] Xlh, Rl}l∈[L] with

counting sets Xlh ⊂ Qh × U h, synthesize individual switch-

ing protocols {πnh}n∈[Nh] such that the generated actions

σ

h n

(0)σ

h n

(1)σ

h n

(2)

.

.

.

and

trajectories

x

h n

(0)x

h n

(1)x

h n

(2)

.

.

.

satisfy the counting constraints

1Xh xhn(s), σnh(s) ≤ Rl, l
h∈[H] n∈[Nh]

∀s ∈ N, ∀l ∈ [L].

The linear program (24) can easily be extended to the multi-class setting, at the cost of additional variables and constraints. Assuming similar abstraction parameters and cycle selections, a problem with two classes has roughly twice as many variables as a problem with a single class. The next section includes an example showcasing how a multi-class counting problem can account for parameter heterogeneity in a family of continuous-time systems.

VIII. EXAMPLES
We showcase the method on two examples; one numerical example and the TCL scheduling problem. The examples are computed with our prototype implementation available at https://github.com/pettni/mode-count, which uses Gurobi [26] as the underlying ILP solver.

A. Numerical Example Our ﬁrst example is the following non-linear system:
x˙ 1 = −2(x1 − u) + x2, x˙ 2 = −(x1 − u) − 2x2 − x32. (29) It can be shown that for a constant u the system is incrementally stable and that the KL-function β(r, t) = √2r exp −2 1 t
−1 −2 2 satisﬁes (7). We consider two modes µ1 and µ2 corresponding to the constant inputs u = −1 and u = 1.

12

0.55

X˜1 count

1 X1

X˜2 count

0.5

Xµ1 count

0.5 0

x2

0.45

0

10

20

30

40

50

t

Fig. 6. Fraction of total number of systems present in X˜1, X˜2 and Xµ1 over time. Whereas the sets Xµ1 and Xµ2 are mutually exclusive (the fractions sum to 1), the sets X˜1 and X˜2 are not due to the expansion to account for
approximate bisimilarity.

−0.5

−1

−1

−0.5

0

x1

X2

0.5

1

Fig. 7. Illustration of counting sets X1 and X2 together with selected cycles making up the sufﬁx solution.

We consider the domain X = {(x1, x2) : x1 ∈ [−2, 2], x2 ∈ [−1.5, 1.5]}. For a large N , we introduce mode-counting constraints (Xµ1 , 0.55N ) and (Xµ2 , 0.55N ) for Xms = X × {s} stating that at most 55% of the subsystems can use the same
dynamical mode at any given time. In addition we consider a balancing objective; namely that no more than 55% of the subsystems should be in one of the sets X1 = {(x1, x2) : x1 ≥ 0} or X2 = {(x1, x2) : x1 ≤ 0}; expressed by the counting constraints (X1, 0.55N ) and (X2, 0.55N ). Furthermore, we want all subsystems to repeatedly visit these two sets.
Using abstraction parameters η = 0.05, τ = 0.32 we obtain an abstraction with 4,941 states that is 0.1-approximately
bisimilar to the time-discretization of (29). In order to guar-
antee that the counting constraints are satisﬁed, we therefore need to expand the counting sets as X˜1 = {(x1, x2) : x1 ≥ −0.1} and X˜2 = {(x1, x2) : x1 ≤ 0.1}. We proceed by solving the discrete counting problem with randomized initial conditions and a horizon T = 10. We sampled 200 randomized cycles that visit both X˜1C and X˜2C , in order to achieve the second objective. We solved the problem for N = 10k for k = 2, . . . , 9; the solving times are shown in Table II
and illustrate that the difﬁculty of this problem is largely independent of N .

TABLE II AVERAGE SOLUTION TIMES OVER 10 RANDOMIZED TRIALS

N

102 103 104 105 106 107 108 109

Time (s) 7.8 11.1 12.0 12.8 11.5 13.2 13.0 11.0

Fig. 6 illustrates the number of systems that are in the counting sets over time in a trajectory, and Fig. 7 demonstrates some of the cycles that make up the sufﬁx part of the solution.

B. Application Example: TCL Scheduling
We use the following model for the dynamics of the temperature xn of an individual TCL [15]:
x˙ n(t) = −an (xn(t) − θna) − bnPnm1{on} (σn(t)) . (30)
We assume that there are two distinct populations of TCLs, i.e., that all sets of parameters (an, bn, θna, Pnm) are δ-close to one of two nominal parameter conﬁgurations. Each nominal parameter conﬁguration represents a mildly heterogeneous class (c.f. Section VII). The parameter values for the nominal

conﬁgurations are listed in Table III along with the abstraction parameters η and τ used for each class and the allowed deviation δ from these nominal values. These parameters result in ﬁnite abstraction with 1,600 and 1,200 states for the two classes, respectively.

TABLE III PARAMETER VALUES FOR THE TWO CLASSES OF SUBSYSTEMS. NOTE
THAT THE TIME DISCRETIZATIONS NEED TO BE IDENTICAL FOR
CONCURRENT EXECUTION.

Parameter
Nominal [a, b, θa, Pm] Space discretization η Time discretization τ Error bound δ

Class 1
[2, 2, 32, 5.6] 0.002 0.05 0.025

Class 2
[2.2, 2.2, 32, 5.9] 0.0015 0.05 0.025

It can easily be shown that the KL-function β(r, s) = re−san satisﬁes (7) with respect to (30). In addition, it satisﬁes the approximate bisimulation inequality (11) for an approximation level = 0.2 and using the Lipschitz constant an for (30); thus the results from Section IV-B apply. The constraints for the TCL problem have been introduced earlier in (4)-(5). We posit that all subsystems must remain in the temperature interval [21.3, 23.7]; taking the approximation into account this implies that the constraint for the discrete problem becomes xn(t) ∈ [21.5, 23.5].
We randomly selected initial conditions for 10,000 systems of each class, sampled 50 random cycles for each class4, and solved the ILP (24) for a preﬁx length of 20 steps (corresponding to one hour). We also introduced randomized additive model errors δn such that |δn| ≤ δ to represent mild in-class heterogeneity. Figure 8 shows simulated trajectory densities for two different mode-on-counts, one maximal count of 6,000, i.e. n∈[N] 1{on} (σn(t)) ∈ [0, 6000]; and one minimal count of 6,700, i.e. n∈[N] 1{on} (σn(t)) ∈ [6700, N ]. For comparison, the fundamental minimal upper bound is 5,595 and the fundamental maximal lower bound is 7,045 as computed from formulas in [27] that apply to a centralized full-state feedback coordinator with arbitrarily fast switching. While the objective here was not to ﬁnd the maximal ranges (which could be done by adding an objective function to (24)), the fundamental limits can not be attained due to approximation errors stemming from the approximate
4To promote diversity in the cycle sets, the cycles were selected in order to have different fractions of time in mode on.

13

24

Temp. [◦C]

23

22

21

0

1

2

3

4

5

24

Temp. [◦C]

23

22

21

0

1

2

3

4

5

Time [hrs]

Fig. 8. Density of TCLs in different parts of the temperature spectrum over time—blue parts represent regions with a larger fraction of the 20,000 subsystems. The state counting constraint (5) guarantees that no subsystem exits the interval [21.3, 23.7] which is marked with dashed lines. The ﬁrst hour represents the preﬁx part of the solution which steers the initial state to the periodic sufﬁx.

mode-on-count

10,000 5,000

0

1

2

3

4

5

Time [hrs]

Fig. 9. Number of TCLs in mode on during the two simulations. As can be seen, the lower bound of 6,700 is enforced for the upper (red) trajectory, while the upper bound 6,000 is enforced for the lower (blue) trajectory.

bisimulation, incomplete cycle selection, a minimal dwell time imposed by the time discretization, etc. Figure 9 shows modeon-counts during the same simulation for the two experiments. As can be seen, the imposed counting bounds are satisﬁed.
IX. CONCLUSION
This paper was concerned with control synthesis for very high-dimensional but permutation-symmetric systems subject to likewise symmetric counting constraints, and presented a scalable sound and (almost) complete solution to this problem. The main insight is to aggregate the individual subsystem dynamics as an integer linear system induced from an abstraction constructed for a single subsystem, thus avoiding abstraction of the entire state space. As we used an approximately bisimilar system as an abstraction, the same abstraction can represent not only identical subsystems (homogeneity) but also subsystems with slightly different parameters (i.e., almost symmetric, or mildly heterogeneous) by a slight change in the approximation factor. The control synthesis problem was then reduced to one of coordinating the number of subsystems that are in different parts of the discrete state-space of this abstraction. We characterized preﬁx-sufﬁx solutions as the feasible set of an integer linear program, and showed how to interpret (in)feasibility of the program both in the integer and non-integer case.
The results were demonstrated on a TCL scheduling problem including tens of thousands of subsystems. With the proposed approach, it is possible to impose hard constraints

on the overall power consumption of TCLs over an inﬁnite time horizon, to the best of our knowledge this is a ﬁrst in this domain. Counting constraints are also relevant in other application domains, including multi-agent planning and coordination as shown in [18].
Exploiting symmetries to achieve scalability in correct-byconstruction methods is a promising direction and we will explore other types of symmetries in our future work. Another interesting direction is to consider other types of abstractions, including non-deterministic ones, since not all systems admit ﬁnite bisimulations. Although the idea of an aggregate system can still be used in this case, one should either solve a robust uncertain ILP, which could lead to conservative results, or consider reactive feedback solutions, for which different synthesis techniques should be developed.
ACKNOWLEDGMENT
The authors would like to thank Johanna Mathieu for insightful discussions regarding TCL coordination problem. Petter Nilsson is supported by NSF grant CNS-1239037. Necmiye Ozay is supported in part by NSF grants CNS1446298 and ECCS-1553873, DARPA grant N66001-14-14045 and an Early Career Faculty grant from NASA’s Space Technology Research Grants Program.
REFERENCES
[1] C. Belta, B. Yordanov, and E. A. Gol, Formal Methods for Discrete-Time Dynamical Systems. Springer, 2017.
[2] P. Tabuada, Veriﬁcation and control of hybrid systems: a symbolic approach. Springer, 2009.
[3] C. Conte, C. N. Jones, M. Morari, and M. N. Zeilinger, “Distributed synthesis and stability of cooperative distributed model predictive control for linear systems,” Automatica, vol. 69, pp. 117–125, Jul. 2016.
[4] S. Smith, P. Nilsson, and N. Ozay, “Interdependence quantiﬁcation for compositional control synthesis: An application in vehicle safety systems,” in Proc. IEEE CDC, 2016, pp. 5700 – 5707.
[5] G. Pola, P. Pepe, and M. D. Di Benedetto, “Symbolic Models for Networks of Control Systems,” IEEE Transactions on Automatic Control, vol. 61, no. 11, pp. 3663–3668, 2016.
[6] ——, “Decentralized Supervisory Control of Networks of Nonlinear Control Systems,” IEEE Transactions on Automatic Control, 2017, early access. DOI 10.1109/TAC.2017.2775962.
[7] P.-J. Meyer, A. Girard, and E. Witrant, “Compositional Abstraction and Safety Synthesis using Overlapping Symbolic Models,” IEEE Transactions on Automatic Control, 2017, early access. DOI 10.1109/TAC.2017.2753039.
[8] S. Coogan and M. Arcak, “Efﬁcient ﬁnite abstraction of mixed monotone systems,” in Proc. HSCC, 2015, pp. 58–67.
[9] E. S. Kim, M. Arcak, and S. A. Seshia, “Directed speciﬁcations and assumption mining for monotone dynamical systems,” in Proc. HSCC, 2016, pp. 21–30.
[10] D. C. Tarraf, “Approximations for Control Design,” vol. 59, no. 12, pp. 3164–3177, 2014.
[11] M. Zamani, A. Abate, and A. Girard, “Symbolic models for stochastic switched systems: A discretization and a discretization-free approach,” Automatica, vol. 55, pp. 183–196, 2015.
[12] A. Ghaffari, S. Moura, and M. Krstic, “Modeling, Control, and Stability Analysis of Heterogeneous Thermostatically Controlled Load Populations Using Partial Differential Equations,” J. Dyn. Sys., Meas., Control, vol. 137, no. 10, p. 101009, 2015.
[13] S. Koch, J. L. Mathieu, and D. S. Callaway, “Modeling and control of aggregated heterogeneous thermostatically controlled loads for ancillary services,” in Proc. PSCC, 2011, pp. 1–7.
[14] S. Esmaeil Zadeh Soudjani and A. Abate, “Aggregation and control of populations of thermostatically controlled loads by formal abstractions,” IEEE Trans. Control Syst. Tech., vol. 23, no. 3, pp. 975–990, 2015.

14

[15] H. Hao, B. M. Sanandaji, K. Poolla, and T. L. Vincent, “Aggregate Flexibility of Thermostatically Controlled Loads,” IEEE Trans. Power Syst., vol. 30, no. 1, pp. 189–198, 2015.
[16] A. Colombo and D. Del Vecchio, “Least restrictive supervisors for intersection collision avoidance: A scheduling approach,” IEEE Trans. Autom. Control, vol. 60, no. 6, pp. 1515–1527, 2015.
[17] P. Nilsson and N. Ozay, “Control synthesis for large collections of systems with mode-counting constraints,” in Proc. HSCC, 2016, pp. 205–214.
[18] Y. E. Sahin, P. Nilsson, and N. Ozay, “Provably-correct coordination of large collections of agents with counting temporal logic constraints,” in Proc. ACM/IEEE ICCPS, 2017, pp. 249–258.
[19] A. Girard and G. J. Pappas, “Approximation Metrics for Discrete and Continuous Systems,” IEEE Trans. Autom. Control, vol. 52, no. 5, pp. 782–798, 2007.
[20] D. Angeli, “A Lyapunov approach to the incremental stability properties,” IEEE Trans. Autom. Control, vol. 47, no. 3, pp. 410–421, 2002.
[21] J. Liu and N. Ozay, “Finite abstractions with robustness margins for temporal logic-based control synthesis,” Nonlinear Analysis: Hybrid Systems, vol. 22, pp. 1–15, 2016.
[22] G. Pola and P. Tabuada, “Symbolic Models for Nonlinear Control Systems: Alternating Approximate Bisimulations,” SIAM J. Control Optim., vol. 48, no. 2, pp. 719–733, 2009.
[23] K. H. Rosen, Elementary Number Theory and Its Applications. Addison-Wesley, 1986.
[24] E. Seneta, Non-negative matrices and Markov chains. Springer, 2006. [25] S. Lovett and R. Meka, “Constructive Discrepancy Minimization by
Walking on the Edges,” SIAM J. Comput., vol. 44, no. 5, pp. 1573– 1582, 2015. [26] Gurobi Optimization, Inc., “Gurobi optimizer reference manual,” 2015. [Online]. Available: http://www.gurobi.com [27] P. Nilsson and N. Ozay, “On a class of maximal invariance inducing control strategies for large collections of switched systems,” in Proc. HSCC, 2017, pp. 187–196. [28] M. W. Hirsch, S. Smale, and R. L. Devaney, Differential Equations, Dynamical Systems, and an Introduction to Chaos, 3rd ed. Academic Press, 2012. [29] R. K. Ahuja, T. L. Magnanti, and J. B. Orlin, Network ﬂows. Prentice Hall, 1993. [30] J. Shen, “A bound on the exponent of primitivity in terms of diameter,” Linear Algebra and its Applications, vol. 244, pp. 21 – 33, 1996.

APPENDIX
Proof of Proposition 1. For a grid point q ∈ κη(X ) and x ∈ X , consider the relation q ∼ x iff q−x ∞ ≤ . Since > η/2 this relation has the property that every x ∈ X is related to some q ∈ κη(X ), and conversely every q ∈ κη(X ) is related to at least one x ∈ X . The relation satisﬁes 1) of Deﬁnition 2. To show that also 2) and 3) hold, we show the stronger property that if q ∼ x, then for all x = φµ(τ, x, d) pertaining to an admissible d : [0, τ ] → D it holds that q ∼ x for (the unique) q such that q −µ→ q .
τ,η
From the construction of Στ,η, q − φµ(τ, q, 0) ∞ ≤ η/2. Furthermore, under the continuity assumptions, it is known that the ﬂow φµ(t, x, 0) of fµ(x, 0) and the ﬂow φµ(t, x, d) for any d(t) such that maxt∈[0,τ] fµ(x, 0) − fµ(x, d(t)) ∞ ≤ δµ satisfy φµ(t, x, 0) − φµ(t, x, d) ∞ ≤ (δµ/Kµ)(eKµt − 1) [28]. Thus, it follows that for any such d : [0, τ ] → D,

q − φµ(τ, x, d) ∞ ≤ φµ(τ, x, d) − φµ(τ, x, 0) ∞

+ φµ(τ, x, 0) − φµ(τ, q, 0) ∞ + φµ(τ, q, 0) − q ∞

≤ δµ Kµ δ¯µ
≤ Kµ

eKµτ − 1 eKµτ − 1

η + βµ ( q − x ∞, τ ) + 2
η + βµ ( , τ ) + 2 ≤ .

Hence q ∼ φµ(τ, x, d), which completes the proof.

Proof of Theorem 1. Let {πn}n∈[N] be individual switching protocols that solve (12) by generating trajectories ξn(0)ξn(1) . . . and actions σn(0)σn(1) . . . for Στ,η. Due to bisimilarity and the η/2-proximity of initial conditions, the individual trajectories ξn(0)ξn(1) . . . of Στ,η and the individual trajectories xn(0)xn(1) . . . of Στ satisfy ξn(s)−xn(s) ∞ ≤
for all s ∈ N when the action sequence σn(0)σn(1) . . . is implemented for both systems. By assumption,

1G+ (Xl) (ξn(s), σn(s)) ≤ Rl.
n∈[N ]
Thus for a counting set Xl = XlX × XlU , xn(s) ∈ XlX =⇒ ξn(s) ∈ XlX ⊕ B∞(0, ) =⇒ ξn(s) ∈ κη XlX ⊕ B∞(0, ) ,
where the last step follows from knowing that ξn(s) only takes values x such that κη(x) = x. Thus,

1Xl (xn(s), σn(s)) ≤ 1G+ (Xl) (ξn(s), σn(s))≤Rl,

n∈[N ]

n∈[N ]

which shows that the constraint in (13) is satisﬁed.

Proof of Theorem 2. Suppose for contradiction that there is a

solution to (15) but not to (14). Let {πn}n∈[N] be individual switching policies that solve (15) by generating trajectories

xn(0)xn(1) . . . and actions σn(0)σn(1) . . . for Στ . Due to bisimilarity and the η/2-proximity of initial conditions, the

individual trajectories ξn(0)ξn(1) . . . of Στ,η and the individual trajectories xn(0)xn(1) . . . of Στ satisfy ξn(s) − xn(s) ≤ for all s ∈ N when the actions σn(0)σn(1) . . . are implemented for both systems. For a set A we have κη A B∞ 0, η2 ⊂ {x ∈ A : κη(x) = x} ⊂ A. Thus,

ξn(s) ∈ κη XlX

η B∞ 0, + 2

=⇒ ξn(s) ∈ XlX B∞ (0, )

=⇒ xn(s) ∈ XlX B∞ (0, ) ⊕ B∞(0, ) ⊂ XlX .

It follows that

1G−( +η/2)(Xl)(ξn(s), σn(s)) ≤ 1Xl (xn(s), σn(s)) ,

n∈[N ]

n∈[N ]

so {πn}n∈[N] is a solution also for (14)—a contradiction.

Proof of Theorem 3. We ﬁrst consider the case s ≤ T , and claim that the selection on Line 2 is possible if

wq(s) =

1{q} (ξn(s)) , ∀q ∈ Q.

(31)

n∈[N ]

and, furthermore, that the selection guarantees that (31) holds at time (s + 1).
Due to (23), equation (31) holds at s = 0. For induction, assume that (31) holds at time s. Then by (24e),

rqµ(s) = wq(s) =

1{q} (ξn(s)) .

(32)

µ∈U

n∈[N ]

The selection on line 2 amounts to for each q ∈ Q assigning wq(s) objects to |U | “bins” such that the µ-bin has rqµ

15

members; by (32) this is doable. Remark that if σn(s) = µ, then ξn(s + 1) = q if and only if ξn(s) ∈ Nqµ. Thus,

1{q} (ξn(s + 1)) =

1{(q,µ)} (ξn(s + 1), σn(s))

n∈[N ]

n∈[N ] µ∈U

=

1{(q ,µ)} (ξn(s), σn(s))

n∈[N ] µ∈U q ∈Nqµ

=

rqµ (s) = wq(s + 1),

µ∈U q ∈Nqµ

where the last step follows from (16). Thus (31) holds for all s ∈ [T + 1].
Secondly, we consider the case s ≥ T and claim that the selection on line 4 is possible if for all q ∈ Q

µ∈U j∈[J]

Cj , αj (s−T )

{(q,µ)}
=

1{q} (ξn(s)) ,

n∈[N ]

(33)

and, furthermore, that the selection guarantees that (33) holds

at time (s + 1). To show that (33) enables a selection

{σn(s)}n∈[N] satisfying line 4, it sufﬁces to remark that the

selection problem is equivalent to above with rqµ(s) replaced

(s−T ) {(q,µ)}

by j∈[J] Cj , αj

.

Due to (24c) and (31), equation (33) holds at s = T .

Suppose for induction that (33) holds at time s ≥ T and that a

selection {σn(s)}n∈[N] satisfying line 4 has been made. Then,

1{q} (ξn(s + 1)) =

1{(q,µ)} (ξn(s + 1), σn(s))

n∈[N ]

n∈[N ] µ∈U

=

1{(q ,µ)} (ξn(s), σn(s))

n∈[N ] µ∈U q ∈Nqµ

(s−T ) Nqµ×{µ}

= Cj , αj

=

Cj , αj (s+1−T )

{(q,µ)}
.

j ∈[J ] µ∈U

j ∈[J ] µ∈U

The last step follows from the observation that a node q ∈ Nqµ must have a cycle index (i − 1) mod |Cj| in cycle Cj, where i is the cycle index of q. Thus the selection on line 4 is feasible
for all s ≥ T . Finally, we show that each counting constraint (Xl, Rl) is
satisﬁed. For s < T we have from line 2 and (24a):

1Xl (ξn(s), σn(s))
n∈[N ]

=

1Xl (q, µ) 1{(q,µ)} (ξn(s), σn(s))

n∈[N ] q∈Q µ∈U

=

1Xl (q, µ) rqµ(s) ≤ Rl.

q∈Q µ∈U

Thus the counting constraints are satisﬁed in the preﬁx phase. For the sufﬁx phase, from line 4 and (24b) it follows that

1Xl (q, µ) 1{(q,µ)} (ξn(s), σn(s))

n∈[N ] q∈Q µ∈U

=

1Xl (q, µ)

q∈Q µ∈U

j ∈[J ]

Cj , αj (s−T )

{(q,µ)}

(s−T ) Xl

=

Cj , αj

≤ Rl.

j ∈[J ]

Thus the switching protocol in Algorithm 1 generates inputs and trajectories that satisfy the constraints of (22).

Proof of Theorem 5. Let {πn∗ }n∈[N] be a solution to the in-

stance (22) and consider the generated sequence of con-

trols σn(s), s ∈ N, and aggregate states wq(s) =

n∈[N] 1{q} (ξn(s)). The number of possible values w(s) can
take is ﬁnite and given by |Q|+NN−1 —the number of ways in which N identical objects (subsystems) can be partitioned

into |Q| sets (nodes). We can therefore ﬁnd times T1, T2 with

T1 < T2 ≤

|Q|+N −1 N

such that w(T1) = w(T2). We show

that the graph ﬂows induced by {πn∗ }n∈[N] on the time interval

[T1, T2] can be achieved with cycle assignments: we deﬁne a

ﬂow on a graph in a higher dimension, decompose it into ﬂows

over cycles, and project the cyclic ﬂow onto the original graph.

Let G = (Q, −→) be the system graph, and deﬁne a new

graph H = (VH , EH ). The node set VH = Q × Q × . . . × Q

T2−T1 times
contains T2 − T1 copies of each node in Q, and copies of
q ∈ Q are labeled qs for s ∈ [T1, T2]. The set of edges is
deﬁned as

EH = {(qs, q˜s+1) : s ∈ {T1, . . . , T2 − 1}, (q, q˜) ∈ E}

{(qT2 , qT1 ) : q ∈ Q} .

An edge ﬂow is induced on H by {πn∗ }n∈[N], obtained by letting the ﬂow along (qs, q˜s+1) be the number of subsystems that traverses the edge (q, q˜) ∈ E at time s, and by letting the ﬂow along (qT2 , qT1 ) be equal to the number of systems at q at time T1. By construction, this ﬂow is balanced at each node (i.e. inﬂows equal outﬂows).
By the ﬂow decomposition theorem [29, Theorem 3.5], we can then ﬁnd cycles and assignments in H that achieve this
edge ﬂow. As becomes evident from the proof in [29], these cycles are furthermore simple in H and thus of length at most |VH | = |Q|(T2 − T1). By projecting these cycles onto a single copy of Q, we obtain cycles and assignments in G that mimic the counting performance of {πn∗ }n∈[N] on the interval [T1, T2] when circulated.
We can therefore deﬁne a preﬁx-sufﬁx strategy by taking as the preﬁx part rqµ(s) = n∈[N] 1{(q,µ)}(ξn(s), σn(s)), s ∈ [T1], followed by a sufﬁx part consisting of the cycles and assignments constructed as above.

Lemma 1. Suppose C = C1 ∪ C2 is a cycle that visits a node q0 twice, so that it can be decomposed into two cycles C1 = (q0, q1) . . . (qi, q0) and C2 = (q0, qi+1) . . . (q|C|−1, q0).
Let α be an assignment to C that satisﬁes maxcntX (C, α) ≤ R, let P be the graph period, and

let Np =

α(p + iP ), p ∈ [P ],

i∈[|C|/P ]

Np1 = ||CC1|| Np, Np2 = ||CC2|| Np, p ∈ [P ].

Then the joint X-counts for the assignment α¯{Np1}p∈[P] to C1 and the assignment α¯{Np2}p∈[P] to C2, satisfy

maxcntX {C1, C2}, {α¯{N1} , α¯{N2} } ≤ R.

p p∈[P ]

p p∈[P ]

16

Proof of Lemma 1. We have for all i1 that

P N(1i mod P ) P N(i mod P )

α¯{N1} (i1) =

1

=

1

p p∈[P ]

|C1|

|C |

P

= |C |

α((i1

k∈[|C|/P ]

mod P ) + kP ),

and similarly for C2. P must divide both |C1| and |C2|, so ((i1
mod |C1|) mod P ) = (i1 mod P ) for all i1 and similarly
for |C2|. Below, for a cycle C = (q0, µ0, q1)(q1, µ1, q2) . . . we use the short hand notation 1CX (i) = 1 if (qi, µi) ∈ X and 1CX (i) = 0 otherwise, to indicate that the i’th state-action pair is in the counting set X. For j = 1, 2 we get

Cj, α¯

s
j

{Np }p∈[P ]

X
=

1CXj (ij ) (α¯{Nj} ) p p∈[P ]

ij ∈[|Cj |]

s(ij )

P =
|C |

1CXj (ij )

α(((ij − s)

ij ∈[|Cj |]

k∈[|C|/P ]

mod P ) + kP ).

We have i2 mod P = (|C1|+i2) mod P , and i2 → |C1|+i2 is a mapping from i2 ∈ [|C2|] to the corresponding index in C. We can therefore convert a sum over both i1 and i2 into a sum over the index i of C.

X

X

C1, α¯{Ns 1}

+ C2, α¯{Ns 2}

p p∈[P ]

p p∈[P ]

P =
|C |

1CX (i)

α (((i − s)

i∈[|C |]

k∈[|C|/P ]

mod P ) + kP )

≤ max

1CX (i) α (((i − s) mod P ) + kP )

k∈[|C|/P ]

i∈[|C |]

≤ max

1CX (i) α s(i) = maxcntX (C, α) ≤ R.

s∈[|C|]

i∈[|C |]

Proof of Theorem 6. By Theorem 5, we know that a correct

solution must eventually lead to periodic behavior, and Lemma

1 shows that the sufﬁx of such a solution can be mapped into a

sufﬁx on simple cycles consisting of P -averaged assignments,

where P is the period of the graph5. What remains to show is

that this latter sufﬁx is reachable from the initial state while

respecting the relaxed counting constraints.

Let w(s) for s ∈ N be the aggregate states for an integer

solution to (22). From Lemma 1 we can obtain a set of

simple cycles I such that some P -averaged assignments to

these cycles satisfy the counting bounds. In addition, these

assignments have the same parity structure as w(s), and

hence as the initial condition; therefore they are reachable

from the initial condition by virtue of Corollary 1. We now

propose a switching protocol to control the aggregate state to

these assignments; the protocol consists in gradually steering

a fraction of the systems from the original solution w(s) to

the P -averaged assignments pertaining to the cycles in I.

We use the following notation: let α(s) be what remains of

the correct trajectory w(s), let β(s) be the fraction currently

being steered towards assignments to the simple cycles, and

let γ(s) be the fraction that has already reached these assign-

ments. We then have α(0) = w(0), and β(0) = γ(0) = 0.

The overall system state is w˜ (s) = α(s) + β(s) + γ(s).

5In the case of a non-connected graph the analysis can be done separately for each strongly connected component.

The protocol at time s + 1 is as follows.
• If β(s) = 0, set α(s + 1) = α(s)(1 − / α(s) 1), and β(s + 1) = α(s) / α(s) 1,
• If β(s) has reached the average assignments to cycles in I, set β(s + 1) = 0, and γ(s + 1) = β(s) + γ(s),
• Otherwise, steer β(s) toward the average assignments to cycles in I .
We remark that the transitions are all properly connected and merely illustrate the transport of subsystem “weight” from α(s) via β(s) to the average assignments represented by γ(s). Transporting a mass takes at most time (diam(G)2 + 1) by [30] which gives a bound T ≤ (diam(G)2 + 1) for the T in the proof of Theorem 4. We can thus infer that the total transportation time is upper bounded by (diam(G)2 + 1)N/ , since an absolute weight is transported in each step.
We ﬁnally consider the counting bounds. By assumption, they are satisﬁed by w(s), and by Lemma 1 they are also satisﬁed once the average assignments to cycles in I are reached. In the meantime, w˜qµ(s) = αqµ(s)+βqµ(s)+γqµ(s). For every s, there is an integer z ≤ 1/ such that α(s) = 1 − Nz w(s), γ(s) = (zN−1) γ0(s), where γ0 is the average assignment to the cycles. Furthermore βqµ(s) 1 ≤ which shows that the counts are bounded as follows:

1Xl (q, µ) w˜qµ(s)
q∈Q µ∈U

=

1Xl (q, µ)

q∈Q µ∈U

(1 − z/N )wqµ(s) + (z − 1)γ0(s)/N + βqµ(s)

≤ (1 − z/N )Rl + (z − 1)Rl/N + ≤ Rl + .

We have therefore constructed a preﬁx-sufﬁx solution, where the sufﬁx part consists of simple cycles, such that the relaxed counting bounds (Xl, Rl + ) are satisﬁed.

Petter Nilsson received his B.S. in Engineering Physics in 2011, and his M.S. in Optimization and Systems Theory in 2013, both from KTH Royal Institute of Technology in Stockholm, Sweden, and his Ph.D. in Electrical Engineering in 2017 from the University of Michigan. In addition to his technical degrees, he holds a B.S. in Business and Economics from the Stockholm School of Economics. He is currently a postdoctoral scholar at the California Institute of Technology.

Necmiye Ozay received the B.S. degree from Bogazici University, Istanbul in 2004, the M.S. degree from the Pennsylvania State University, University Park in 2006 and the Ph.D. degree from Northeastern University, Boston in 2010, all in electrical engineering. She was a postdoctoral scholar at California Institute of Technology, Pasadena between 2010 and 2013. She is currently an assistant professor of Electrical Engineering and Computer Science, at University of Michigan, Ann Arbor.

