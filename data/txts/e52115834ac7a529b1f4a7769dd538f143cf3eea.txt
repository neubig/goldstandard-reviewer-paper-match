arXiv:1707.02337v1 [cs.IT] 7 Jul 2017

Limitations on the Achievable Repair Bandwidth of Piggybacking Codes with Low Substriping
Reyna Hulett∗ and Mary Wootters†
June 2017
Abstract
The piggybacking framework for designing erasure codes for distributed storage has empirically proven to be very useful, and has been used to design codes with desirable properties, such as low repair bandwidth and complexity. However, the theoretical properties of this framework remain largely unexplored. We address this by adapting a general characterization of repair schemes (previously used for Reed Solomon codes) to analyze piggybacking codes with low substriping. With this characterization, we establish a separation between piggybacking and general erasure codes, and several impossibility results for subcategories of piggybacking codes; for certain parameters, we also present explicit, optimal constructions of piggybacking codes.
1 Introduction
The modern world is practically overwhelmed with data, much of which is kept in large-scale distributed storage systems. These systems store large ﬁles across a number of servers, or nodes. Due to the scale of such systems, node failure is an everyday occurrence, and the system must be robust to such failures. One way to achieve robustness is by replicating the data. However, this clearly has high storage overhead. Erasure coding can achieve the same reliability as replication with far less overhead.
Recently, there has been extensive eﬀort in the ﬁeld of coding for distributed storage to design erasure codes with desirable properties. Two important desirable properties include an optimal reliability-redundancy trade-oﬀ, and bandwidth-eﬃcient repair of failed nodes. Since the work of [1], there have been several constructions of regenerating codes which aim to achieve these properties. We refer the reader to [5] for much more information on coding for distributed storage.
In recent work, [7] introduced a new piggybacking design framework to construct such codes. This framework modiﬁes a base code to improve its repair properties. This framework has been employed several times to design new codes [4] [7] [11] [13], including one code that is being implemented in the Hadoop Distributed File System [7].
Although the piggybacking framework has clearly been productive in practice, there has not been much theoretical analysis of its possibilities and limitations. That is the subject of this paper.
1.1 Our Contributions
We build on a framework introduced by [3] for characterizing and analyzing erasure code repair schemes, which gives us a characterization of piggybacking code repair schemes in particular. This allows us to prove various impossibility results for piggybacking schemes, and to design schemes with optimal repair bandwidth for certain parameters. Speciﬁcally, our contributions are the following.
∗Computer Science Department, Stanford University. rmhulett@stanford.edu. RH’s research supported in part by a NSF Graduate Research Fellowship under grant DGE-1656518.
†Computer Science and Electrical Engineering Departments, Stanford University. marykw@stanford.edu. RH and MW’s research supported in part by NSF grant CCF-1657049.
1

1. Extension of the framework of [3]. We adapt the characterization of repair schemes by [3], originally introduced for Reed Solomon codes, to our setting. More precisely, their scheme works for scalar MDS codes over ﬁnite ﬁelds, while piggybacking codes are not scalar. We modify their approach to obtain a characterization of linear repair schemes for MDS array codes. We specialize this to piggybacking codes for our main results, but the general framework may be of broader interest.
2. Separation between piggybacking and general erasure codes. Using this framework, we demonstrate that for certain parameter regimes, piggybacking cannot achieve the optimal repair bandwidth achievable by general erasure codes. Thus piggybacking is strictly less powerful than general erasure codes.
3. Other bounds. We additionally utilize this framework to give some limited lower bounds for piggybacking in other settings, as well as upper bounds and explicit code constructions for some speciﬁc parameters. Certain of these bounds suggest approaches to using the piggybacking design framework which may improve the attainable repair bandwidth, compared to existing practices.
1.2 Organization
In Section 2 we set up notation and deﬁnitions. In Section 3 we survey related work and restate our results in more detail. We introduce our characterization of repair schemes in Section 4 and leverage it to prove a variety of useful lemmas. The main results for piggybacking are given in Sections 5 and 6. In Section 7 we conclude with some open questions.
2 Setup and Preliminaries
2.1 Notation
In general, we will use (parenthetical) superscripts to denote diﬀerent matrices and subscripts to index within a matrix. For indexing into a matrix M (ℓ), the entry in row i, column j will be denoted m(i,ℓj), the ith row will be denoted m(i,ℓ•), and the jth column will be denoted m(•ℓ,j) .
Vectors generated by indexing into a matrix will be rows or columns corresponding to their orientation in the matrix (e.g., mi(,ℓ•) is a row vector but m(•ℓ,j) is a column vector). Other vectors will be considered row vectors by default. They will be typeset in bold as v(ℓ) = [v0(ℓ) v1(ℓ) · · · ] or v = [ v0 v1 · · · ] if the elements are themselves vectors.
2.2 Erasure Coding and the Exact Repair Problem
In this paper, we restrict our focus to linear, maximum distance separable codes with linear repair schemes. We ﬁrst brieﬂy recall some deﬁnitions. A code C over an alphabet A is a subset of An; if the code has size |C| = |A|k, we say that the dimension of C is k. We say that such a code has the Maximum Distance Separable property (MDS property) if any k symbols of a codeword c ∈ C can determine c.
If the alphabet A is a ﬁeld, A = Fq, and if C ⊂ Fnq is a linear subspace of Fnq , then we say C is linear. A linear code C can always be written as the image of a generator matrix F ∈ Fqk×n; given a message a ∈ Fkq , the corresponding codeword is aF . If C additionally has the MDS property—equivalently, if a generator matrix F has the property that any k columns are linearly independent—we say C is an MDS code. We say that a code (along with an encoding map from messages to codewords) is systematic if the k symbols of the message appear as symbols of the codeword. Notice that any linear code can be made systematic by performing row operations on the generator matrix to obtain a generator matrix so that the ﬁrst k columns form the identity. In this case, the ﬁrst k symbols are called systematic while the remaining symbols are called parity symbols.
We will study array codes, where the alphabet A is in fact a vector space A = Ftq. These codes are not linear (indeed, it does not make sense for a code to be linear over Ftq), but we will study codes that are Fq-linear.
2

Deﬁnition 1. An array code with t substripes over an alphabet Fq is a code C ⊂ (Ftq)n over Ftq. We say that C has linear substripes if C is closed under Fq-linear operations; that is, for any c, c′ ∈ C and for any λ ∈ Fq, we have c + λc′ ∈ C. If C has the MDS property, we say that it is an MDS array code.
We will often think of codewords of an array code as matrices C ∈ Fqn×t, rather than vectors c ∈ (Ftq)n, and we will write C ⊂ Fqn×t. Notice that this orientation is at odds with our convention that vectors c of length n are row vectors, but we will stick by it because it will be more convenient and intuitive for the diagrams in the rest of the paper.
In coding for distributed storage, the message a corresponds to a ﬁle to be stored, and the corresponding codeword c ∈ C captures how the data should be stored on the n nodes: node i holds the symbol ci. In this setting, we would always like to tolerate as many node failures as possible, which means that we demand that the code C have the MDS property. Moreover, there are certain operations we would like to be eﬃcient. First, we would like to be able to recover the original message (the stored ﬁle) eﬃciently. This can always be done directly if the code is systematic. Second, while we would like to be able to handle n − k failures in the worst case, a much more common scenario in many systems is a single failure [8]. Thus, we would like to be able to repair a single failed node as eﬃciently as possible. In this work, the measure of eﬃciency we consider is the repair bandwidth, which measures how much data must be downloaded to repair a single failure.
Formally, let C be an MDS array code over Fq with t substripes. If node i∗ fails, then a repair scheme to repair i∗ using a repair set S ⊂ {0, . . . , n − 1} \ {i∗} is a collection of functions1 gi : Ftq → Fbqi so that for all c ∈ C, ci∗ can be determined from {gi(ci) | i ∈ S}. If C is a linear MDS array code, and if the functions gi and the method of determining ci∗ is linear, we say that the repair scheme is linear.
The above deﬁnes a repair scheme for a particular node i∗ and a particular repair set S. A (linear) repair scheme with locality d for an MDS array code C over Fq consists of (linear) repair schemes with repair sets S of size d for every possible failed node i∗. There are two important regimes. In the “any d” regime, there must be a valid repair scheme for any repair set S of size d. On the other hand, in the “some d” regime, we require only one valid repair set of size d per possible failed node.
The bandwidth of a repair scheme for an MDS array code C over Fq is the number of symbols of Fq needed to repair any symbol i∗. In the language above, it is the maximum, over all i∗ and all repair sets S in the scheme, of i∈S bi. The exact repair problem is the problem of minimizing the repair bandwidth. There have been several solutions proposed in the literature since the problem was introduced in [1]. In this work, we focus on the piggybacking framework, which we discuss in the next section.

2.3 Piggybacking

In this paper, we study the piggybacking framework introduced by [7], (with a few assumptions, discussed

below).

A piggybacking code C over Fq with t substripes is constructed from a “base code” C0 ⊂ Fnq and

t 2

“piggybacking functions” p(i,j) : Fkq → Fnq . For this work, we assume that the base code C0 is a (scalar)

MDS code over Fq; in particular, it is linear, with a generator matrix F ∈ Fqk×n. We also assume that the

piggybacking functions p(i,j) are linear; in particular, they can be represented by matrices P (i,j) ∈ Fqk×n.

With these assumptions, we deﬁne a piggybacking code (with a scalar MDS base code) over Fq as follows.

Deﬁnition 2. Let F ∈ Fqk×n be the generator matrix of an MDS code C0, and take a collection of piggy-
backing matrices {P (i,j) | i ∈ [0, t − 2], j ∈ [i + 1, t − 1]} ⊂ Fqk×n.

Consider the MDS array code C over Fq with t linear substripes, deﬁned as follows. Given a message a ∈ Fkqt given by
a = [ a0 · · · at−1 ]

(where each ai ∈ Fkq ), we form a codeword C ∈ Fqn×t so that the ith substripe is

c•,i = (a0P (0,i) + · · · + ai−1P (i−1,i) + aiF )T .

1In this work, we will only consider repair bandwidth, rather than disk access, so we allow the nodes to do arbitrary local computation.

3

We say that C is a (n, k) piggybacking code with a scalar MDS base code (henceforth a piggybacking code) with t substripes over Fq.
We illustrate a piggybacking code formed from F and {P (i,j)} below.

node 0 ...
node n-1

substripe 0 (a0F )T

substripe 1

···

a0P (0,1) + a1F T · · ·

substripe t-1 a0P (0,t−1) + · · · + at−2P (t−2,t−1) + at−1F T

As with all MDS array codes, we will represent codewords as matrices in Fqn×t of the form

 (a0F )T

a0P (0,1) + a1F T · · ·



a0P (0,t−1) + · · · + at−2P (t−2,t−1) + at−1F

T


As noted in [7], piggybacking codes using an MDS base code remain MDS, but may have improved repair properties; in particular, they may have reduced repair bandwidth.
In addition to general piggybacking codes, we will also consider a subcategory of codes which only piggyback in the last substripe of each node, inspired by the approach of [13]. We dub these linebacking codes.

Deﬁnition 3. An (n, k) linebacking code with a scalar MDS base code (henceforth a linebacking code) C
over the ﬁnite ﬁeld Fq with t substripes is a (n, k) piggybacking code, with the additional property that all piggybacking matrices P (i,j) such that j = t − 1 are zero. Thus we drop the index j indicating which substripe the piggyback is added to and denote P (i,t−1) by P (i).

Thus for message a = [ a0 · · · at−1 ], a linebacking code stores

substripe 0 substripe 1 · · · substripe t-2

node 0 ...

(a0F )T

(a1F )T · · · (at−2F )T

node n-1

substripe t-1 a0P (0) + · · · + at−2P (t−2) + at−1F T

and has codewords of the form

 (a0F )T (a1F )T · · · (at−2F )T



a0P (0,t−1) + · · · + at−2P (t−2,t−1) + at−1F

T


It is not hard to see that, as with general linear MDS codes, piggybacking (respectively, linebacking) codes can be made systematic via a remapping of message symbols, while retaining their piggybacking (linebacking) structure. Thus as with general codes, we can assume without loss of generality that the ﬁrst k nodes of a piggybacking (linebacking) code are systematic, meaning substripe i stores message chunk ai on the ﬁrst k nodes.
3 Related Work and Our Results
The piggybacking framework for designing error correcting codes for distributed storage was introduced by [7]. It is as described in Deﬁnition 2, except that we have made the following assumptions. First, we assume that the piggybacking functions are linear—in general this is not required—and second, that the base code is a scalar MDS code—in general, the base code may itself be an MDS array code. However, we note that all piggybacking codes in the literature do use linear piggybacking functions [4] [7] [11] [13]. Almost all use scalar MDS base codes as well, except [13] and one of four constructions in [7], which are speciﬁcally designed to improve the repair properties of parity nodes for existing array codes.

4

Furthermore, in [7], an invertible linear tranformation may be applied to the data stored on each node in order to reduce the data-read. However, since in this work we are only concerned with repair bandwidth, this does not matter for us and we omit it from Deﬁnition 2.
The piggybacking design framework has been used to produce codes with low data-read and bandwidth for repairing individual failed nodes. [7] used the framework to design explicit codes with the lowest dataread and bandwidth among known solutions for a few speciﬁc settings, including (high-rate) MDS codes with low substriping, the domain of interest in this paper. Extending their ideas, [13] showed how to modify codes with optimal repair bandwidth for systematic nodes to use piggybacking to obtain asymptotically optimal bandwidth for parity nodes as well. Interestingly, [13] obtained these results for linebacking codes (Deﬁnition 3), which is more restricted than general piggybacking. The piggybacking framework was also employed by [11] to design codes with low repair complexity, and by [4] as part of a compound design using both piggybacking and simple parity checks.
However, little is understood about the theoretical possibilities and limitations of codes designed using the piggybacking framework. Nor is there much understanding of how to choose piggybacking functions to achieve desirable repair properties. Although [13] takes a more principled approach than others to choosing the piggybacking functions, some of their choices—including piggybacking only in the last substripe and always using all the systematic nodes in repairing a failed parity node—do not have a rigorous theoretical backing.
Here we explore the theoretical limitations on achievable repair bandwidth for piggybacking codes with scalar MDS base codes and with a small number of substripes t ≤ n − k. As in Deﬁnition 1, we do not allow for symbol extension; that is, we treat the elements of Fq as indivisible and measure bandwidth in units of symbols of Fq. We focus primarily on the regime where any failed node must be repairable from any set of d other nodes, where d is the locality. The alternative is that for each failed node, there must exist some set of d other nodes which repair the failed node. This alternative regime is less restrictive, and the achievable repair bandwidth is less well characterized. While both regimes have been studied in the literature [10], the piggybacking design framework has primarily been employed in the latter, less restrictive regime [4] [7] [11] [13].

Known lower bounds. In any setting, for MDS codes, we have the cut-set bound on the repair bandwidth,

which

states

that we

must download b ≥

td d−k+1

symbols [1].

Since

this

is

decreasing in

d,

we

can

also set

d

to

the

maximum/optimal

value

n

−

1

to

get

the

bound

b

≥

t

n−1 n−k

.

However, if t < n − k and in the

absence of symbol extension—the setting we consider here—this is not achievable, since it would require

downloading less than a full symbol from each node. Since we must download at least one full symbol from

every participating node, we can say b ≥ d which gives the bound

b ≥ td ≥ tb d−k+1 b−k+1

which implies

b ≥ k + t − 1,

which also matches the trivial lower bound for any MDS code [3]. We will call b = k + t − 1 “perfect bandwidth.”2
Note that this bound cannot be tight for large t > n − k. However, for t ≤ n − k, and in the regime where
any d nodes must be able to repair the failed node, [10] demonstrated that perfect bandwidth is achievable for t > k − 3, but cannot be achieved by a linear code without symbol extension for t ≤ k − 3. Under the
weaker requirement that only some set of d nodes must be able to repair the failed node, [12] showed that the cut-set bound (and thus perfect bandwidth) is achievable provided k ≤ max{ n2 , 3} and d ≥ 2k − 1 which in our setting translates to substriping t ≥ k, with ﬁeld size at most 2(n − k). Although the cut-set bound
has been shown to be achievable for large t, q and general n, k [6] [14], to our knowledge the question of achieving perfect bandwidth when t ≤ n − k in general remains open.

2Throughout we will assume 2 ≤ t ≤ n − k and 2 ≤ k. Otherwise, if t = 1, there is no piggybacking and any MDS code achieves perfect bandwidth; if t > n − k, achieving perfect bandwidth is impossible; and if k = 1, the straightforward lower bound on bandwidth k + t − 1 and the trivially achievable bandwidth for MDS codes kt are equal.

5

3.1 Our Results
In this paper, we study the ability of piggybacking codes (with scalar MDS base codes) to achieve perfect bandwidth when t ≤ n − k, using linear repair schemes. By adapting the framework of [3], we give complete results for the regime where any d nodes must be able to repair a failed node, and partial progress for the regime where only some d nodes repair. These results, summarized in Tables 1 and 2, are as follows.

• “Any d” regime:
– Piggybacking codes cannot achieve perfect bandwidth for k ≥ 3, and thus are strictly weaker than general MDS codes (Theorem 10).
– Linebacking codes suﬃce to achieve perfect bandwidth for k = 2 with large ﬁeld size q (Theorem 12).
• “Some d” regime:

– Piggybacking codes are more powerful in this regime than the “any d” regime, as demonstrated by an example perfect bandwidth linebacking code with k = 3 (Theorem 13).

– By extension from the “any d” regime, piggybacking codes do not exist for k ≥ 3, t = n − k, and thus are strictly weaker than general MDS codes (Theorem 10), but linebacking codes do exist for k = 2 with large ﬁeld size q (Theorem 12).

–

Linebacking

codes

cannot

achieve

perfect

bandwidth

for

k

≥3

and

t>

n−k+1 2

(Theorem

18).

– Linebacking codes which follow the common practice of using all remaining systematic nodes to repair a failed node cannot achieve perfect bandwidth for k ≥ 3 and t > n−√k−1 (Theorem 22).
k

– For t = 2, k = 2 we give an explicit construction of perfect bandwidth linebacking codes with small ﬁeld size q ≥ k + 1 (Theorem 17); compare to [12] where q ≥ 2(n − k).

k≥3 k=2

General t > k − 3: exist for q ≥ n − k + t t ≤ k − 3: do not exist [10] exist for q ≥ n − k + t [10]

Piggybacking do not exist (Thm. 10)
exist for some q (Thm. 12)

Linebacking do not exist (Thm. 10)
exist for some q (Thm. 12)

Table 1: Existence of perfect bandwidth MDS array codes when t ≤ n − k in the “any d” regime

k≥3 k=2

General t ≥ k: exist for
k ≤ max{ n2 , 3}, q ≥ 2(n − k) [12]
exist for q ≥ 2(n − k) [12]

Piggybacking t = n − k: do not exist (Thm. 10) t = 2: example (6, 3) construction
with q = 7 (Thm. 13)
exist for some q (Thm. 12) t = 2: construction for
q ≥ k + 1 (Thm. 17)

Linebacking t = n − k: do not exist (Thm. 10) t > n−2k+1 : do not exist (Thm. 18) t = 2: example (6, 3) construction
with q = 7 (Thm. 13)
exist for some q (Thm. 12) t = 2: construction for
q ≥ k + 1 (Thm. 17)

Table 2: Existence of perfect bandwidth MDS array codes when t ≤ n − k in the “some d” regime

6

4 Characterization of Repair Schemes
The work of [3] provides a characterization of linear repair schemes for scalar MDS codes. Their framework relies on the fact that a scalar MDS code C is linear over its alphabet. In our case, piggybacking codes— and more generally MDS array codes with linear substripes—are linear over Fq, but not over Ftq. (Indeed, linearity over Ftq does not immediately make sense, as Ftq does not have a natural notion of multiplication). However, the approach of [3] still makes sense in this context. The main reason linearity was important to the approach of [3] was because their characterization involved the dual code, C⊥. We may introduce a similar notion for MDS array codes.
Deﬁnition 4. Let C ⊂ Fqn×t be an MDS array code with t linear substripes over Fq. The dual code of C is C⊥ := {X ∈ Fqn×t | X, C = 0 ∀C ∈ C}, where ·, · denotes the Frobenius inner product.
Theorem 1. Let C ⊂ Fqn×t be a (n, k) MDS array code with t linear substripes over Fq. For a ﬁxed node i∗ and set of nodes S ∋ i∗, the following are equivalent.
1. There is a linear repair scheme for node i∗ from S with bandwidth b.
2. There exists a set of t dual codewords, the repair matrices, {W (0), W (1), . . . , W (t−1)} ⊂ C⊥ such that the only non-zero rows of each W (j) are i∗ and S, and
dim({wi(∗j),• | j ∈ [0, t − 1]}) = t
dim({wi(,j•) | j ∈ [0, t − 1]}) ≤ b
i=i∗
See Figure 1 for an illustration of a set of repair matrices. The proof of Theorem 1 follows very similar to the approach in [3]. We include a proof in Appendix A for completeness, but we sketch one direction in Figure 2, showing how a set of repair matrices yields a repair scheme.

1 0 0 ··· 0

0 1 0 ··· 0

0 0 0 · · · 1 Row i∗ has full dimension t

2 2 2 ··· 2

1 1 1 ··· 1

2 2 2 ··· 2

1 0 -1 · · · 1 1 -1 0 · · · 1

2 0 -2 · · · 2 2 -2 0 · · · 2

···

2 0 -2 · · · 2 0 0 0 ··· 0

Rows i ∈ S have low dimension

2 0 0 ··· 1

0 0 0 ··· 0

2 0 0 ··· 1

0 0 0 ··· 0 0 0 0 ··· 0 0 0 0 ··· 0

0 0 0 ··· 0 0 0 0 ··· 0 0 0 0 ··· 0

0 0 0 ··· 0 0 0 0 ··· 0 0 0 0 ··· 0

All other rows are 0

W (0)

W (1)

W (t−1)

Figure 1: An example illustrating the structure of a linear repair scheme with q = 3.
Henceforth we will refer interchangeably to a linear repair scheme for i∗ from a set S, and a set of t repair matrices for i∗, S as deﬁned above.
4.1 Piggybacking Code Repair Schemes
Now that we have characterized repair schemes as sets of dual codewords, we can analyze the repair schemes of piggybacking codes, and those that achieve perfect bandwidth in particular. In the remainder of Section 4, we develop several lemmas using this characterization which will allow us to prove our main results in Sections 5 and 6.
The next lemma specializes the deﬁnition of a dual code to piggybacking codes.

7

Linear repair scheme, given repair matrices. Suppose that {W (0), W (1), . . . W (t−1)} are a set of repair matrices for a node i∗ with repair set S, as in Theorem 1. Let C ∈ C. Then we can deﬁne a linear repair scheme as follows.
1. For every node i = i∗, let Qi ⊂ Ftq be any basis of span({wi(,j•) | j ∈ [0, t − 1]}). We say that Qi is the query set for node i. Observe that Qi = ∅ ∀i ∈/ S so only nodes in the repair set will be queried.
2. For every query vector q ∈ Qi, node i sends q · ci,• to the replacement node. Since i=i∗ |Qi| ≤ b, at most b symbols of Fq are downloaded.
3. The replacement node now has enough information to recover wi(∗j),• · ci∗,• = W (j), C − i=i∗ wi(,j•) · ci,•i for all j, since W (j) ∈ C⊥ implies W (j), C = 0 and wi(,j•) · ci,• for i = i∗ can
be recovered from the responses to the query Qi. Since dim({wi(∗j),• | j ∈ [0, t − 1]}) = t, this gives t linearly independent equations, and we can solve for ci∗,•, thus repairing the failed node.

Figure 2: Turning a set of repair matrices into a linear repair scheme. This algorithm proves one direction of Theorem 1. See Appendix A for the full proof.

Lemma 2. Let C be an (n, k) piggybacking code over Fq with t substripes, base code C0 with generator matrix F , and piggybacking matrices {P (i,j) | i ∈ [0, t − 2], j ∈ [i + 1, t − 1]}. A matrix X ∈ Fqn×t is in C⊥ if and only if
F x•,i + P (i,i+1)x•,i+1 + · · · + P (i,t−1)x•,t−1 = 0T ∀i
Proof. X ∈ C⊥ if and only if

xT•,0 · (a0F )T + · · · + xT•,t−1 ·

X, C = 0 xT•,0 · c•,0 + · · · + xT•,t−1 · c•,t−1 = 0
T
a0P (0,t−1) + · · · + at−2P (t−2,t−1) + at−1F = 0

∀C ∈ C ∀C ∈ C ∀a0, . . . , at−1 ∈ Fkq

Since the above holds for all a0, . . . , at−1, for an arbitrary i we consider aj = 0 for j = i and ai ∈ Fkq . This yields the equivalent requirement

xT•,i · (aiF )T + xT•,i+1 ·

T
aiP (i,i+1) + · · · + xT•,t−1 ·

T
aiP (i,t−1) = 0

∀i ∀ai ∈ Fkq

aiF x•,i + aiP (i,i+1)x•,i+1 + · · · + aiP (i,t−1)x•,t−1 = [0] F x•,i + P (i,i+1)x•,i+1 + · · · + P (i,t−1)x•,t−1 = 0T

∀i ∀ai ∈ Fkq ∀i

as desired.
Note that the restriction on the last column of a repair matrix W , F w•,t−1 = 0T , is equivalent to w•T,t−1 ∈ C0⊥ where C0⊥ ⊂ Fnq is the dual of the base code. Because C0 is a scalar MDS code, C0⊥ is itself an MDS code, and thus is a linear subspace with minimum weight k + 1. Corollary 3. Let C be an (n, k) linebacking code over Fq with t substripes, base code generator matrix F , and piggybacking matrices {P (i) | i ∈ [0, t − 2]}. A matrix X ∈ Fqn×t is in C⊥ if and only if
F x•,t−1 = 0T F x•,i + P (i)x•,t−1 = 0T ∀i = t − 1
8

It will also be useful to note operations we can perform on a set of repair matrices which result in an equivalent repair scheme.
Deﬁnition 5. For a given MDS array code C with t linear substripes, and failed node i∗, two repair schemes {W (0), . . . , W (t−1)} and {V (0), . . . , V (t−1)} are equivalent if for every row i,

span({wi(,j•) | j ∈ [0, t − 1]}) = span({vi(,j•) | j ∈ [0, t − 1]})
That is, two repair schemes are equivalent if they can share the same queries {Qi} in the algorithm in Figure 2. This also means the two schemes have the same repair set and repair bandwidth.
Lemma 4. Let C be an (n, k) MDS array code over Fq with t linear substripes. Consider a repair scheme {W (0), . . . , W (t−1)} for failed node i∗. The following operations on {W (0), . . . , W (t−1)} produce an equivalent repair scheme.
1. Scaling any repair matrix W (j) by a constant κ ∈ Fq\{0}
2. Adding a multiple of one repair matrix κW (j) to another W (ℓ) where κ ∈ Fq, j = ℓ
Proof. First, note that the dual code C⊥ of a MDS array code with linear substripes is a subspace of Fqn×t, so the matrices obtained by scaling or adding two dual codewords are still dual codewords. Now, consider the eﬀect of these operations on the row sets: {wi(,j•) | j ∈ [0, t − 1]} for row i. Scaling or adding two repair matrices is equivalent to scaling or adding two rows in each row set. Since these are elementary row operations, they do not change the subspace spanned by each row set, and thus by deﬁnition these operations result in an equivalent repair scheme.

The above holds for any MDS array code with linear substripes. For piggybacking and linebacking schemes speciﬁcally, we also deﬁne a weaker notion of equivalence which permits more operations on the repair scheme.
Deﬁnition 6. For a given MDS array code C with linear substripes, and failed node i∗, two repair schemes {W (0), . . . , W (t−1)} and {V (0), . . . , V (t−1)} are download-equivalent if for every row i,

dim({wi(,j•) | j ∈ [0, t − 1]}) = dim({vi(,j•) | j ∈ [0, t − 1]})

That is, two repair schemes are download-equivalent if they download the same number of symbols from each node. Two equivalent schemes are also download-equivalent, but not vice versa. Download-equivalent schemes must have the same repair set and bandwidth, but not the same queries {Qi}.

Lemma 5. Let C be an (n, k) MDS array code over Fq with t linear substripes. Consider a repair scheme {W (0), . . . , W (t−1)} for failed node i∗. The following operations on {W (0), . . . , W (t−1)} produce a download-
equivalent repair scheme.

1. For a piggybacking code, adding κw•(j,t)−1 to w•(j,0) for some ﬁxed κ ∈ Fq and every j

2. For a linebacking code, adding κw•(j,t)−1 to w•(j,ℓ) for some ﬁxed κ ∈ Fq, ℓ = t − 1 and every j Proof. First, we will argue that the resulting matrices are still dual codewords.

1. For a piggybacking code C, recall from Lemma 2 that X ∈ C⊥ if and only if

F x•,i + P (i,i+1)x•,i+1 + · · · + P (i,t−1)x•,t−1 = 0T ∀i

(1)

Consider the repair matrix W (j) and the resulting matrix W (j)′ obtained by adding κ times the last column to the 0th column. Only the 0th column of W (j)′ diﬀers from W (j), so we need only check the
equation for i = 0:

F w•(j,0)′ + P (0,1)w•(j,1)′ + · · · + P (0,t−1)w•(j,t)−′ 1 = F (w•(j,0) + κw•(j,t)−1) + P (0,1)w•(j,1) + · · · + P (0,t−1)w•(j,t)−1 = κF w•(j,t)−1 + F w•(j,0) + P (0,1)w•(j,1) + · · · + P (0,t−1)w•(j,t)−1 = κ0T + 0T = 0T

as desired, where the last line results from two applications of (1) to W (j) ∈ C⊥.

9

2. For a linebacking code C, recall from Corollary 3 that X ∈ C⊥ if and only if
F x•,t−1 = 0T F x•,i + P (i)x•,t−1 = 0T ∀i = t − 1
Consider the repair matrix W (j) and the resulting matrix W (j)′ obtained by adding κ times the last column to the ℓth column. Only the ℓth column of W (j)′ diﬀers from W (j), so we need only check the equation for i = ℓ:
F w•(j,ℓ)′ + P (ℓ)w•(j,t)−′ 1 = F (w•(j,ℓ) + κw•(j,t)−1) + P (ℓ)w•(j,t)−1 = κF w•(j,t)−1 + F w•(j,ℓ) + P (ℓ)w•(j,t)−1 = κ0T + 0T = 0T
as desired. Now, consider the eﬀect of these operations on the row sets {wi(,j•) | j ∈ [0, t − 1]} for row i. If we consider this as the row space of a matrix, it becomes clear that these operations are equivalent to elementary column operations. Thus they may change the space spanned by the row set but not its dimension, so by deﬁnition these operations result in a download-equivalent repair scheme.
4.2 Perfect Bandwidth Repair Schemes
Recall from Section 3 that an (n, k) MDS array code with t ≤ n − k substripes has perfect bandwidth if it achieves the trivial lower bound on bandwidth, b = k + t − 1.
Observation 6. Any perfect bandwidth (n, k) MDS code with t linear substripes must have d = k + t − 1 nodes in each repair set, and download a single symbol from each. This follows from the cut-set bound [1]
b ≥ td d−k+1
because d ≤ b trivially (each node in the repair set contributes at least one symbol), and we can only achieve b ≤ k + t − 1 if d ≥ b.
Per Theorem 1, a repair scheme for node i∗ from a set of other nodes S can be characterized as a set of repair matrices {W (0), . . . , W (t−1)} in C⊥ with
dim({wi(∗j),• | j ∈ [0, t − 1]}) = t dim({wi(,j•) | j ∈ [0, t − 1]}) ≤ b
i∈S
From Observation 6, we must have |S| = k + t − 1 and dim({wi(,j•) | j ∈ [0, t − 1]}) = 1 ∀i ∈ S, for any perfect bandwidth repair scheme. With this observation, as well as the preceding discussion in Section 4.1, we note some properties of perfect bandwidth repair schemes for piggybacking codes which will be useful later. Deﬁnition 7. We say a piggybacking repair scheme {W (0), . . . , W (t−1)} for node i∗ from a set S is in standard form if the following conditions hold; see Figure 3 for an illustration.
1. We can partition S such that for some T ⊂ S, |T | = k − 1, we have S = T ∪ {r0, . . . , rt−1}, where repair matrix W (j) is only non-zero on rows T ∪ {rj, i∗}.
2. The last column of each repair matrix has exactly k + 1 non-zero entries, i.e., wt(w•(j,t)−1) = k + 1 ∀j.
10

i∗ 1 0 0 · · · 1

0 1 0 ··· 1

0 0 0 · · · 1 Row i∗ has full dimension t

T

2 2 2 ··· 2 1 0 -1 · · · 1

1 1 1 ··· 1 2 0 -2 · · · 2

2 2 2 ··· 2 2 0 -2 · · · 2

Rows i ∈ T have low dimension

···

r0 1 2 0 · · · 1

0 0 0 ··· 0

0 0 0 ··· 0

··· 0 0 0 ··· 0

1 1 2 ··· 1

0 0 0 · · · 0 Row rj is exclusive to W (j)

rt−1 0 0 0 · · · 0

0 0 0 ··· 0

2 0 0 ··· 1

0 0 0 ··· 0 0 0 0 ··· 0

0 0 0 ··· 0 0 0 0 ··· 0

0 0 0 ··· 0 0 0 0 ··· 0

All other n − k − t rows are 0

W (0)

W (1)

W (t−1)

Figure 3: An example illustrating the structure of a linear repair scheme in standard form with q = 3.

Observation 7. Consider a perfect bandwidth (n, k) piggybacking code C with t substripes, base code C0 with generator matrix F , and piggybacking matrices {P (i,j) | i ∈ [0, t − 2], j ∈ [i + 1, t − 1]}. If {W (0), . . . , W (t−1)} is any repair scheme for C and some node i∗, then the rightmost non-zero column of each W (j) must have at least k + 1 non-zeros. This is because W (j) ∈ C⊥ requires
F w•(j,i) + P (i,i+1)w•(j,i)+1 + · · · + P (i,t−1)w•(j,t)−1 = 0T ∀i
by Lemma 2, so if i is the rightmost non-zero column we get F w•(j,i) = 0T . But since the base code C0 is MDS, any k columns of the generator matrix F are linearly independent, so this equation can only hold if w•(j,i) has at least k + 1 non-zeros. Note also that W (j) must have a rightmost non-zero column. Otherwise, W (j) would be entirely zero, including row i∗. But then dim{wi(∗j),• | j ∈ [0, t − 1]} ≤ t − 1, which contradicts the requirements for a valid repair scheme from Theorem 1.
Lemma 8. Let C be a perfect bandwidth (n, k) piggybacking code with t substripes. Then for any failed node i∗, repair set S, and corresponding repair scheme {W (0), . . . , W (t−1)}, there exists an equivalent repair scheme in standard form.
Proof. From Observation 6, we know that the matrices {W (0), . . . , W (t−1)} are non-zero on exactly k + t rows, and each row of S has dimension 1. Furthermore, from Lemma 4, we know that scaling and adding two repair matrices will result in an equivalent repair scheme. Thus to obtain an equivalent repair scheme in standard form, we proceed as follows.
1. Choose any T ⊂ S, |T | = k − 1 to be the set of shared non-zero rows.
2. Go through the repair matrices in order. For each W (j),
• Pick rj to be any remaining non-zero row in W (j) not in T or equal to i∗. Such a row must exist because otherwise W (j) could have at most k non-zero rows, but this would contradict Observation 7.
• Add multiples of W (j) to each other repair matrix to zero out row rj. This can be done because row rj ∈ S has dimension 1.
The above procedure results in each W (j) being non-zero only on the k + 1 rows T ∪ {rj, i∗} since every other row ri, i = j was zeroed out using matrix i; subsequent operations would not aﬀect this row because every matrix added to W (j) had also had row ri zeroed out.
Furthermore, the last column of W (j) must have exactly k + 1 non-zeros: By Observation 7, there are exactly k + 1 non-zero rows in W (j), and either the last column is zero or has exactly k + 1 non-zeros. But if w•(j,t)−1 were zero, it would also be zero on the k − 1 ≥ 1 rows T , each of which has dimension 1 across the repair matrices. This would imply that every repair matrix has a last column of weight less than k + 1 and therefore all zero by Observation 7. This would make it impossible to have row i∗ have full rank, so we have a contradiction, and the equivalent repair scheme obtained by the above procedure must be in standard form.

11

Lemma 9. Let C be a perfect bandwidth (n, k) piggybacking code over Fq with t = 2 substripes. Then q ≥ k + 1.
Proof. Consider a repair scheme for a node i∗ from a set S for such a code, {W (0), W (1)}. Because we can perform linear operations on the repair matrices and get an equivalent repair scheme by Lemma 4, we can assume without loss of generality that wi(∗0,)• = [1 0], wi(∗1,)• = [0 1].
Recall that from Observation 6, the number of non-zero rows in the repair matrices is k + t including i∗, so |S| = k + t − 1 = k + 1. Since the rows S have dimension 1, and by Observation 7 the rightmost non-zero column of each repair matrix has at least k + 1 non-zeros, we observe that every row in S must be non-zero in W (0). Since the rows of S have dimension 1, this means we can express wi(,1•) = κiwi(,0•) for every i ∈ S and some κi ∈ Fq.
If any κi = κj for i = j, then consider W (1) − κiW (0). From Lemma 4, this would still be a dual codeword of C, but clearly it has at least one non-zero in the last column (row i∗) and at most k non-zeros in the last column (rows i∗ and S\{i, j}). This contradicts Observation 7, implying that all the κi’s must be distinct. This necessitates k + 1 distinct scalars in Fq so we conclude q ≥ k + 1 as desired.

5 “Any d” Regime
As noted in Observation 6, perfect bandwidth piggybacking codes with low substriping t ≤ n − k must have locality d = k + t − 1 other nodes. In this section, we consider the regime where, when a node fails, any set of d other nodes must be able to repair it with bandwidth b (as opposed to the less strict “some d” regime, which is treated in Section 6). For general linear erasure codes in this regime, [9] showed that for t ≤ k − 3, the cut-set bound is not achievable when only a single symbol is downloaded from each node of the repair set (and thus perfect bandwidth is not achievable). However, they also constructed a code which does achieve the cut-set bound for any t ≥ k − 2, at least for repairing the systematic nodes. In this section, we will show that piggybacking codes cannot achieve perfect bandwidth for k ≥ 3, and thus are strictly weaker than general linear codes in this regime.

5.1 Non-achievability of Perfect Bandwidth for k ≥ 3

In this section, we prove the following theorem.

Theorem 10. No (n, k) piggybacking code with k ≥ 3 and t substripes can achieve perfect bandwidth in the regime where any d = k + t − 1 nodes must be able to repair a failed node.

To prove this, we will assume the existence of such a code, and consider an arbitrary pair of repair schemes for two diﬀerent nodes with the same set of non-zero rows in their repair matrices. We assume these repair schemes are in standard form, which can be done without loss of generality, per Lemma 8. Finally, we show that the requirements for both schemes to have bandwidth k + t − 1 render it impossible for the ﬁrst scheme to recover its failed node. This will demonstrate that no piggybacking code for k ≥ 3 can achieve perfect bandwidth, even for systematic nodes (in fact, even for only two nodes), and thus piggybacking codes are strictly less powerful than general linear codes in the “any d” regime.

Lemma 11. No (n, k) piggybacking code with k ≥ 3 and t substripes can have two bandwidth b = k + t − 1 repair schemes for two diﬀerent failed nodes with the same set of k + t non-zero rows.

Proof. Assume to obtain a contradiction that for some k ≥ 3, some (n, k) piggybacking code C—over Fq with

t substripes, base code C0 generated by F , and piggybacking matrices {P (i,j) | i ∈ [0, t− 2], j ∈ [i + 1, t− 1]}— obtains a repair bandwidth of k + t− 1 for two such repair schemes. Let these schemes be {W (0), . . . , W (t−1)}

which repairs node i∗W

and {V (0), . . . , V (t−1)} which repairs i∗V

=

i

∗ W

,

both

with

bandwidth

k

+

t − 1.

Furthermore, let the set of non-zero row indices be S, such that the W ’s repair i∗W from SW = S \ {i∗W } and

the V ’s repair i∗V from SV = S \ {i∗V }.

By Lemma 8, we can assume without loss of generality that these repair matrices are in standard form.

Namely, each repair matrix has exactly k + 1 non-zero rows; we can choose the shared sets of rows T =

TW ∪ {i∗W } = TV ∪ {i∗V } such that all the repair matrices share |T | = k ≥ 3 non-zero rows including i∗W , i∗V ,

12

and some other row rshared; and we can renumber the matrices such that for all j, W (j) and V (j) share the same non-zero rows. Furthermore, for all j, w•(j,t)−1 and v•(j,t)−1 have the same k + 1 non-zero rows, both live in C0⊥, and are non-zero because the matrices are in standard form. Thus they live in the same one-dimensional subspace, so if we deﬁne x(j) = w•(j,t)−1, we can scale V (j) such that v•(j,t)−1 = x(j) = w•(j,t)−1; recall that scaling repair matrices still results in an equivalent repair scheme by Lemma 4.
Now that we have ﬁxed the last column of every matrix, consider the next-to-last columns. Deﬁne y(j) = w•(j,t)−2. Now, because each V (j) ∈ C⊥, we must have F v•(j,t)−2 + P (t−2,t−1)v•(j,t)−1 = F v•(j,t)−2 + P (t−2,t−1)x(j) = 0T . Since we know v•(j,t)−2 is only non-zero on some ﬁxed k + 1 rows, any solution to this equation (possible next-to-last column of V (j)) can be represented as one ﬁxed solution with only these k + 1 rows non-zero,
plus some vector in C0⊥ with only these k + 1 rows non-zero. Note, however, that y(j) is one such ﬁxed solution (since W (j) ∈ C⊥ implies F w•(j,t)−2 + P (t−2,t−1)w•(j,t)−1 = F w•(j,t)−2 + P (t−2,t−1)x(j) = 0T ), and all vectors in C0⊥ with only these k + 1 rows non-zero are scalar multiples of x(j). Thus for some λ(j) ∈ Fq we must have v•(j,t)−2 = y(j) + λ(j)x(j). Thus we have









∀j W (j) = · · · y(j) x(j) , V (j) = · · · y(j) + λ(j)x(j) x(j)

Now, we recall the assumption that {W (0), . . . , W (t−1)} is a repair scheme for i∗W and {V (0), . . . , V (t−1)} for i∗V , with bandwidth k + t − 1, and all the repair matrices are non-zero on row rshared = i∗W , i∗V . Thus by Observation 6, we know that dim({wr(jsh)ared,• | j ∈ [0, t − 1]}) = dim({vr(jsh)ared,• | j ∈ [0, t − 1]}) = 1. This must also hold when considering only the last two columns, so
dim({(yr(jsh)ared , x(rjsh)ared ) | j ∈ [0, t − 1]}) = dim({(yr(jsh)ared + λ(j)x(rjsh)ared , x(rjsh)ared ) | j ∈ [0, t − 1]}) = 1

However, since row rshared is non-zero in every W and V , we know x(rjsh)ared is non-zero for every j, and thus

for both of these sets to have dimension 1, it must be that λ(j) = λ for every j.

But

now

consider

row

i

∗ W

.

We

know

that

in

the

V ’s

this

row

must

have

dimension

1

in

order

to

achieve

bandwidth k + t − 1, which implies

dim({(yi(∗j) + λx(i∗j) , x(i∗j) ) | j ∈ [0, t − 1]}) = 1

W

W

W

but then

dim({(yi(∗j), x(i∗j) ) | j ∈ [0, t − 1]}) = 1

W

W

which implies that in the W ’s, row i∗W has dimension at most t − 1. But to be a valid scheme repairing node i∗W , this row must have full dimension, giving us the desired contradiction.

This lemma immediately leads to the desired result.

Proof of Theorem 10. Assume to obtain a contradiction that a perfect bandwidth (n, k) piggybacking code C with k ≥ 3 and t substripes does exist. Then there must exist repair schemes {W (0), . . . , W (t−1)} repairing node i∗W = 0 from nodes 1, 2, . . . , k +t−1, and {V (0), . . . , V (t−1)} repairing i∗V = 1 using nodes 0, 2, 3, . . . , k + t − 1 each with bandwidth k + t − 1. However, these repair schemes share the same set of non-zero rows,
thus meeting the conditions of Lemma 11, so we have a contradiction.

5.2 Achievability for k = 2
Although piggybacking codes cannot achieve perfect bandwidth for any k ≥ 3, they can achieve it for k = 2 and any 2 ≤ t ≤ n − k, provided the ﬁeld size is suﬃciently large. In this section, we oﬀer a non-constructive proof that such codes exist for any 2 × n MDS base code generator matrix F and 2 ≤ t ≤ n − k, even if we only permit linebacking, i.e., piggybacking only in the last substripe (as in [13]). We proceed by considering the repair of any given node i∗ from a given set of k + t − 1 = t + 1 nodes, and counting the choices of piggybacking functions which fail to yield a valid repair scheme. Then we union bound over all choices of i∗ and sets of t + 1 nodes to show that for suﬃciently large ﬁeld size q, some choice of piggybacking functions admits a repair scheme for every i∗ and set of t + 1 nodes, with bandwidth t + 1.

13

Theorem 12. Let C0 ⊂ Fnq be an MDS code with dimension k = 2 and generator matrix F ∈ Fqk×n, let 2 ≤

t

≤

n − k,

and

suppose

that

q

is

suﬃciently

large

so

that

n

n−1 t+1

1

−

Πti=−11 (1

−

1 qi

)

< 1. Then there exists a

linebacking code with base code C0 and t substripes, which achieves perfect bandwidth (b = k + t − 1 = t + 1),

in the “any d” regime.

Proof. Consider an arbitrary failed node i∗ and a repair set S of size t + 1. Choose linebacking matrices {P (i) | i ∈ [0, t − 2]} uniformly at random and let C be the resulting linebacking code. We will show that with positive probability, C admits a valid repair scheme for i∗ from S.
We will construct a set of repair matrices. Write S = {r∗, r0, . . . , rt−1}. We will choose matrices W (0), . . . , W (t−1) with the following structure:
1. wi(∗j),• may be nonzero for all j

2. wr(jj),• may be nonzero for all j

3. wr(j∗),t−1 may be nonzero for all j

4. all other entries of W (j) for all j are zero.

Now, we will ﬁll in the nonzero entries of each W (j), so that W (j) ∈ C⊥. First note that w•(j,t)−1 is restricted

to only have 3 nonzero entries. For each j, ﬁx any choices for these nonzero entries so that w•(j,t)−1 = 0 and

so that F w•(j,t)−1 = 0. Notice that because F ∈ F2q×n and we have three nonzero entries to set, such a choice exists. For i ∈ [0, t − 2], set

(j)
zi

=

−P (i)w•(j,t)−1.

Thus,

(j)
zi

is

uniformly

random

(because

P

(i)

is),

and

for

a

ﬁxed

j,

the

set

{zi(j)

|

i

∈

[0,

t−2]}

is

independent.

Now for each i < t − 1 and for each j, choose w•(j,i) so that it obeys the nonzero pattern above, and so that

F w•(j,i) = zi(j).

We can do this because w•(j,i) has two nonzero entries and each 2 × 2 minor of F is full rank, since C0 is MDS; moreover, the choice of w•(j,i) is thus also uniformly random, and for a ﬁxed j, the set {w•(j,i) | i ∈ [0, t − 2]} is independent.
By Corollary 3, the matrices W (j), when chosen as above, are in C⊥. In order to constitute a set of optimal repair matrices for C, they thus need the additional properties that {wr(j,•) | j ∈ [0, t − 1]} has dimension 1 for all r ∈ S, and that {wi(∗j),• | j ∈ [0, t − 1]} has dimension t. The ﬁrst of these is satisﬁed by construction: for r ∈ {r0, . . . , rt−1}, there is only one element of {wr(j,•) | j ∈ [0, t − 1]} that is not zero; for r = r∗, every element of {wr(j,•) | j ∈ [0, t − 1]} is a multiple of et−1.
Thus, it remains to compute the probability that the second of these occurs, namely, that

dim({wi(∗j),• | j ∈ [0, t − 1]}) = t.

For a ﬁxed i∗, these vectors are independent and uniformly random, so the probability that these are full

rank is precisely Πti=−11

1

−

1 qi

.

Thus for any ﬁxed i∗ and set S, the probability that a random choice of piggybacking matrices admits a

valid repair scheme is Πti=−11

1

−

1 qi

. Since any set of d = k+t−1 = t+1 nodes must repair a failed node, and

there

are

n

nodes,

there

are

n

n−1 t+1

choices for i∗, S. Thus union bounding over all such choices, there exist

piggybacking matrices admitting

a

valid repair scheme for all i∗, S

provided n

n−1 t+1

1 − Πti=−11

1

−

1 qi

< 1,

which holds if q is suﬃciently large.

14

6 “Some d” Regime
In this section, we consider the regime where, when a node fails, there must exist only some single set of d = k +t−1 nodes which can repair it with bandwidth b. As we shall see, this is a strictly weaker requirement than requiring any set of d nodes to repair the failed node, as we did in Section 5. It is also a popular regime for instantiating the piggybacking design framework, e.g., in [4], [7], [11], and [13].
The “some d” regime seems more diﬃcult to get a handle on than the “any d” regime, although some results do immediately transfer over. For example, since perfect bandwidth linebacking codes for k = 2 exist in the “any d” regime, then they exist in the “some d” regime as well. Additionally, when t = n − k and d = k + t − 1 = n − 1, then the two regimes coincide, and so all of the results of Section 5 still hold if t = n − k. This implies perfect bandwidth piggybacking codes for t = n − k are still impossible in the “some d” regime, and since the constructions of [10] and [12] give perfect bandwidth MDS codes for t = n − k, this implies piggybacking codes are strictly weaker than general MDS codes in this regime as well. However, the two regimes are not equivalent; in Section 6.1 below we exhibit an example of a piggybacking code achieving perfect bandwidth for k = 3, which is impossible in the “any d” regime.
While lower bounds are more diﬃcult in the “some d” regime, upper bounds (achievability results) are easier, and in Section 6.2 we strengthen our results for k = 2 for the “any d” regime. More precisely, Theorem 12 gives a non-constructive existence proof of perfect bandwidth piggybacking codes for k = 2. In Section 6.2 we strengthen this for k = 2, t = 2 by giving an explicit construction.
Finally, while we are unable to prove impossibility results for piggybacking codes in general in the “some d” regime, we are able to prove impossibility results for linebacking codes. In Section 6.3 we show that perfect bandwidth linebacking codes do not exist for k ≥ 3 and for t > n−2k+1 .
6.1 General k
For k ≥ 3, establishing impossibility results for perfect bandwidth piggybacking codes in the “some d” regime seems quite diﬃcult. In particular, our approach of Theorem 10 breaks down, because while Lemma 11 still holds—no two schemes can have the same set of non-zero rows—in the “some d” regime, it is easy to choose the repair sets for the failed nodes so that this does not occur.
Below, we show that there is a very good reason that we cannot match the strength of Theorem 10 in the “some d” regime, namely that it is not true! We show by example (Theorem 13) that in fact there is a perfect bandwidth piggybacking code with n = 6, k = 3, t = 2, and q = 7 in the “some d” regime. This establishes a separation between the “some d” and “any d” regimes, since Theorem 10 shows that there is no such scheme in the “any d” regime.
The counterexample in Theorem 13 is for t = 2, and it is natural to ask if impossibility results might still hold for larger t. We also provide some results which shows that this may be the case. More precisely, we show in Theorem 14 and the ensuing Corollary 15 that if there is a perfect bandwidth piggybacking code in the “some d” regime with t substripes, then there also exists one with t − 1 substripes, down to t = 2. Thus, a negative result for any ﬁxed t0 would imply a negative result for all t ≥ t0, and a positive result for t0 would imply a positive result for all t ≤ t0.
Theorem 13. There is a piggybacking code with n = 6, k = 3, t = 2, q = 7 which achieves perfect bandwidth in the “some d” regime.
Proof. The example is given in Figure 4, along with the repair matrices.
Finally, we show that decreasing t does not make the problem of obtaining perfect bandwidth piggybacking codes any more diﬃcult.
Theorem 14. Let C be an (n, k) piggybacking code over Fq with t substripes, base code generator matrix F , and piggybacking matrices {P (i,j) | i ∈ [0, t − 2], j ∈ [i + 1, t − 1]}. If there exists a bandwidth b repair scheme for C, then we can construct a new (n, k) piggybacking code C′ over Fq with t − 1 substripes and bandwidth at most b − 1 in the regime where only some d = k + t − 1 nodes must be able to repair a failed node.
Before we prove Theorem 14, we note that this immediately implies that if there is a perfect bandwidth piggybacking code with t substripes, then there is also one with t − 1 substripes.
15

4 1 0 6 i∗ = 0 : 0 0 , 0 3 0 0
04
0 1 0 0 i∗ = 3 : 0 0 , 6 4 0 1
31

1 0 0 1 3 6 F = 0 1 0 4 6 6 ,
001363

0 0 0 1 0 0 P = 0 0 0 0 0 0
000010

2 1
0 0 0 2 0 5 0 0
06

1 1
6 5 i∗ = 1 : 0 0 ,
0 2 6 6
00

0 0
6 1 0 4 0 3 6 6
00

0 1
0 0 i∗ = 2 : 2 6 ,
0 0 0 5
02

0 0
3 1 0 0 4 1 0 1
54

0 0
6 1 i∗ = 4 : 0 0 ,
0 1 3 1
34

0 0
0 0 0 1 0 4 6 3
16

2 1
0 0 i∗ = 5 : 0 0 ,
0 4 2 1
51

0 0
0 1 5 5 0 0 0 2
06
0 0
0 0 0 1 0 4 6 3
16

Figure 4: A (6, 3) piggybacking code and repair scheme for t = 2, q = 7 in the “some d” regime.

Corollary 15. Let C be a perfect bandwidth (n, k) piggybacking code over Fq with t substripes. Then there exist piggybacking codes achieving perfect bandwidth for the same n, k, q and any number of substripes up to t.
Additionally, Corollary 15, along with Lemma 9 about the required alphabet size, imply that perfect bandwidth piggybacking codes must have large alphabets:
Corollary 16. Let C be a perfect bandwidth (n, k) piggybacking code over Fq in the regime where any d = k + t − 1 nodes must be able to repair a failed node. Then q ≥ k + 1.
Proof. Per Lemma 9, any piggybacking code achieving perfect bandwidth for t = 2 must have q ≥ k + 1, and by Corollary 15, if a piggybacking code exists for any t one exists for t = 2 with the same n, k, q.
Finally, we prove Theorem 14.
Proof of Theorem 14. We deﬁne the new code C′ with the same parameters n, k, q and base code as C, but with t − 1 substripes, such that the new piggybacking matrices are P (i,j)′ = P (i+1,j+1). This essentially amounts to removing the 0th substripe of both the message and each node, along with the corresponding piggybacking functions.
Now we want to show that a valid repair scheme exists for C′ with bandwidth at most b − 1. Consider the repair scheme of C for node i∗, {W (0), . . . , W (t−1)}. Since linear operations on this set of repair matrices result in an equivalent repair scheme, per Lemma 4, we can assume without loss of generality that wi(∗0,)• = [1 0 · · · 0]. Now, there must exist some entry of W (0), wi(f0ix)ed,jfixed = 0 such that iﬁxed = i∗; otherwise only row i∗ would be non-zero, which would contradict Observation 7. Thus we can use this entry to zero out the iﬁxed, jﬁthxed entry of every other repair matrix, by adding multiples of W (0).
Now we obtain a repair scheme of C′ for i∗ from {W (0), . . . , W (t−1)} by deleting the 0th column of each repair matrix and removing W (0) to obtain {W (1)′, . . . , W (t−1)′ }. Again, this essentially amounts to deleting the contribution of the 0th substripe of each node to the repair process, and deleting the repair matrix which solely recovers the 0th substripe. Note that each new repair matrix W (j)′ is in C′⊥: Per Lemma 2, the original matrix W (j) ∈ C⊥ implies
F w•(j,i) + P (i,i+1)w•(j,i)+1 + · · · + P (i,t−1)w•(j,t)−1 = 0T ∀i
Thus for W (j)′ we have
F w•(j,i)′ + P (i,i+1)′ w•(j,i)+′ 1 + · · · + P (i,t−2)′ w•(j,t)−′ 2 = F w•(j,i)+1 + P (i+1,i+2)w•(j,i)+2 + · · · + P (i+1,t−1)w•(j,t)−1 = 0T ∀i
16

so W (j)′ ∈ C′⊥, as desired. Furthermore, dim({wi(∗j,)•′ | j ∈ [1, t − 1]}) = t − 1. We know dim({wi(∗j),• | j ∈ [0, t − 1]}) = t, and the
deleted row wi(∗0,)• was [1 0 · · · 0], so it contributes nothing to the dimension of the row set obtained by deleting the 0th entry of each row, which must have dimension t − 1 for the original space to have full dimension.
Finally, the bandwidth of the new repair scheme {W (1)′, . . . , W (t−1)′} is at most b − 1. Clearly, we have dim({wi(j)′ | j ∈ [1, t − 1]}) ≤ dim({wi(j) | j ∈ [0, t − 1]}) ∀i, since deleting one row and one coordinate cannot increase the dimension of the row set. Additionally, the dimension of row iﬁxed must have decreased by at least one, because the iﬁxed, jﬁthxed entry was zeroed out in every repair matrix but W (0). Thus deleting row wi(f0ix)ed from the row set {wi(fji)xed | j ∈ [0, t − 1]} decreases the dimension. Since the dimension of at least one row set decreased, and no dimension increased, the total bandwidth decreased by at least one.
Thus for every i∗, we can obtain a valid repair scheme of C′ with bandwidth b − 1 from the repair
scheme of C. Therefore given a piggybacking code C with t substripes and bandwidth b, we can construct a
piggybacking code with the same n, k, q, and F ; t − 1 substripes; and bandwidth at most b − 1.

6.2 k = 2

Theorem 12, which guarantees the existence of optimal repair schemes for k = 2 in the “any d” regime, also applies in the “some d” regime.3 However, the requirement that only some repair set of size d exist is
weaker, and we can improve on Theorem 12 in the “some d” regime, giving an explicit construction of an optimal piggybacking code for k = 2, t = 2.

Theorem 17. Let C0 ⊂ Fnq be an MDS code with dimension k = 2 and generator matrix F ∈ Fqk×n, let t = 2, and suppose that n ≥ 4, q ≥ 3. Then there is an explicit construction of a piggybacking code with base
code C0 and with t substripes, which achieves perfect bandwidth b = k + t − 1 = 3, in the “some d” regime.

Proof. For t = 2, there is only one piggybacking matrix, P (0,1) = P . We choose P to be all zero, except
for some column i such that f1,i = 0 (which much exist for C0 to be MDS and F therefore rank k = 2); let
p0,i = 1. First, we exhibit the repair scheme for any i∗ = i. Pick the repair set S = {i, i0, i1} for any rows
i0, i1 = i, i∗. The two repair matrices will be

W (0) =

i∗  1

i −f1,i∗ /f1,i

i0  0

i1

0

0



−wi(,00)f0,i − f0,i∗  ,

i∗ 0 1

i 00

W (1) =

 i0 0

 

i1 0

where we omit the zero rows and the missing entries are fully determined by the requirement that the last columns are in C0⊥. Clearly this satisﬁes row i∗ having full dimension and has bandwidth k + t − 1 = 3. We allow the missing entries to be chosen such that the last columns are in C0⊥, and note that

F w•(0,0) + P w•(0,1) =

f0,i∗ − f0,i f1,i∗ , f1,i∗ − f1,i f1,i∗

f1,i

f1,i

T
+

f1,i∗ f − f

T
, 0 = 0T

f1,i 0,i 0,i∗

and F w•(1,0) + P w•(1,1) = [0, 0]T + [0, 0]T = 0T
so the W ’s are in C⊥. Thus we have exhibited a valid repair scheme for any i∗ = i.
3 In fact, since only some set of d nodes must be able to repair a given failed node, we need only union bound over choices of i∗ (not sets of d nodes), and thus q must only satisfy n 1 − Πti=−11 1 − q1i < 1.

17

When i∗ = i, the argument is slightly more complicated. We pick any repair set S = {i0, i1, i2} not including i∗. The repair matrices will be

W (0) =

i∗ = i
i0 i1 i2

1
wi(00,)0 wi(10,)0
0

0 wi(00,)1
,

W (1) =

i∗ = i
i0 i1 i2

0
κ0wi(00,)0 κ1wi(10,)0
0

1 κ0wi(00,)1



where κ0, κ1 ∈ Fq, we omit the zero rows, and the non-constant entries are yet to be determined. To have W (0) ∈ C⊥, we need

F w(0) + P w(0) = f0,i f0,i0 f0,i1 [1, w(0) , w(0) ]T = 0T

(2)

•,0

•,1

f1,i f1,i0 f1,i1

i0,0 i1,0

Since C0 is MDS, this uniquely determines wi(00,)0, wi(10,)0 = 0. Furthermore, to have W (1) ∈ C⊥, we need

F w•(1,0) + P w•(1,1) = ff10,,ii00 ff10,,ii11 [κ0wi(00,)0, κ1wi(10,)0]T + [1, 0]T = 0T (3)

Again, since C0 is MDS and we know wi(00,)0, wi(10,)0 = 0, this uniquely determines κ0, κ1. Note also that κ0 = κ1, since if they were equal that would imply either f1,i0 wi(00,)0 + f1,i1 wi(10,)0 = 0 or κ0 = κ1 = 0. The former would violate equation 2 since we speciﬁcally chose f1,i = 0, and the latter clearly violates equation 3.
Our goal now is to show that we can choose W (0), W (1) to simultaneously satisfy the known values above
while also having their last columns in C0⊥; this will ensure the repair scheme has row i∗ = i full rank, bandwidth k + t − 1 = 3, and repair matrices in C⊥. We will show this by considering the q − 1 possible non-zero choices for wi(00,)1. We ﬁx the 0th columns and it0h rows (since we know their desired values), and determine the last two unknowns in each last column such that the last columns are in C0⊥. For some choice of wi(00,)1, this must give the desired value of wi(11,)1/wi(10,)1, which needs to equal κ1 for the repair scheme to have the desired bandwidth. This is because each non-zero choice of wi(00,)1 must give a distinct value not equal to κ0 for wi(11,)1/wi(10,)1. (Note that this is never division by zero because the last columns are in C0⊥ and thus have a minimum weight of k + 1 = 3, so if wi(00,)1 = 0, wi(10,)1 = 0 as well.) The resulting values of wi(11,)1/wi(10,)1 never equal κ0, because if one did, w•(1,1) − κ0w•(0,1) would still be in C0⊥ but would have weight 1 or 2, which is less than the minimum weight. Also, if any two resulting values of wi(11,)1/wi(10,)1 were both equal to some κ, the diﬀerence between the two resulting values of w•(1,1) − κw•(0,1) for the two choices of wi(00,)1 would be zero in rows i, i1 but not in i0, so it again violates the minimum weight for vectors in C0⊥. Thus each possible value (not including κ0) for wi(11,)1/wi(10,)1 will occur exactly once over choices of wi(00,)1, so some such choice will give the desired value κ1 and yield a valid repair scheme.

6.3 Linebacking codes

While we do not have general impossibility results for piggybacking codes in the “some d” regime, we can prove impossibility results for linebacking codes in this regime. We note that multiple constructions of piggybacking codes in the literature are in fact linebacking codes—including the design of [13] and any piggybacking codes with t = 2 substripes, such as two constructions of [7]—and so such lower bounds provide useful design insights.
Our main theorem in this section is the following.

Theorem

18.

No

(n, k)

linebacking

code

with

k

≥

3

and

t

>

n−k+1 2

substripes

can

achieve

perfect

bandwidth.

We remark that the constraint on t is tight in the sense that Theorem 13 gives an example of a perfect bandwidth linebacking code with t = n−2k+1 .
In addition, we prove a stronger impossibility result for the special case of linebacking codes where
every repair scheme (for systematic nodes) uses all remaining systematic nodes in its repair set. This

18

impossibility result is notable because many piggybacking and linebacking constructions do use all the remaining systematic nodes when repairing a failed node [7] [13], and this result suggests that such an approach may limit the achievable repair bandwidth. Our main result here is the following, which is a corollary of Theorem 22 that we will state and prove below.
Corollary 19. No (n, k) linebacking code with k ≥ 3, t > n−√k−1 substripes, and which uses all remaining
k
systematic nodes to repair a failed node can achieve perfect bandwidth.
Remark 20 (Separation between linebacking and piggybacking?). Note that in the regime where any d = k + t − 1 nodes must be able to repair a failed node, linebacking and general piggybacking were essentially equivalent in terms of ability to achieve perfect bandwidth: For k ≥ 3 it was impossible for any piggybacking or linebacking code to achieve it, and for k = 2 linebacking was suﬃcient provided the ﬁeld size q was large enough. However, in the “some d” regime, it is possible that piggybacking codes are strictly more powerful than linebacking codes, in the sense that there may exists parameter regimes where linebacking codes cannot achieve perfect bandwidth but general piggybacking codes can. We conjecture that this is the case, and note that an example of a perfect bandwidth piggybacking code in the regime where Theorem 18 holds would establish this.
We begin by proving a lemma that will lead to the result of Theorem 18.
Lemma 21. No (n, k) linebacking code with t substripes and k ≥ 3 can have two bandwidth b = k + t − 1 repair schemes for two diﬀerent failed nodes, where each node participates in the other’s repair and the respective repair sets overlap by at least k nodes.
Proof. We proceed along the lines of Lemma 11, but using only two repair matrices from each of the two repair schemes. Assume to obtain a contradiction that for some k ≥ 3, some (n, k) linebacking code C—over Fq with t substripes, base code C0 with generator matrix F , and piggybacking matrices {P (i) | i ∈ [0, t−2]}— obtains a repair bandwidth of k + t− 1 for two such repair schemes. Let these schemes be {W (0), . . . , W (t−1)} which repairs node i∗W and {V (0), . . . , V (t−1)} which repairs node i∗V = i∗W . By assumption, these two repair schemes share k + 2 non-zero rows, including i∗W , i∗V .
By Lemma 8, we can assume without loss of generality that the repair matrices are in standard form. Namely, each repair matrix has exactly k + 1 non-zero rows, and all the repair matrices share k ≥ 3 rows including i∗W , i∗V , and some other row rshared. Since the W ’s and V ’s share two additional rows besides these k in common, we can renumber the matrices such that the pairs W (0), V (0) and W (1), V (1) each have the same k + 1 non-zero rows. Furthermore, the last columns of W (0), V (0) (and W (1), V (1)) live in C0⊥ and have the same k + 1 non-zero rows, so they live in a one-dimensional subspace. Thus, by Lemma 4, we can scale V (0) (and V (1)) such that w•(0,t)−1 = v•(0,t)−1 (and w•(1,t)−1 = v•(1,t)−1). Additionally, we know from Lemma 5 that we can add the last columns of the W ’s (or V ’s) onto any previous column, provided we perform the same operation on every matrix, and obtain a download-equivalent repair scheme. Thus, for example, we can modify the repair matrices such that row rshared is zeroed out in W (0) and V (0) except in the last position. Now, observe that the last columns of W (0) and V (0) have already been made equal, and that each other column j is constrained by F w•(0,j) + P (j)w•(0,t)−1 = 0T (and likewise for V (0)) by Corollary 3. Since each such constraint consists of k linearly independent equations (since F is MDS) and k unknowns (since k + 1 rows are non-zero and we ﬁxed row rshared), this constraint admits exactly one solution. But that implies each column of W (0) equals the corresponding column of V (0), and thus W (0) = V (0).
However, recall that row rshared must have dimension 1 in both the W ’s and V ’s by Theorem 1. Since we already have w•(1,t)−1 = v•(1,t)−1 which implies wr(1sh)ared,t−1 = vr(1sh)ared,t−1, and W (0) = V (0) which implies wr(0sh)ared,• = vr(0sh)ared,•, for row rshared to have dimension 1 in both repair schemes, we must have wr(1sh)ared,• = vr(1sh)ared,•. But again, this means the last columns are equal and each previous column has k unknowns (with the same known values between W (1) and V (1)), so we must have W (1) = V (1). This gives us the desired contradiction, because in the W ’s, row i∗W must have full rank, whereas in the V ’s it must have dimension 1; these cannot both be true if W (0) = V (0) and W (1) = V (1).
We are now ready to prove the main result of this section.
19

Proof of Theorem 18. Assume to obtain a contradiction that a perfect bandwidth (n, k) linebacking code

C

with

t

<

n−k+1 2

substripes

does

exist

for

some

k

≥

3.

Then there would necessarily be two repair

schemes meeting the assumptions of Lemma 21. First, observe that there must exist a pair of nodes each

of which participates in repairing the other. Consider a directed graph where edges go from each node

to the nodes it repairs. Each node has k + t − 1 in-edges so there are n(k + t − 1) edges. However,

n(k + t − 1)

>

n(k +

n−k+1 2

− 1)

=

n(n+k−1) 2

>

n 2

.

But

n 2

is the maximum number of edges a directed

graph (with no self-loops) can have without having a 2-cycle; thus this graph has a 2-cycle meaning two

nodes participate in each others’ repair. Furthermore, these same two nodes must have an overlap in their

repair

sets

of

size

at

least

k:

In

addition

to

repairing

each

other,

they

each

have

k+t−2

>

n+k−3 2

helper

nodes drawn from the remaining n − 2 nodes, so the overlap is at least 2( n+2k−2 ) − (n − 2) = k. Thus if

such a linebacking code existed, it would necessarily have two repair schemes meeting the assumptions of

Lemma 21, which is impossible.

Note that for t ≤ n−2k+1 , it is trivial to construct the repair sets (disregarding whether they admit valid repair schemes) to avoid any pair satisfying the assumptions of Lemma 21; for instance, each node can be repaired by the k + t − 1 nodes immediately following it (mod n).
However, most existing piggybacking codes do not choose their repair sets this way. Most, including those of [7] and [13] (who use linebacking codes), always use all remaining systematic nodes in the repair. For linebacking codes, this further restricts the parameters for which perfect bandwidth may be achievable.

Theorem 22. No (n, k) linebacking code with k ≥ 3, t substripes where t(t − 1) > (n−k)(kn−k−1) , and which uses all remaining systematic nodes to repair a failed node can achieve perfect bandwidth.

Proof. Assume to obtain a contradiction that a perfect bandwidth (n, k) linebacking code C with k ≥ 3 and

t substripes where t(t − 1) > (n−k)(kn−k−1) always uses all remaining systematic nodes to repair a failed node. Consider only the repair of the systematic nodes. By assumption, for any pair of systematic nodes, each

participates in the other’s repair. Their repair sets overlap by at least k if and only if there are at least

2 parity nodes which repair both, and each systematic node has t parity nodes repairing it. Per [2], the

maximum

number

of

sets

of

t

parity

nodes

such

that

no

two

sets

have

2

parity

nodes

in

common

is

(n

− 2

k

)

.

(2t)

Thus if k > (n−kt)((t−n−1)k−1) , two systematic nodes must share 2 helper parity nodes, and thus have an overlap

of size at least k in their repair sets as well as each participating in the other’s repair. However, this meets

the assumptions of Lemma 21, which is impossible.

Simplifying the statement of Theorem 22 results in the Corollary 19 which we presented earlier. We restate it here:

Corollary 19. No (n, k) linebacking code with k ≥ 3, t > n−√k−1 substripes, and which uses all remaining
k
systematic nodes to repair a failed node can achieve perfect bandwidth.

This may suggest that linebacking codes can achieve better bandwidth if they do not follow the standard

practice of using all remaining systematic nodes in every repair, since the bound t ≤ n−√k−1 is more restrictive

k

than

t≤

n−k+1 2

from

Theorem

18

as

k

grows.

7 Conclusion
We adapted the framework of [3] in order to analyze the achievable bandwidth of piggybacking codes introduced by [7] with scalar MDS base codes for low substriping t ≤ n − k. In the regime where any d nodes must be able to repair a failed node, we showed that for k ≥ 3 piggybacking codes cannot achieve the lower bound on bandwidth, and thus are less powerful than general linear codes. We established by counterexample that this result does not extend to the regime where only some d nodes repair a failed node (though piggybacking codes are still less powerful than general linear codes), and partially addressed the question of whether piggybacking codes can achieve the lower bound on bandwidth in this regime. We additionally gave impossibility results for linebacking, a subcategory of piggybacking in the style of [13].
Some questions about the theoretical capabilities and limitations of piggybacking codes remain to be addressed, and we conclude with these.

20

1. When do there exist perfect bandwidth piggybacking codes for the “some d” regime and k ≥ 3? When they do not exist, how close can piggybacking codes get to the lower bound on bandwidth?
2. Is linebacking less powerful than piggybacking?
3. Adding the (commonly used) assumption that all remaining systematic nodes assist in the repair of a failed node gave us a stronger impossibility result for linebacking in Corollary 19. Does this assumption actually worsen the achievable bandwidth for piggybacking (or general) codes?
4. Our analysis of piggybacking codes was limited compared to the proposal of [7] in a few ways. How does the analysis change if we permit non-linear piggybacking functions, or allow a vector (rather than scalar) base code? What can we say about how piggybacking codes perform on other metrics such as data-read and computation as well as bandwidth?
Acknowledgements
We thank Rashmi Vinayak for introducing the problem to us, and for very helpful correspondences.
References
[1] Alexandros G. Dimakis, P. Brighten Godfrey, Yunnan Wu, Martin Wainwright, and Kannan Ramchandran. Network coding for distributed storage systems. IEEE Transactions on Information Theory, 56(9):4539–4551, 2010.
[2] P. Erdo¨s and H. Hanani. On a limit theorem in combinatorial analysis. Publicationes Mathematicae Debrecen, 10:10–13, 1963.
[3] Venkatesan Guruswami and Mary Wootters. Repairing reed-solomon codes. pages 216–226. ACM, 6 2016.
[4] Siddhartha Kumar, Alexandre Gaell i Amat, Iryna Andriyanova, and Fredrik Bra¨nnstro¨m. A family of erasure correcting codes with low repair bandwidth and low repair complexity. pages 1–6. IEEE, 12 2015.
[5] University of Texas ECE Department. Erasure Coding for Distributed Storage wiki. Available at http://storagewiki.ece.utexas.edu/. Accessed: July 2017.
[6] K. V. Rashmi, Nihar B. Shah, and P. Vijay Kumar. Optimal exact-regenerating codes for distributed storage at the msr and mbr points via a product-matrix construction. IEEE Transactions on Information Theory, 57(8):5227–5239, 2011.
[7] K. V. Rashmi, Nihar B. Shah, and Kannan Ramchandran. A piggybacking design framework for readand download-eﬃcient distributed storage codes. pages 331–335. IEEE, 7 2013.
[8] K.V. Rashmi, N.B. Shah, D. Gu, H. Kuang, D. Borthakur, and K. Ramchandran. A solution to the network challenges of data recovery in erasure coded storage systems: A study on the Facebook warehouse cluster. UNISEX HotStorage, 2013.
[9] Nihar B. Shah, K. V. Rashmi, P. Vijay Kumar, and Kannan Ramchandran. Explicit codes minimizing repair bandwidth for distributed storage. pages 1–11. IEEE, 1 2010.
[10] Nihar B. Shah, K. V. Rashmi, P. Vijay Kumar, and Kannan Ramchandran. Interference alignment in regenerating codes for distributed storage: Necessity and code constructions. IEEE Transactions on Information Theory, 58(4):2134–2158, 2012.
[11] Chong Shangguan and Gennian Ge. New piggybacking design for systematic mds storage codes. 2016.
21

[12] Changho Suh and Kannan Ramchandran. Exact-repair mds code construction using interference alignment. IEEE Transactions on Information Theory, 57(3):1425–1442, 2011.
[13] Bin Yang, Xiaohu Tang, and Jie Li. A systematic piggybacking design for minimum storage regenerating codes. IEEE Transactions on Information Theory, 61(11):5779–5786, 2015.
[14] Min Ye and Alexander Barg. Explicit constructions of high-rate mds array codes with optimal repair bandwidth. IEEE Transactions on Information Theory, 63(4):2001–2014, 2017.

A Proof of Theorem 1

We follow the approach of [3], which gives a similar result for scalar MDS codes. We ﬁrst show that 2 implies 1, that is, if the required repair matrices exist, then there is a linear repair scheme for node i∗ from S with
bandwidth b. Suppose that {W (0), W (1), . . . , W (t−1)} ⊂ C⊥ so that the only non-zero rows of W (j) are i∗ and S, and
suppose that dim({wi(∗j),• | j ∈ [0, t − 1]}) = t

and dim({wi(,j•) | j ∈ [0, t − 1]}) ≤ b
i=i∗

Deﬁne a repair scheme for a codeword C ∈ C as follows. Let bi be the dimension of {wi(,j•) | j ∈ [0, t − 1]}, and let Let v0, . . . , vbi−1 be a basis for the span of that space. Then the bi symbols of Fq returned by node

i are

{ci,• · vℓ | ℓ ∈ [0, bi − 1]}

(4)

We need to establish that, from these, we may recover ci∗,•, the contents of node i∗. Using the fact that W (j), C = 0 for all C ∈ C, we have

ci∗,• · wi(∗j),• = − ci,• · wi(,j•)
i∈S

Thus, using the information (4) for all i ∈ S, we may reconstruct

ci∗,• · wi(∗j),•

for all j ∈ [0, t − 1]. Because {wi(∗j),• | j ∈ [0, t − 1]} has dimension t in Ftq, this is enough information to recover ci∗,•, as desired.
Now we show that 1 implies 2. Suppose that we have a linear repair scheme for i∗ using S with bandwidth
b, so that for every i ∈ S and every j ∈ [0, t − 1], there is some set Qi,j ⊂ Ftq so that

ci∗,j =

v · ci,•

i∈S v∈Qi,j

=
i∈S

v
v∈Qi,j

· ci,•

:= wi,j · ci,•
i∈S

for every C ∈ C, where the ﬁnal line deﬁnes the vectors wi,j ∈ Ftq. Moreover, we have

Qi,j := bi ≤ b

i∈S j∈[0,t−1]

i∈S

22

because bi := | j∈[0,t−1] Qi,j| is the number of symbols of Fq returned by node i. Now for j ∈ [0, t − 1], we

deﬁne a repair matrix W (j) by



wi,j

wi(,j•)

=

 −ej

i∈S i = i∗

0 else

where ej denotes the jth standard basis vector in Ftq. It is easily checked that the matrices W (j) are a valid set of repair matrices. First, we see that by deﬁnition of W (j), we have W (j), C = 0 for all C ∈ C and j ∈ [0, t − 1]. Second,
{wi(∗j),• | j ∈ [0, t − 1]} = {−ej | j ∈ [0, t − 1]}
is full rank. Finally, for i = i∗,

{wi(,j•) | j ∈ [0, t − 1]} = {−wi,j | j ∈ [0, t − 1]}

where

wi,j =

v

v∈Qi,j

In particular, all of these vectors live in the set j∈[0,t−1] Qi,j, which has size bi as deﬁned above. Thus, it has dimension at most bi, and so

dim({wi(,j•) | j ∈ [0, t − 1]}) ≤ b
i∈S

This completes the proof.

23

