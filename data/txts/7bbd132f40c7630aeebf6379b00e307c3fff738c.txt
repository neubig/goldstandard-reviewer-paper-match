Explicit Codes Minimizing Repair Bandwidth for Distributed Storage
Nihar B. Shah†, K. V. Rashmi†, P. Vijay Kumar†, Kannan Ramchandran# † Dept. of ECE, Indian Institute Of Science, Bangalore. {rashmikv, nihar, vijay}@ece.iisc.ernet.in
# Dept. of EECS, University of California, Berkeley. kannanr@eecs.berkeley.edu

arXiv:0908.2984v2 [cs.IT] 5 Sep 2009

Abstract—We consider the setting of data storage across n nodes in a distributed manner. A data collector (DC) should be able to reconstruct the entire data by connecting to any k out of the n nodes and downloading all the data stored in them. When a node fails, it has to be regenerated back using the existing nodes. An obvious means of accomplishing this is to use a Reed-Solomon type MDS code where each node stores a single ﬁnite ﬁeld symbol and where one downloads the entire ﬁle for regeneration of a failed node. However, storing vectors in place of symbols makes it easy to extract partial information from a node, and helps in reducing the amount of download required for regeneration of a failed node, termed as repair bandwidth.
Recently, there has been additional interest in storing data in systematic form as no post processing is required when the DC connects to the k systematic nodes. On failure of a systematic node, there is a need to regenerate it back quickly and exactly due to their preferred status. Replacement of a failed node by an exact replica is termed exact regeneration.
In this paper, we consider the problem of minimizing the repair bandwidth for exact regeneration of the systematic nodes. The ﬁle to be stored is of size B and each node can store α = B/k units of data. A failed systematic node is regenerated by downloading β units of data each from d existing nodes. We give a lower bound for the repair bandwidth for exact regeneration of the systematic nodes which matches with the bound given by Wu et al. For d ≥ 2k − 1 we give an explicit code construction which achieves the lower bound on repair bandwidth when the existing k − 1 systematic nodes participate in the regeneration. We show the existence and construction of codes that achieve the bound for d ≥ 2k − 3. Here we also establish the necessity of interference alignment. We prove that the bound is not achievable for d ≤ 2k − 4 when β = 1, except for the case when α = 1 for which any [n, k] MDS code will trivially achieve the bound. We also give a coding scheme which can be used for any d and k, which is optimal for d ≥ 2k − 1.

I. INTRODUCTION
Consider a scenario where a ﬁle of size B is to be stored in a distributed manner across n storage nodes. A data collector (DC) should be able to reconstruct the entire ﬁle by downloading data stored in any k out of n nodes. Each node can store α units of data (symbols) given by

α = B/k

(1)

When a node fails, the failed node has to be regenerated back by downloading β symbols each from d existing nodes as shown in Figure 1. We consider the problem of minimizing the repair bandwidth for exact regeneration of the systematic nodes.
Consider the exact regeneration of a systematic node, say node l by connecting to some set of d nodes. Each symbol

α

α

source

α

α

B symbols

α

node 1

node 2

β

node 3

β

β

node 4 β

node 5

=

node 5

Fig. 1. An illustration of exact regeneration: On failure of node 5, data from nodes 1 to 4 is used to regenerate back the same data that node 5 earlier had.

stored is a linear function of the source symbols. By (1)

the linear functionals associated with the symbols stored in

any k − 1 of the d nodes are linearly independent of those

associated with the symbols of node l. Hence an additional α

linear functionals are necessary to exactly regenerate node l.

From this it follows that a lower bound on the repair bandwidth

dβ is given by

dβ ≥ α + (k − 1)β

(2)

In particular, for β = 1 we have

d≥α+k−1

(3)

Our focus in the current paper is on the case β = 1. Given a construction for β = 1, constructions for larger β can be obtained by partitioning the data into smaller chunks, and encoding them individually using the construction for β = 1. As reconstruction and regeneration are performed separately on these smaller chunks, additional processing and storage required is greatly reduced.
In general, it is an open problem whether this lower bound is achievable for the problem of exact regeneration of the systematic nodes, and we address this issue in the present paper. For α = 1, we get B = k and the lower bound as d ≥ k. In this case, any [n, k]-MDS code will achieve the lower bound for exact regeneration. Hence, we will consider α > 1 throughout. We have categorized the (k, d) parameter set with respect to the lower bound on repair bandwidth in Figure 2.
In an independent work [2], authors consider the same setting and provide constructions for codes corresponding to a repair bandwidth that is signiﬁcantly higher than the lower bound on repair bandwidth.
We say a code is optimal exact regenerating if it achieves the the lower bound on repair bandwidth for the exact regeneration of systematic nodes. The non-systematic nodes are not the

2

Trade-off not achievable for β=1

Explicit code construction Achievable for any β

2k-7 2k-6 2k-5 2k-4 2k-3 2k-2 2k-1 2k
d
Fig. 2. Categorization of the (k, d) parameter set

2k+1

focus and hence their regeneration is not considered in detail. We assume the naive strategy of downloading the entire ﬁle for the exact regeneration of the non-systematic nodes.
The pioneering paper in this area [1] considers a more general setting in which each node stores slightly more data than the minimum required, namely α = (B/k)ν for some ν ≥ 1, in order to reduce the repair bandwidth. In this scheme, the regenerated node need not be identical to the failed node as long as it maintains all the properties of the system. The authors establish a tradeoff between the amount of storage in each node α and the repair bandwidth dβ. In the present paper, we are interested only in the case ν = 1 which corresponds to the Minimum Storage Regeneration (MSR) point on the tradeoff. The bound given in equation (2) matches with the MSR point on the tradeoff.
In our previous work [3], we also considered the problem of exact regeneration, however for that value of ν > 1 which minimized the repair bandwidth. We gave explicit codes for the other extreme point on the tradeoff, and an approximately exact regenerating code for the MSR point, both of which minimized the repair bandwidth at the respective points.
In the rest of the paper, the results are presented in terms of k and α, as this leads to a more intuitive understanding of the codes. In Section II we give a subspace viewpoint which will be used throughout the paper. Explicit and optimal code constructions for k ≤ α are given in Section III. The existence and construction of optimal codes for k ≤ α + 2 is given in Section IV. In Section V we prove that the lower bound in not achievable for k ≥ α + 3 with β = 1. A coding scheme for any (k, α) parameter set is provided in Section VI which is optimal for k ≤ α.

II. SUBSPACE VIEWPOINT FOR LINEAR CODES

We consider only linear codes in this paper. By a linear

code, we mean that any symbol stored is a linear combination

of the source symbols, and only linear operations are allowed

on them. Deﬁne a vector z of length B consisting of the source

symbols. Let

z1 z =  ... 

zk

where zi is a column vector of length α. Each source symbol can independently take values from Fq, a ﬁnite ﬁeld of size q. Hence, the B source symbols can be thought of as forming a
B-dimensional vector space over Fq. Since the code is linear, any stored symbol can be written
as tz for some column vector . These vectors which specify
the kernels for the stored symbols deﬁne the code, and the
actual symbols stored depend on the instantiation of z. Since
a node stores α symbols, it can be considered as storing α

systematic

1 2

l

=

l

k

m n

non-systematic

Fig. 3. Exact regeneration of systematic node l

vectors of the code, and hence can be represented by a α × B

matrix. We will say that the node stores this matrix.

Linear operations performed on the stored symbols are

equivalent to the same operations performed on the corre-

sponding vectors. Hence storing an α × B matrix is equivalent

to storing a subspace of dimension at most α. However,

from (1) it is clear that each node must store a subspace of

dimension at least α.

For m = 1, . . . , n denote the matrix stored by node m

as G(m) = [G(1m) G(2m) . . . G(km)], where G(lm), l =

1, . . . , k are α × α matrices. The α symbols stored by node

m are G(m)z = G(lm) as g(jml ).

k l=1

G(l m) z l .

We

will

denote

the

j th

row

of

There are n storage nodes, out of which k are systematic

and store α data symbols each in uncoded form. For m =

1, . . . , k, systematic node m stores the symbol set zm. Thus for l = 1, . . . , k,

G(m) = Iα if l = m

(4)

l

0α if l = m

where 0α is α × α zero matrix, and Iα is α × α identity matrix. Hence, for any non-systematic node m, G(lm) denotes the components along systematic node l that are stored in node

m.

For regeneration of a failed systematic node, d other nodes

provide one symbol each. We say that each node passes a

vector for the regeneration of the failed node. In the vectors

passed by the non-systematic nodes, the components along the

existing systematic nodes constitute interference.

Let D denote the set of d existing nodes used for regeneration of systematic node l. Let v(Dm,l) = [v(Dm,1,l) · · · v(Dm,k,l)]
represent the vector passed by node m ∈ D for the re-

generation of node l ∈/ D (as shown in Figure 3) where v(Dm,i,l), (i = 1, . . . , k) is an α-length row vector representing
the component along the symbols of the systematic node i.
Thus, v(Dm,i,l), (i = 1, . . . , k, i = l) constitute interference. Let x(Dm,l) = [x(Dm,1,l) . . . x(Dm,α,l)] be the coefﬁcients of the linear combination of the rows of G(m) to obtain the vector that node

m passes for regeneration of systematic node l. For brevity,

we will discard the subscript D from the notation and the set

of d nodes being used for regeneration will be clear from the

context. Thus,

v(m,l) = x(m,l)G(m)

(5)

3

Throughout this paper, we use superscripts to refer to the node numbers, and subscripts to index the elements of any matrix. No distinction is made between row and column vectors and the orientation of the vector under consideration is clear from the context. ei represents an α-length unit vector with 1 in ith position and 0 elsewhere. We say two vectors are aligned if they are linearly dependent.
III. OPTIMAL EXPLICIT CODE FOR k ≤ α
In this section an explicit linear construction is given, which achieves optimal exact regeneration of systematic nodes for k ≤ α. The construction assumes that when a systematic node fails, the existing k − 1 systematic nodes along with any α non-systematic nodes participate in the regeneration. First, we provide a code construction for k = α. Codes for any k < α can be obtained by modifying the code for k = α. Initially, a simple example is given to illustrate the code.

A. Example

Take k = α = 3. This gives d = 5 and B = 9. Thus each node stores a 3 × 9 matrix. Let n = 6 and q = 7.
Let the ﬁrst three nodes be systematic. Hence,

G(1) = [I3 03 03]

(6)

G(2) = [03 I3 03]

(7)

G(3) = [03 03 I3]

(8)

 ψ1(4) ψ2(4) ψ3(4)  Let Ψ3 =  ψ1(5) ψ2(5) ψ3(5)  be a 3 × 3 Cauchy matrix
ψ1(6) ψ2(6) ψ3(6) [5]. Any submatrix of a Cauchy matrix is full rank.
The three non-systematic nodes store the matrices G(m), m = 4, 5, 6, given by

2ψ1(m) 0 0

2ψ2(m) ψ1(m)
0

2ψ3(m) 0
ψ1(m)

ψ2(m) 2ψ1(m)
0

0 2ψ2(m)
0

0
2ψ3(m) ψ2(m)

ψ3(m) 0
2ψ1(m)

0
ψ3(m) 2ψ2(m)

0
0 2ψ3(m)

1) Regeneration: For the regeneration of systematic node l (∈ {1, 2, 3}), each non-systematic node passes its lth row. The choice of the non-systematic node matrices is such that in the vectors passed for regeneration of a systematic node, components along the existing systematic nodes (which constitute interference) are aligned. For example, consider regeneration of systematic node 1. Each non-systematic node passes its ﬁrst row. First rows of G(m), m = 4, 5, 6, have components along the systematic nodes (nodes 2 and 3) aligned in the direction [1 0 0]. Now, the second and third systematic nodes pass [0 0 0 1 0 0 0 0 0], and [0 0 0 0 0 0 1 0 0] respectively and cancel out the interference leaving behind the matrix [Ψ3 03 03]. Since Ψ3 is invertible, systematic node 1 can be exactly regenerated.
2) Reconstruction: To reconstruct the entire data, DC can connect to any three nodes. For reconstruction to be possible, the 9 × 9 matrix formed by juxtaposing the node matrices of these three nodes one below the other should be non-singular.
Reconstruction is trivially satisﬁed when the data collector connects to all the three systematic nodes. Suppose, the data

collector connects to two systematic nodes and one nonsystematic node. For example, suppose DC connects to nodes 2, 3 and 4. For reconstruction, we need the following matrix to be non-singular:

 2ψ(4) 2ψ(4) 2ψ(4)  A1 = G(14) =  01 ψ2(24) 03  (9)

0

0

ψ3(4)

which is full rank since the elements of a Cauchy matrix are
non-zero.
Consider the data collector connecting to one systematic
node and two non systematic nodes. For example, suppose it connects to nodes 1, 4, and 5. Since all symbols of node 1 are available, G(14) and G(15) can be cancelled out. Hence for reconstruction to be possible the matrix B1 given below must be full rank.

B1 =

G(24) G(25)

G(34) G(35)

Claim: The matrix B1 is full rank. Proof: For i = 2, 3, 1 (in this order), group the ith rows
of the two non-systematic nodes together to give matrix

 2ψ1(4)  2ψ1(5)
 B2 =  0
0 
 ψ2(4)
ψ2(5)

2ψ2(4) 2ψ2(5)
0
0
0
0

2ψ3(4) 2ψ3(5) ψ2(4) ψ2(5)
0
0

0
0
2ψ1(4) 2ψ1(5) ψ3(4) ψ3(5)

ψ3(4) ψ3(5) 2ψ2(4) 2ψ2(5)
0
0


0

0

2ψ3(4)

 

2ψ3(5) 

0

0

Let Ψ2 =

ψ2(4) ψ2(5)

ψ3(4) ψ3(5)

Ψ2 is a submatrix of the Cauchy matrix Ψ3 and hence is

invertible. Multiply the three groups of two rows each by Ψ−2 1

to obtain

Ψ−2 1 03

03

B3 = 03 Ψ−2 1 03 B2

03

03 Ψ−2 1

φ 2 0 0 0 0

φ 0 2 0 1 0

 =

0

0

1

φ

2

0 

0 0 0 φ 0 2

1 0 0 0 0 0

000100

(10) (11)

where φ is some arbitrary value. Rows 1, 4, 5, 6 (and columns 1, 2, 4, 6) are linearly independent of all others (this includes all the columns containing φ) and hence be eliminated to obtain,

B4 =

21 12

which is full rank.
Now consider the case of DC connecting to three non-
systematic nodes. Let C1 be the matrix formed by juxtaposing the matrices stored in these three nodes one below the other.
Claim: The matrix C1 is full rank. Proof: In C1, group the ith (i = 1, 2, 3) rows of all the
three nodes together to obtain the matrix C2. Thus,

C2 =

(12)

4


grp1   
grp2    
grp3

2ψ1(4) 2ψ1(5) 2ψ1(6)
0
0
0
0
0
0

2ψ2(4) 2ψ2(5) 2ψ2(6) ψ1(4) ψ1(5) ψ1(6)
0
0
0

2ψ3(4) 2ψ3(5) 2ψ3(6)
0
0
0 ψ1(4) ψ1(5) ψ1(6)

ψ2(4) ψ2(5) ψ2(6) 2ψ1(4) 2ψ1(5) 2ψ1(6)
0
0
0

0
0
0 2ψ2(4) 2ψ2(5) 2ψ2(6)
0
0
0

0
0
0
2ψ3(4) 2ψ3(5) 2ψ3(6) ψ2(4) ψ2(5) ψ2(6)

ψ3(4) ψ3(5) ψ3(6)
0
0
0 2ψ1(4) 2ψ1(5) 2ψ1(6)

0
0
0
ψ3(4) ψ3(5) ψ3(6) 2ψ2(4) 2ψ2(5) 2ψ2(6)

0
0 0
 0
0 
0 
2ψ3(4)  2ψ3(5) 
2ψ3(6)

Multiply the 3 groups of 3 rows each by Ψ−3 1 to get a matrix C3 given by

As illustrated in the example, this choice makes the interference in the vectors passed by non-systematic nodes for the regeneration of a failed systematic node aligned. This enables the existing systematic nodes to cancel the interference by passing one symbol each.
1) Regeneration: Consider regeneration of systematic node ˆl(∈ {1, . . . , k}). All non-systematic nodes who participate in the regeneration pass their ˆlth row, i.e. if non-systematic node m(∈ {k + 1, . . . , n}) participates in the regeneration, then it passes

Ψ−3 1 03

03

C3 = 03 Ψ−3 1 03 C2

03

03 Ψ−3 1

2 0 0 0 0 0 0 0 0

020100000





0 0 2 0 0 0 1 0 0

 

0

1

0

2

0

0

0

0

0

 

= 0 0 0 0 2 0 0 0 0 





0 0 0 0 0 2 0 1 0





0 0 1 0 0 0 2 0 0

0 0 0 0 0 1 0 2 0

000000002

Rows 1, 2 and 3 in the groups 1, 2 and 3 respectively (i.e rows 1, 5 and 9) are clearly independent of all others (and so are the corresponding columns). The remaining 6×6 submatrix can be rearranged to get the following form:

2 1 0 0 0 0

1 2 0 0 0 0

C4

 =

0

0

2

1

0

0 

0 0 1 2 0 0

0 0 0 0 2 1

000012

This is a block diagonal matrix, and since q = 7, is full rank. Thus the matrix C1 is full rank.

B. Explicit General Code Construction for k = α
Let Ψ be an (n − k) × α Cauchy matrix [5] with elements drawn from Fq. i.e,

v(m,ˆl) = [gˆ(l,m1 ) . . . gˆ(l,mk )]

(16)

The systematic node l (l = 1, . . . , k, l = ˆl) passes

v(l,ˆl) = [0 . . . 0 eˆ 0 . . . 0]

(17)

l

with eˆl in the lth position. From equation (15), gˆ(l,ml ) are all aligned along the direction
of eˆ. Hence v(l,ˆl) can be used to remove interference along
l
the systematic node l from v(m,ˆl), ∀m participating in the
regeneration. Also from equation (15), gˆ(l,mˆl ) are rows of the Cauchy
matrix Ψ, and hence are linearly independent. Using these α linearly independent vectors, the systematic node ˆl can be
regenerated.
2) Reconstruction: For reconstruction to be successful, the matrices stored in the k nodes to which the DC connects, when juxtaposed one below the other, should form a B × B full rank matrix. Call this the reconstruction matrix R. If the DC connects to the k systematic nodes, then reconstruction is trivially satisﬁed. Consider DC connecting to p non-systematic nodes, and k − p systematic nodes, 1 ≤ p ≤ k. Let δ1, . . . , δp be the p non-systematic nodes to which DC connects and let Ω1, . . . , Ωp (Ω1 < . . . < Ωp) be the p systematic nodes to which DC does not connect.
Reconstruction is successful if and only if the pα × pα matrix R formed by components along systematic nodes Ω1, . . . , Ωp in G(δ1), . . . , G(δp) is non-singular.

ψ(k+1)

ψ(k+2)





Ψ= 

..

 

.





ψ(n)

(13)

G (δ1) GΩ(δ11) G(Ωδ21) · · · G(Ωδp1)

R =  ...  =  ... ... ... 





G (δp)

G(Ωδ1p) G(Ωδ2p) · · · GΩ(δpp)

(18)

where ψ(i) = [ψ1(i) . . . ψα(i)], i = k + 1, . . . , n are α-length

row vectors. Any submatrix of a Cauchy matrix is full rank.

The minimum ﬁeld size required for the construction of this

Cauchy matrix is:

q ≥ α+n−k

(14)

Theorem 1: R is full rank. The proof of Theorem 1 is provided in Appendix. The steps followed in the proof are similar to the ones used in the example.

Note that since n − k ≥ α ≥ 2, we will have q ≥ 4. For m = k + 1, . . . , n, i, j = 1, . . . , α, set

g(m) =
ij

ψ(m) ψj(m)ei,

if i = j if i = j

where is any arbitrary value such that = 0 and Note that there always exists such a value if q ≥ 4.

(15) 2 = 1.

C. Explicit Code construction for k < α
For a given (k, α) ﬁrst construct the code for k = α. The theorem given below shows the existence and construction for any k < α.
Theorem 2: If there exists a (k, α) linear code for exact regeneration of the systematic nodes, then there also exists a (kˆ, α) linear code for any kˆ ≤ k.

5

Proof: Suppose there exists an (k, α) code for exact regeneration of the systematic nodes. From each node matrix, remove the last (k − kˆ)α columns so that now G(m) is of the size α × kˆα. Thus, we will have Bˆ = kˆα data symbols. Consider only the set of ﬁrst kˆ systematic nodes and all the non-systematic nodes. This forms a (kˆ, α) code.
Reconstruction: Suppose the DC connects to systematic nodes and kˆ − non-systematic nodes. This case is same as the case in original (k, α) code where the DC connects to the removed k − kˆ systematic nodes along with the above systematic nodes and kˆ − non-systematic nodes. Hence, the DC can reconstruct Bˆ data symbols.
Regenration: During regeneration of a systematic node, we have dˆ = α + kˆ − 1 = d − (k − kˆ). All the α nonsystematic nodes participating in the regeneration pass exactly the same vector as in the original code. Since the last (k −kˆ)α column sets have been removed from the non-systematic node matrices, there is no interference from the data symbols corresponding to the removed k − kˆ systematic nodes. All the interference which is present are aligned and the components along the failed systematic node span an α-dimensional space as in the original code. Hence k − kˆ lesser vectors will be able to regenerate the failed node.
Remark: The above construction is optimal for β = 1. For any higher β, the data to be stored can be split into smaller chunks, which can be encoded individually using this construction for β = 1. Hence, this construction is optimal for any value of β.
IV. EXISTENCE AND CONSTRUCTION FOR k ≤ α + 2
The existence and construction of exact regenerating codes which meet the bound given by (3) is shown for the parameter set k ≤ α + 2. This proof assumes that when a systematic node fails, the existing k − 1 systematic nodes participate in regeneration along with any α non-systematic nodes, passing one symbol each. The proof can be extended to the general case as well, where any d existing nodes can participate in the regeneration.
A. Approach
In the sequel the reconstruction and regeneration conditions will be cast as product of rational polynomials. We will need to show that there exists a set of non-zero values such that these polynomials are all well deﬁned and non-zero. In [4] a similar problem is arises in proving the existence of capacity achieving multicast network codes, but with respect to polynomials. But the argument can be easily extended to rational polynomials. If gf11((xx)) , . . . , gfpp((xx)) are rational polynomials, then deﬁne fp+1(x) = gcd(g1(x), . . . , gp(x)). There exists a solution to x such that the product of the rational polynomials is well deﬁned and non-zero if and only if there exists a solution to x such that the product of the polynomials f1(x), . . . , fp+1(x) is non-zero. Hence, the algorithm given by Koetter and Medard in [4] can be used to ﬁnd the values of the variables, provided the ﬁeld size is large enough.

B. Necessary Properties

1) Necessary Properties for Reconstruction:
Lemma 3: For reconstruction property to hold, for any nonsystematic node m, G(lm) must be full rank ∀l ∈ {1, . . . , k}.
Proof: Given some m and l, suppose the DC connects to the k − 1 systematic nodes other than l, and to the nonsystematic node m. From the k − 1 systematic nodes, the DC recovers (k − 1)α data symbols. Hence column sets corresponding to these k − 1 systematic nodes (i.e Gˆ(lm), ˆl = 1, . . . , k ˆl = l) can be removed from G(m) leaving behind only G(lm). Thus, for successful reconstruction, G(lm) should be full rank.
2) Necessary Properties for Exact Regeneration:
Lemma 4: For the regeneration of a failed systematic node l (∈ {1, . . . , k}), the components along node l in the vectors passed by the α non-systematic nodes participating in the
regeneration must be linearly independent. Proof: Consider the regeneration of a failed systematic
node l, by connecting to k − 1 existing systematic nodes m1, . . . , mk−1 and α non-systematic nodes mk, . . . , mk−1+α. Let matrix
 v(m1,l)  V =  ...  = V1 V2 · · · Vk (19)
v(mk−1+α,l )


 where Vi = 


v i(m1 ,l) ...


 , (i = 1, . . . , k) is a d × α ma

v (mk−1+α,l )
i

trix representing the component of V along the ith systematic

node. For successful regeneration of l, we need an α×d matrix

Y such that

Y V = G(l)

(20)

Consider the component of Y V along node l. Since G(ll) = Iα, we need rank(Y Vl) ≥ α. Since the k − 1 other systematic
nodes cannot provide any vector in the direction of l, we get v(im,l) = 0 for i, m = 1, . . . , k, i = m, l = m. Thus the ﬁrst k − 1 rows of Vl are 0. Hence, the remaining α rows
of Vl, which are the components along the failed node in the
vectors given by the non-systematic nodes, have to be linearly
independent.
Remark: Since only the last α rows of Vl are non-zero, the
last α columns of Y should also be linearly independent.
Lemma 5: (Need for Interference Alignment) For the regeneration of a failed systematic node l, and for any ˆl ∈ 1, . . . , k, ˆl = l, the vectors vˆ(lm,l), ∀m ∈ {k + 1, . . . , n} should be aligned.
Proof: Using the same notations as in Lemma 4, consider the components along any other systematic node ˆl. Since Gˆ(ll) = 0α, we need Y Vˆl = 0. Since the other k−2 systematic nodes provide 0 component along node ˆl, the corresponding rows of Vˆl will be zero. Let V˜ˆl (α + 1 × α) and Y˜ (α × α + 1) be sub-matrices of Vˆl and Y with the k−2 zero rows in Vˆl and the corresponding columns in Y removed. Thus we need Y˜ V˜ˆl = 0. Since rank(Y˜ ) ≥ α, it forces rank(V˜ˆl) ≤ 1. Hence, for the regeneration of a systematic node, in the vectors passed by the

6

α non systematic nodes, the components along any existing systematic node should be aligned in the same direction. By choosing different sets of α non-systematic nodes, we get that alignment should hold for all the non-systematic nodes.

Theorem 6: A necessary and sufﬁcient condition for exact regeneration of a failed systematic node l by connecting to the existing k − 1 systematic nodes and α non-systematic nodes is that the set of vectors passed by these non-systematic nodes satisfy Lemmas 4 and 5.

Proof: Necessity: Proved in Lemmas 4 and 5 itself.
Sufﬁciency: Suppose Lemma 5 is satisﬁed. Then, in the vectors
passed by the non-systematic nodes, the components along any other systematic node ˆl are aligned in the same direction, i.e. vˆ(lm,l) = κˆ(lm,l)wˆ(ll) where m is any non-systematic node, wˆ(ll) is a vector independent of m, and κ’s are some constants in Fq. The systematic node ˆl passes vˆ(lˆl,l) = wˆ(ll) with the components of v(ˆl,l) along other nodes as 0. Hence, this can be used to subtract the component in v(m,l) along any other systematic node ˆl, to give a set of vectors

k

v˜(m,l) = v(m,l) −

κ(im,l)v(i,l)

i=1,i=l

(21)

Since v(lˆl,l) = 0 for ˆl = 1, . . . , k, ˆl = l, we get v˜(lm,l) = vl(m,l). Since Lemma 4 is satisﬁed, the components of these α vectors along node l are independent, and hence span the
α-dimensional subspace stored in node l.

C. Structure of the Code

For m = k + 1, . . . , n let,

G(im) = Λ(im)Hi(m), i = 1, . . . , k

(22)

where

Λ(im)

=

diag

{

λ(1m,i )

,

.

.

.

,

λ

(m) α,i

}

is

an

α×α

diagonal

matrix and

h(1m,i )

(m) h(2m,i )

Hi

= 

..

 

(23)

.

h(αm,i)

where h(i,mj ) is an α-length row vector. Also set

λ(i,mi ) = 1, i = 1, . . . , k

(24)

Regeneration: For m = k + 1, . . . , n, l = 1, . . . , k, let

v(m,l) = x(m,l)G(m)

(25)

For l = 1, . . . , α, set

x(m,l) = el ∀m ∈ {k + 1, . . . , n}

(26)

i.e. for regeneration of the systematic node l(∈ {1, . . . , α}), each non-systematic node passes the lth row of its node matrix.

Thus to satisfy Lemma 5 we choose,

h(i,mj ) = hi,j , m = k + 1, . . . , n

(27)

i = 1, . . . , α,

j = 1, . . . , k, j = i

Thus, for regeneration of systematic nodes 1, . . . , α, the interference is aligned, and hence can be subtracted out.
Reconstruction: The DC connects to any set of k nodes and downloads all the kα data symbols stored in them.

D. Existence and construction for k = α + 2
Consider regeneration of the systematic node α + 1. By Lemma 5, the component along the systematic node l, ∀l ∈ {1, . . . , α} in the vector passed by non-systematic nodes need to be aligned in one direction. This leads to the following set of n − k − 1 equations: for m = k + 2, . . . , n,

κ(lm,α+1)x(k+1,α+1)G(lk+1) = x(m,α+1)G(lm) (28)

Similarly, alignment for the regeneration of the systematic node α + 2 leads to another set of n − k − 1 equations: m = k + 2, . . . , n,

κ(lm,α+2)x(k+1,α+2)G(lk+1) = x(m,α+2)G(lm) (29)

for some constants κ’s ∈ Fq. Set

κ(lm,α+1) = κ(lm,α+2) = κ(lm) (say)

(30)

For all m ∈ {k + 2, . . . , n}, multiply equation (28) by (x(lm,α+1))−1 and (29) by (x(lm,α+2))−1 and subtract the two. h(l,ml ) gets eliminated and a homogeneous equation in terms of h1,l, . . . , hl−1,l, h(l,kl+1), hl+1,l, . . . , hα,l remains. One way to satisfy this equation is to equate all the scalar coefﬁcients to
zero.
This gives, for l = 1, . . . , α, m = k + 2, . . . , n and i =
1, . . . , α, i = l,

λ(i,ml ) = κ(lm)λ(i,kl+1) (x(lm,α+1))−1x(ik+1,α+1) − (xl(m,α+2))−1

x(k+1,α+2) (x(m,α+1))−1x(m,α+1)−(x(m,α+2))−1x(m,α+2) −1

i

l

i

l

i

(31)

Equation (31) ensures that second set of equations (i.e. 29) are satisﬁed whenever the ﬁrst set (i.e. 28) is satisﬁed.
Note that any polynomial containing a λ(i,ml ) (i = l) term will be a rational polynomial. For such polynomials, we will obtain an assignment which will simultaneously ensure that none of the inverted terms are zero, and the polynomial is also not zero.
Now only the ﬁrst set of equations have to be satisﬁed, for which, using equation (28) make the following assignments, for m = k + 2, . . . , n

h(l,ml ) = (x(lm,α+1))−1[κ(lm){h(l,kl+1)x(lk+1,α+1)+

α

α

λ(i,kl+1) x(i k+1,α+1) hi,l } −

λ(i,ml )x(im,α+1)hi,l]

i=1,i=l

i=1,i=l

(32)

7

The component along systematic node α + 1 needs to be aligned in the vector passed for the regeneration of systematic node α + 2 and vice versa. Hence the alignment of systematic nodes α + 1 and α + 2 result only in one set of n − k − 1 equations each. Consider the regeneration of the (α + 2)th systematic node. By Lemma 5, the the component along the (α + 1)th systematic node in the vector passed by nonsystematic nodes need to be aligned in one direction. This leads to the following set of n − k − 1 equations: For m = k + 2, . . . , n,

κ(αm+)1x(k+1,α+2)Hα(k++11)Λ(αk++11) = x(m,α+2)Hα(m+)1Λ(αm+)1 (33)

By equation (27) we have

Hα(m+)1 = Hα(k++11) = Hα+1 (say)

(34)

Thus, equating the coefﬁcients to zero, we get for i = 1, . . . , α,

λ(i,mα)+1 = κ(αm+)1xi(k+1,α+2)λ(i,kα++11)(x(im,α+2))−1

(35)

Similarly, for regeneration of node α + 1, we need to align components along node α + 2 which leads to

λ(i,mα)+2 = κ(αm+)2xi(k+1,α+1)λ(i,kα++12)(x(im,α+1))−1

(36)

Regeneration: Exact regeneration of each one of the systematic nodes l ∈ {1, . . . , α} results in a condition

 h(l,ml 1) 

 det 

...

 =0

(37)





h(l,ml α)

where m1, . . . , mα are the α non-systematic nodes used for regeneration After substituting for h(l,ml i), i = 1, . . . , α from equation (32), this condition evaluates to a rational polynomial,
which can be shown to be not identically equal to zero by the
following assignments:

κ(lm) = 1, λ(i,kl+1) = 1, h(l,kl+1) = el, hi,l = ei,

x(ik+1,α+1) = 0, xi(k+1,α+2) = 1, xl(k+1,α+1) = 1

x(lm,α+1) = 1, x(lm,α+2) = 1, x(im,α+1) = 1

x(im,α+2) = (m − k)−j + 1

(38)

for i = 1, . . . , α, i = l, m ∈ {m1, . . . , mα}, m = k + 1 and j = i if i < l, j = i − 1 if i > l. This set of assignments makes the matrix under consideration in equation (37) a Vandermonde matrix which is full rank, and ensures that equations (31), (35) and (36) remain valid, provided the ﬁeld size is large enough.

Exact regeneration of systematic nodes α + 1 and α + 2
also result in conditions of rational polynomials being not equal to zero. For exact regeneration of (α + 1)th systematic
node, Lemma 4 should hold. Choose Hα+1 to be a full rank matrix. Lemma 4 implies that the coefﬁcients resulting from
the linear combinations need to be linearly independent, i.e x(m,α+1)Λ(αm+)1 should be linearly independent for any α out of the n − k non-systematic nodes. Express the determinant of
this matrix as a polynomial. To show that this polynomial is not identically zero, we choose Λ(αk++11) = I, κ(αm+)1 =

1, x(im,α+2) = 1, x(ik+1,α+2) = 1 for i = 1, . . . , α, m = k + 2, . . . , n.
From (35), we get Λ(αm+)1 = I. Choose x(im,α+1) = (m − k)i for m = k + 1, . . . , n to make it a Vandermonde matrix

(also ensuring that equations (31), (35) and (36) remain valid),

provided the ﬁeld size is large enough. A similar argument can

be used to obtain a condition for regeneration of node α + 2.

Reconstruction: The condition for reconstruction property

to hold can be expressed as a product of polynomials not

being equal to zero by viewing each determinant as a polyno-

mial. For reconstruction to be successful, the node matrices

corresponding to the k nodes to which the data collector

connects, when juxtaposed one below the other, should form

a B × B full rank matrix. If the data collector connects to the

k systematic nodes, then reconstruction is trivially satisﬁed.

Consider DC connecting to p non-systematic nodes and k − p

systematic nodes, 1 ≤ p ≤ k. Let m1, . . . , mp, (m1 < . . . < mp) be the non-systematic nodes to which it connects. Let l1, . . . , lp, (l1 < . . . < lp) be the p systematic nodes to which it does not connect. Due to the structure of node

matrices of the systematic nodes, we will be left with the

condition of the lα × lα matrix formed by the column sets

l1, . . . , lp of the node matrices of the p non-systematic nodes being non-singular. Thus the polynomial corresponding to this

choice of k nodes is

  Gl(1m1) Gl(2m1) · · · G(lpm1)

  Gl(1m2) Gl(2m2) · · · G(lpm2)

det   ...

...

...

G(l1mp) G(l2mp) · · · G(lpmp)

(39)

We will now show that there exists an assignment of the variables such that this polynomial is not identically zero. For i, j = 1, . . . , p, m1 = k + 1, set
κ(ljmi) = 10 iiff ii == jj (40)

For i = 1, . . . , α, m = k + 2, . . . , n, l = 1, . . . , k set Hl(k+1) = I, Λ(lk+1) = I, x(im,α+1) = 1, x(ik+1,α+1) = 1, x(ik+1,α+2) = 1, x(im,α+2) = (m − k)i. Thus from (31), (32), (35) and (36), we get that this matrix is full rank for a large enough ﬁeld size, and also the equations (31), (35) and (36) remain valid.
Hence, provided that the ﬁeld size is large enough, one can ﬁnd solutions for these variables such that both reconstruction and exact regeneration properties are satisﬁed.

E. Existence and construction for k < α + 2
For a given α, the code described for the previous subsection can by modiﬁed using Theorem 2 to obtain a code for any k < α + 2.
Remark: This achievability scheme is optimal for β = 1. For any higher β, the data to be stored can be split into smaller chunks, which can be encoded individually using this construction for β = 1. Hence, this for any value of β, optimal regeneration for the parameter set k ≤ α + 2 is achievable using this scheme.

8

V. NON-ACHIEVABILITY FOR k ≥ α + 3

We deﬁne two codes to be equivalent if the corresponding nodes of both codes store the same subspace, and pass the same vectors for regeneration of any node. The only difference may be in the representation of what is stored in a node, i.e. in the node matrices.
Lemma 7: If there exists an exact regenerating code for k ≥ α + 1, then there exists an equivalent code with the following property:

h(i,mj ) = hi,j, for i = 1, . . . , α, j = 1, . . . , k, , j = i (41)

for any non-systematic node m. Proof: Consider a code which performs exact regenera-
tion of the systematic nodes. For any non-systematic node m in this code, we will obtain linearly independent vectors in the subspace stored in it one by one, and set them as the rows of its node matrix. By induction we will prove that the matrix of any node will take the following form: G(m) =

 λ(1m,1)h(1m,1)

 λ(2m,1)h2,1

 

...

λ(αm,1)hα,1

for m = k + 1, have to be full

· · · λ(1m,α)h1,α λ(1m,α)+1h1,α+1 · · · λ(2m,α)h2,α λ(2m,α)+1h2,α+1
... · · · λ(αm,α)h(αm,α) λ(αm,α)+1hα,α+1
. . . , n. Note that by Lemma rank matrices.

· · · λ(1m,k)h1,k 

· · · λ(2m,k)h2,k 

...

 

· · · λ(αm,k)hα,k

(42)

3, Hl(m) and Λ(lm)

Let the ﬁrst row of G(m) represent the vector passed by

the non-systematic node m for the regeneration of the ﬁrst

systematic node. From Lemma 5, as the interference from the

remaining k − 1 systematic nodes has to be aligned,

h(1m,j) = h1,j , j = 2, . . . , k

(43)

Hence, the ﬁrst row has to be of the given form. Suppose
the vectors passed for the regeneration of systematic nodes 1, . . . , p − 1 (1 < p ≤ α) are linearly independent in all the non-systematic nodes. By a similar argument, the ﬁrst p − 1 rows of G(m) have to be of the given form.
Now consider the regeneration of the pth systematic node.
Suppose some of the non-systematic nodes (say type A) pass a vector linearly dependent on the ﬁrst p − 1 rows of their
node matrix and some (say type B) pass a linearly independent
vector. Each type B node will have this vector as a new
row in their node matrices. In this set of vectors passed for regeneration of the pth systematic node, consider the component along systematic node (α + 1), i.e. v(αm+,1p). In vectors passed by type A nodes, this vector is a linear combination of hi,α+1, i = 1, . . . , p−1, whereas in vectors passed by type B nodes, it is linearly independent of hi,α+1, i = 1, . . . , p − 1 (by Lemma 4). But by Lemma 5, these vectors have to be
aligned. Hence there is a contradiction.
Suppose all the non-systematic nodes are of type A. Then
all the vectors passed by non-systematic nodes will be linearly dependent on the ﬁrst p−1 rows of their node matrices. Hence
in all the vectors, the component along systematic node p vp(m,p) will be a linear combination of hi,p, i = 1, . . . , p − 1. These can span at most p − 1 dimensions whereas pth systematic node spans α dimensions. Hence the regeneration

of pth systematic node is not possible.
Hence all the non-systematic nodes should be of type B. i.e they pass linearly independent vectors for the generation of systematic nodes. Along with Lemma 5, this proves that all α rows of the node matrix have to be of the given form.
Henceforth in this section, we will consider all nodes to be of this form.
Remark: In this code, for the regeneration of the pth systematic node (for 1 ≤ p ≤ α), each non-systematic node passes the pth row of its node matrix.
Corollary 8: For l = α + 1, . . . , k, and any non-systematic nodes m and m ,
Hl(m) = Hl(m ) (44)

Corollary 9: For any non-systematic node m and k ≥ α+1, any α out of v(m,1), . . . , v(m,k) are linearly independent.
Proof: In the code given in Lemma 7, the choice of the ﬁrst α systematic nodes was arbitrary. Hence, for a given set of α systematic nodes, an equivalent code can be constructed considering these as the ﬁrst α nodes. Thus, by Lemma 7 the vectors passed by any non-systematic node for regeneration of these systematic nodes will be the α rows of its matrix. Hence they are independent.
Lemma 10: For k ≥ α + 2, for any non-systematic node m,

x(im,l) = 0 for l = α+1, . . . , k, i = 1, . . . , α

Proof: Suppose for some non-systematic node m, l ∈ {α + 1, . . . , k} and i ∈ {1, . . . , α}, x(im,l) = 0. Since for j(∈ {1, . . . , α}), v(m,j) is the jth row of the node matrix of node m, v(m,l) is a linear combination of v(m,j), j = 1, . . . , α, j = i. This is a contradiction to Corollary 9.
Theorem 11: For a linear code with β = 1, exact regeneration of systematic nodes meeting the bound given by (3) is not possible for k ≥ α + 3.
Proof: (By contradiction) Consider any code that achieves exact regeneration of systematic nodes meeting the bound in (3) for k ≥ α + 3. By Corollary 8,

Hi(m) = Hi(m )

(45)

for m, m ∈ k+1, . . . , n, i = α+1, . . . , k. Call these matrices Hi.
Consider regeneration of systematic node (α + 3). By Lemma 5, components corresponding to systematic nodes (α + 1) and (α + 2) are to be aligned. Hence we have

x(k+1,α+3)G(αk++11) = κ1x(k+2,α+3)G(αk++12) x(k+1,α+3)G(αk++21) = κ2x(k+2,α+3)G(αk++22)

(46) (47)

where κ1 and κ2 are some constants in Fq. From equation (45) and since Hα+1 is full rank (Lemma 3), this simpliﬁes to

x(k+1,α+3)Λ(αk++11) = κ1x(k+2,α+3)Λ(αk++12) x(k+1,α+3)Λ(αk++21) = κ2x(k+2,α+3)Λ(αk++22)

(48) (49)

=⇒ κ1x(k+2,α+3)Λ(αk++12)(Λ(αk++11))−1 = κ2x(k+2,α+3)Λ(αk++22)(Λ(αk++21))−1

(50)

9

Since no element of x(k+2,α+3) is zero (Lemma 10), and m = k + 1, . . . , n, i = 1, . . . , k, j = 1, . . . , α, j = µ(i).

the Λ matrices are diagonal, we get κ1Λ(αk++12)(Λ(αk++11))−1 = κ2Λ(αk++22)(Λ(αk++21))−1 (51)
Since none of the elements of the diagonal Λ matrices are zero,

Let b(im) = [b(i,m1 ) · · · b(i,mµ()i)−1 0 b(i,mµ()i)+1 · · · b(i,mα)] (56)
Let matrix Bi(m) be an α × α matrix such that it has b(im) as its µ(i)th row, and zeros elsewhere. Also let

κ1 = 0, κ2 = 0

(52)

Similarly, on regeneration of systematic node α + 2, the

˜b(im) = [b(i,m1 ) · · · b(i,mµ()i)−1 a(im) b(i,mµ()i)+1 · · · b(i,mα)] (57)

components along α + 1 and α + 3 have to be aligned. Hence Let the node matrix of non-systematic node m (∈ {k +

κ˜1Λ(αk++12)(Λ(αk++11))−1 = κ˜2Λ(αk++32)(Λ(αk++31))−1 (53) 1, . . . , n}) be

G(im) = a(im)Iα + Bi(m)

(58)

where κ˜1 and κ˜2 are some other non-zero constants in Fq. for i = 1, . . . , k, where Iα is an α × α identity matrix. Now, for regeneration of systematic node (α + 3) the

component provided along it by the ﬁrst non-systematic node For example, suppose k = 5, α = 3 and the systematic

is,

nodes are grouped as follows: {1, 2}, {3}, {4, 5}. Then,

x(k+1,α+3)Λ(αk++31)Hα+3

the node matrix stored by non-systematic node m, (∈ {k + 1, . . . , n}) is

= κ1x(k+2,α+3)Λ(αk++12)(Λ(αk++11))−1Λ(αk++31)Hα+3 (54) G(m) =

(59)

The

right

hand

side

of

(54)

is

obtained

by

substituting

 for

a(1m)

b(1m,2)

b(1m,3)

a(2m)

b(2m,2)

b(21,3)

a(3m) 0

0

a(4m) 0

0

a(5m) 0


0

x(k+1,α+3) from (48).

  0

a(1m) 0

0

a(2m) 0

b(3m,1) a(3m) b(3m,3) 0

a(4m) 0

0

a(5m) 0

0

0

a(1m) 0

0

a(2m) 0

0

a(3m) b(4m,1) b(4m,2) a(4m) b(5m,1) b(5m,2) a(5m)

For regeneration of systematic node (α + 3) the component

provided along it by the second non-systematic node is,

group 1

group 2

group 3

x(k+2,α+3)Λ(αk++32)Hα+3 = κ˜1κ˜2−1x(k+2,α+3)Λ(αk++12)(Λ(αk++11))−1Λ(αk++31)Hα+3 (55)
The right hand side of (55) is obtained by substituting for Λ(αk++32) from (53).
From equations (54) and (55), it is clear that components along systematic node (α + 3) node in the vectors passed by the two non-systematic nodes are linearly dependent. Hence by Lemma 4 regeneration of node (α+3) node is not possible.
Since regeneration is not possible by connecting to k − 1 systematic nodes and α non-systematic nodes, it will not be possible even in a general setting of using any d nodes for regeneration.
VI. A CODING SCHEME FOR ANY (k, α) In this section, a coding scheme is described which can be used for any (k, α) parameter set. This scheme assumes that when a systematic node fails, the existing k − 1 systematic nodes and any α non-systematic nodes participate in the regeneration. This can be easily extended to a more general case.
A. Scheme Description

1) Regeneration: Consider regeneration of systematic node
l (∈ {1, . . . , k}). α non-systematic nodes, say m1, . . . , mα pass the µ(l)th row of their node matrices. The systematic
nodes in other groups, say node l in group µ(l ) (µ(l ) =
µ(l)), pass the vector [0 · · · 0 eµ(l) 0 · · · 0] where the unit vector is in the position l . Since the component along node l in the vector passed by any non-systematic node is a(lm)eµ(l), it can be subtracted out. The existing systematic nodes in
group µ(l) pass all their symbols and hence components along
these nodes can also be cancelled out. Hence, for regeneration,
the components given out by the non-systematic nodes along the direction of the lth systematic node should be linearly
independent. Thus, regeneration condition for systematic node
l with this choice of α non-systematic nodes reduces to a
polynomial being non-zero i.e

 ˜bl(m1) 

 

˜b(m2)

 

det  

l
.

 

(60)

 .. 





˜b(l mα )

Similar polynomials are obtained ∀l, and for all sets of α non-systematic nodes. Clearly, none of these polynomials are identically zero.

Divide the k systematic nodes into α groups. Similar to the scheme given by Wu et al. [2], for regeneration of a systematic node, the existing systematic nodes in the same group as the failed node pass all their α symbols. The remaining systematic nodes and some α non-systematic nodes pass one symbol each.
The structure of the code is as follows. Let µ(l) ∈ {1, . . . , α} denote the group to which the systematic node l belongs. Consider a set of variables a(im) and b(i,mj ), for

2) Reconstruction: If the data collector connects to the k systematic nodes, then reconstruction is trivially satisﬁed. Consider DC connecting to p non-systematic nodes, and k − p systematic nodes, 1 ≤ p ≤ k. Let m1, . . . , mp, (m1 < . . . < mp) be the non-systematic nodes to which it connects. Let l1, . . . , lp, (l1 < . . . < lp) be the p systematic nodes to which it does not connect. As in Section III-B2, reconstruction condition leads to following polynomial not equal to zero

10

Lower bound Our scheme Scheme by Wu et al.
Fig. 4. Average repair bandwidth(γ) required for exact regeneration of the systematic nodes with β = 1 is plotted for various values of d for k = 9.

Lemma 12: The average repair bandwidth for exact regen-

eration of systematic nodes using the above described scheme

is minimum when the groups are uniformly divided.

Proof: Directly follows from equation (64)

Let

s = k/α

(65)

Uniform division of groups would imply that out of the α groups, k mod α groups contain s + 1 nodes each and the rest contain s nodes each.
The average amount of download required for exact regeneration of the systematic nodes in our scheme is compared with the scheme proposed by Wu and Dimakis [2] (Group interference alignment) in Figure 4. The lower bound on the repair bandwidth is also plotted along side. It can be seen that for d ≥ 2k − 1 (i.e. k ≤ α) our scheme achieves the lower bound. For smaller values of d, the amount of data downloaded is higher. However, whether this achieved value of repair bandwidth is optimal or not is not known for d ≤ 2k−4.

condition.

  G(l1m1) G(l2m1) · · · G(lpm1)

 G(m2) G(m2) · · · G(m2) 

det 

l1
.

l2
.

lp
.

 ..

..

.. 

Gl(1mp) Gl(2mp) · · · Gl(pmp)

(61)

We will now show that there exists an assignment of the variables such that this polynomial is not identically zero. Set

b(im) = 0 ∀i, m

(62)

a(limj) = 10 iiff ii == jj (63)

By these assignments, the reconstruction matrix becomes an identity matrix, which is non-singular. Thus, the regeneration and reconstruction properties evaluate to the condition of the product of certain polynomials being non-zero. It is shown that none of these polynomials is identically zero. Assignment of values to the variables satisfying all the conditions can be obtained using the algorithm given by Koetter and Medard [4].
This scheme can be extended to regeneration using any combination of systematic and non-systematic nodes provided that the systematic nodes in the same group as the failed node participate in regeneration. The extended proof will involve a few more conditions of polynomials being non-zero.

B. Analysis

For k ≤ α, if all the α nodes are kept in different groups, this scheme achieves the minimum repair bandwidth and hence is optimal.
For k > α, the amount of data to be downloaded for exact regeneration of a systematic node depends on the number of nodes in its group. If there are η nodes in a group, the total number of symbols required to regenerate a node in that group, is given by:

γ = (η − 1)α + (d − η + 1)

(64)

REFERENCES
[1] Y. Wu, A. G. Dimakis and K. Ramchandran, “Deterministic Regenerating codes for Distributed Storage,” Proc. Allerton Conf., Sep. 2007.
[2] Y. Wu and A. Dimakis, “Reducing Repair Trafﬁc for Erasure CodingBased Storage via Interference Alignment,” Proc. ISIT, Jul. 2009.
[3] K. V. Rashmi, Nihar B. Shah, P. Vijay Kumar and Kannan Ramchandran, “Explicit Construction of Optimal Exact Regenerating Codes for Distributed Storage,” to appear in Proc. Allerton Conf., Sep 2009. Available online at arXiv:0906.4913 [cs.IT]
[4] Ralf Koetter and Muriel Medard, “An algebraic approach to network coding,” IEEE/ACM Transactions on Networking, v.11 n.5, p.782-795, Oct. 2003.
[5] Dennis S. Bernstein, Matrix mathematics: Theory, facts, and formulas with application to linear systems theory, Princeton University Press, Princeton, NJ, p.119, 2005.

APPENDIX

Proof of Theorem 1 Proof: Let ω1, . . . , ωk−p (ω1 < . . . < ωk−p) be the
systematic nodes to which DC connects, and Ω1, . . . , Ωp (Ω1 < . . . < Ωp) be the p systematic nodes to which it does not connect. Thus the sets ω1, . . . , ωk−p and Ω1, . . . , Ωp are disjoint. Let δ1, . . . , δp be the p non-systematic nodes to which DC connects. The reconstruction matrix R is given by

G (δ1) GΩ(δ11) G(Ωδ21) · · · G(Ωδp1)

R =  ...  =  ... ... ... 





G (δp)

G(Ωδ1p) G(Ωδ2p) · · · GΩ(δpp)

(66)

Group the Ωt1h rows of G (δm) (m = 1, . . . , p) as the ﬁrst p rows of a new matrix R , then Ωt2h rows as the next p rows, and so on. Hence, row number Ωi of G (δm) becomes the row number p×(i−1)+m in R . Below these, group the ω1th rows, then the ω2th and so on. Row number ωi of G (δm) becomes the row number p2 + p × (i − 1) + m in R . Hence there are
α groups with p rows each in R . Let S be an p × α matrix with elements [S]i,j = ψj(δi), i =
1, . . . , p, j = 1, . . . , α. Let Ta,b be an p×α matrix with its bth column as [ψa(δ1), . . . , ψa(δp)]t, and rest of the elements zero. Thus, the bth column of Ta,b is identical to the ath column of
S.

11

The columns of R are grouped into p groups of α columns each. Thus the matrix R can be viewed as a block matrix, with each block of size p × α, and the dimension of R being α × p blocks.
Let [R ](i,j) represent the (i, j)th block of R . For i = 1, . . . , p, j = 1, . . . , p we get

S

if i = j

[R ](i,j) = TΩ ,Ω if i = j

(67)

ji

For i = p + 1, . . . , α, j = 1, . . . , p,

[R ](i,j) = TΩj ,ωi−p

(68)

Thus,


     R =     

S
TΩ1 ,Ω2 ...
TΩ1 ,Ωp TΩ1 ,ω1
...

TΩ2 ,Ω1 S ...
TΩ2 ,Ωp TΩ2 ,ω1
...

TΩ3,Ω1 · · · TΩp,Ω1 

TΩ3,Ω2 · · · TΩp,Ω2  ... ... 

TΩ3,Ωp · · ·

S

 



TΩ3,ω1 · · · TΩp,ω1 

... ... 

TΩ1,ωk−p TΩ2,ωk−p TΩ3,ωk−p · · · TΩp,ωk−p (69)
Let S˜ be the p×p matrix formed by the columns Ω1, . . . , Ωp of S. As S˜ is a submatrix of Cauchy matrix Ψ, it is invertible. Let Iˆ be an p × α matrix with columns ω1, . . . , ωk−p having
some arbitrary values (denoted by φ), and the remaining p columns put together forming an identity matrix. Let Eˆa,b be
an p × α matrix with the element at position (a, b) as 1 and

all other elements 0. Multiply each of the α groups of p rows by S˜−1. This will

cause the following transformation in R : S will be replaced by Iˆ and TΩa,b will be replaced by Eˆa,b.

The resultant matrix will be of the form:

 Iˆ

 Eˆ1,Ω2

 

...



 Eˆ1,Ωp

 Eˆ1,ω1

 

...



Eˆ2,Ω1 Iˆ
...
Eˆ2,Ωp Eˆ2,ω1
...

Eˆ3,Ω1 · · · Eˆp,Ω1 

Eˆ3,Ω2 · · · Eˆp,Ω2 

...

...

 



Eˆ3,Ωp · · ·

Iˆ  (70) 

Eˆ3,ω1 · · · Eˆp,ω1 

...

...

 



Eˆ1,ωk−p Eˆ2,ωk−p Eˆ3,ωk−p · · · Eˆp,ωk−p

In the groups of rows p + 1, . . . , α, every row has exactly one non-zero element. Hence these rows and the corresponding columns (ω1, . . . , ωk−p) are independent of all others and can be eliminated. Note that all the φ elements are present only in these columns and hence the actual values of φ do not matter. The resultant matrix will be a p2 × p2 matrix of the following form:

 Ip E2,1 E3,1 · · · Ep,1   E1,2 Ip E3,2 · · · Ep,2   ... ... ... ... ...  (71)
E1,p E2,p E3,p · · · Ip
where Ip is a p × p identity matrix and Ea,b is an p × p matrix with the element in the position (a, b) as 1 and all

other elements 0. For i = 1, . . . , p, the ith row(column) of the ith
row(column) group respectively contains exactly one non-
zero element, and hence is linearly independent of all others.
After eliminating these rows (and corresponding columns) the remaining matrix is rearranged by placing the ith row(column) of the jth group adjacent to the jth row(column) of the ith
group to form:

 1 0 0 ··· 0 0 

1

0 0 ··· 0 0 

 

0

0

1

···

0

0

 

 

0

0

1

···

0

0

 

(72)

 ... ... ...

... ... 





 0 0 0 0 ···

1

0 0 0 0 ··· 1

This is a block diagonal matrix, and since 2 = 1, is full

rank.

In the example of k = α = 3 considered in section III-A2

when the data collector connected to the ﬁrst systematic node,

and the ﬁrst two non-systematic nodes, we have p = 2, ω1 =

1, Ω1 = 2, Ω2 = 3, δ1 = 4, δ2 = 5 and

D2

= R,

= 2. Here,

S

=

ψ1(4) ψ2(4) ψ3(4) ,

ψ1(5) ψ2(5) ψ3(5)

TΩ1,Ω2 =

0 0 ψ2(4) , 0 0 ψ2(5)

Iˆ

= φ20 ,

φ02

Eˆ1,Ω2 =

001 0 0 0 and

01 E1,2 = 0 0 .

