arXiv:2006.03042v1 [cs.IT] 4 Jun 2020

This is an extended version of an IEEE ISIT 2020 paper with the same title.
Access-optimal Linear MDS Convertible Codes
for All Parameters
Francisco Maturana, V. S. Chaitanya Mukka, and K. V. Rashmi
Abstract
In large-scale distributed storage systems, erasure codes are used to achieve fault tolerance in the face of node failures. Tuning code parameters to observed failure rates has been shown to signiﬁcantly reduce storage cost. Such tuning of redundancy requires code conversion, i.e., a change in code dimension and length on already encoded data. Convertible codes [1] are a new class of codes designed to perform such conversions efﬁciently. The access cost of conversion is the number of nodes accessed during conversion.
Existing literature has characterized the access cost of conversion of linear MDS convertible codes only for a speciﬁc and small subset of parameters. In this paper, we present lower bounds on the access cost of conversion of linear MDS codes for all valid parameters. Furthermore, we show that these lower bounds are tight by presenting an explicit construction for access-optimal linear MDS convertible codes for all valid parameters. En route, we show that, one of the degrees-of-freedom in the design of convertible codes that was inconsequential in the previously studied parameter regimes, turns out to be crucial when going beyond these regimes and adds to the challenge in the analysis and code construction.
I. INTRODUCTION
Erasure codes are an essential tool for providing resilience against node failures in a distributed storage system [2]–[8]. When using an [n, k] erasure code, k chunks of data are encoded into n chunks, called a stripe. These chunks are then distributed among n different “nodes” in the system, where nodes correspond to distinct storage devices typically residing on distinct servers. For the purposes of theoretical study, each stripe can be viewed as a codeword, by viewing each of the n chunks as one of the n codeword symbols. The parameters n and k are usually chosen based on node failure rate, which might vary over time. Redundancy tuning, i.e., changing n and k in response to ﬂuctuations in the failure rate of storage devices can achieve signiﬁcant savings (11% to 44%) in storage space [9]. Due to practical system constraints, changing n alone is typically insufﬁcient and both n and k have to be changed simultaneously [9]. The resource cost of changing n and k on already encoded data can be prohibitively high and is a key barrier in the practical adoption of redundancy tuning [1]. Other reasons to change n and k on already encoded data might include variations in data popularity, failure rate uncertainty, or restrictions on the total amount of used storage.
The code conversion problem deﬁned in [1] involves converting multiple stripes of an [nI , kI ] code (denoted by CI ) into (potentially multiple) stripes of an [nF , kF ] code (denoted by CF ), along with desired constraints on decodability such as both codes being Maximum Distance Separable (MDS). Considering multiple stripes enables code conversions to allow for changes in the code dimension (from kI to kF ). Convertible codes [1] are code pairs that enable code conversion, usually designed to minimize the cost of conversion. A detailed description of the convertible codes framework is provided in Section II-A.
There are several ways in which one might measure the cost of conversion. We focus on the access cost of conversion, which is measured in terms of the total number of nodes that need to be accessed during conversion. In [1], the authors focus on the so-called merge regime, wherein multiple initial stripes are merged into one. Speciﬁcally, they consider the case where kF = ςkI for some integer ς ≥ 2, and propose explicit constructions for converible codes that achieve optimal access cost for the merge regime. We review these results for the merge regime in Section II-B.
The results presented in this work are two fold. (1) We present lower bounds on the access cost of conversion for linear MDS codes for all valid parameters, that is, all nI , kI , nF , kF ∈ N+ such that nI > kI and nF > kF . (2) We show that the proposed lower bounds are tight by presenting an explicit construction of linear MDS convertible codes that is access optimal for all parameter regimes. To achieve this, we ﬁrst deﬁne and study the split regime in Section III, where kI = ςkF for an integer ς ≥ 2, that is, a single initial stripe is split into multiple ﬁnal stripes. We prove a (tight) lower bound on the access cost of conversion in the split regime, and describe a conversion procedure which has optimal access cost when used with any systematic MDS code. We then present in Section IV a tight lower bound on the access cost of conversion for linear MDS convertible codes for all valid parameters (termed general regime) by reducing conversion in the general regime to a combination of generalizations of conversions in the split and merge regimes. While the split and the merge regimes might seem somewhat restrictive, we show that, perhaps surprisingly, the proposed conversion procedure for the general regime that
This work was funded in part by an NSF CAREER award (CAREER-1943409) and a Google faculty research award. We thank Michael Rudow for his suggestions in the writing of this paper.
F. Maturana and K. V. Rashmi are with the Computer Science Department at Carnegie Mellon University, Pittsburgh, PA, USA. (emails: fmaturan@cs.cmu.edu and rvinayak@cs.cmu.edu).
V. S. Chaitanya Mukka is with the Department of CS & IS at BITS Pilani, Goa Campus, Goa, India. (email: f20150536@goa.bits-pilani.ac.in)

2

builds on top of the generalized split and merge regime is optimal. Interestingly, one of the degrees-of-freedom in the design of convertible codes (called “partitions” described subsequently in Section II-A), which is inconsequential in the split and merge regimes, turns out to be crucial in the general regime. The proposed construction for access-optimal convertible codes for the general regime builds on the constructions for split and merge regimes, while separately optimizing along this additional degree-of-freedom.

II. BACKGROUND AND RELATED WORK

A. Convertible codes [1]

A conversion from an [nI , kI ] initial code CI to an [nF , kF ] ﬁnal code CF is a procedure that takes as input a set of initial

stripes from CI and outputs a set of ﬁnal stripes from CF , such that the ﬁnal stripes together encode the same information as

the initial stripes. To avoid degeneracy, nF > kF and nI > kI is assumed. Let Fq be a ﬁnite ﬁeld, and consider a message

m ∈ FM q , where M = lcm(kI , kF ). The number of initial stripes is λI = M/kI and the number of ﬁnal stripes is λF = M/kF .

Let [n] = {1, . . . , n}, rI = nI − kI and rF = nF − kF . Let m[S] denote the projection of m onto the coordinates in the set

S,

and

let

C(m)

denote

the

encoding

of

m

under

code

C.

Consider

an

initial

partition

PI

=

{P

I 1

,

.

.

.

,

P

I λI

}

of

[M ]

such

that

|PiI | = kI (∀i ∈ [λI ]), and a ﬁnal partition PF = {P1F , . . . , PλFF } of [M ] such that |PjF | = kF (∀j ∈ [λF ]). These partitions

determine how message symbols are mapped to each of the initial and ﬁnal stripes. For example, the i-th initial stripe will only

encode the symbols of m indexed by PiI .

Deﬁnition 1 (Convertible code [1]). An (nI , kI ; nF , kF ) convertible code over Fq is deﬁned by:

1) a pair of codes (CI , CF ) over Fq such that CI is [nI , kI ] and CF is [nF , kF ]; 2) a pair of partitions (PI , PF ) of [M = lcm(kI , kF )] such that |PiI | = kI for all PiI ∈ PI and |PjF | = kF for all PjF ∈ PF ;

and

3) a conversion procedure which, for any m ∈ FM q , takes the set of initial codewords {CI (m[PiI ]) | PiI ∈ PI } as input, and

outputs

the

corresponding

set

of

ﬁnal

codewords

{C

F

(m[

P

F j

])

|

PjF

∈

PF }.

In this paper, we will restrict our focus to the case where CI and CF are both linear and MDS. The access cost of a conversion procedure is the total number of nodes that are read or written during conversion. Recall that each node in a stripe corresponds to a single symbol from the corresponding codeword, therefore access cost is equivalent to the number of codeword symbols that are read or written during conversion. We distinguish three types of nodes during conversion: unchanged nodes, which remain as is during the conversion process, and are present in both the initial and ﬁnal conﬁguration (possibly in different stripes); retired nodes, which are present in the initial conﬁguration and throughout the conversion, but not in the ﬁnal conﬁguration; and new nodes, which are introduced during conversion, and are present in the ﬁnal conﬁguration, but not in the initial conﬁguration. Unchanged and retired nodes may be accessed for reading during conversion, and new nodes are always accessed for writing during the conversion. A convertible code that maximizes the number of unchanged nodes is said to be stable. The read access set of an (nI , kI ; nF , kF ) convertible code is a set of tuples D ⊆ [λI ] × [nI ], where (i, j) ∈ D corresponds to the j-th node in initial stripe i. After a conversion, each new node holds a ﬁxed linear combination of the contents of the nodes indexed by D. We denote the accessed nodes from initial stripe i as Di = {j | (i, j) ∈ D}. Thus, the access cost of a conversion with read access set of size d = |D| and m new nodes is d + m. Clearly, there always exists a conversion procedure with read access cost M , which reconstructs the original message m and re-encodes according to CF . We refer to this procedure as the default approach. An (nI , kI ; nF , kF ) convertible code is access-optimal if and only if it achieves the minimum access cost over all (nI , kI ; nF , kF ) convertible codes.

B. Merge regime [1] The merge regime is the subset of valid parameter values for convertible codes where kF = ςkI , for some integer ς ≥ 2.
Thus, in this regime we have λI = ς and λF = 1. This regime was the focus of [1], wherein the following lower bound on access cost was shown.
Theorem 1 ([1]). For all linear MDS (nI , kI ; nF , kF ) convertible code, the access cost of conversion is at least rF + ς min{kI , rF }. Furthermore, if rI < rF , the access cost of conversion is at least rF + ςkI .
An explicit construction for access-optimal convertible codes for all values in the merge regime was also provided in [1].

C. Other related works
The closest related work [1] proposes the convertible codes framework considered in this work (discussed at length above). Several other works in the literature [10]–[14] have considered variants of the code conversion problem, largely within the context of so-called “regenerating codes” [15]. The study on regenerating codes, which are a class of codes that optimize for

3
recovery for a small subset of nodes within a stripe (as opposed to decoding all original data), was initiated by Dimakis et al. [15]. Subsequently numerous works have studied and constructed optimal regenerating codes (e.g., [16]–[30]). Speciﬁc instances of code conversion can be viewed as instances of the repair problem, for example, increasing n while keeping k ﬁxed as studied in [10], [14].
In a recent work [31], Su et al. study a related problem in the context of coded computation for distributed matrix multiplication. In [31], Su et al. propose a coding scheme for coded matrix-multiplication with the property that certain changes to the code parameters only require local re-encoding of the data stored in each server.
D. Notation This subsection introduces notation that generalizes the notation used in [1] and is used throughout this paper. Let G♦ =
(g1♦ · · · gn♦♦ ) ∈ Fkq♦×n♦ be a generator matrix of MDS code C♦ for ♦ ∈ {I, F }. An encoding vector in relation to m ∈ FM q is associated to each node in the initial or ﬁnal stripes. The encoding vector g˜i♦,j ∈ FM q of node j ∈ [n♦] in stripe i ∈ [λ♦] with partition set Pi♦ ∈ P♦ is deﬁned such that g˜i♦,j[Pi♦] = gj♦, and 0 everywhere outside of Pi♦. The difference between gj♦ and g˜i♦,j is that the former describes the encoding of the j-th symbol relative to the information encoded in a single initial (resp. ﬁnal) stripe, while the latter describes the encoding of the j-th symbol of the i-th initial (resp. ﬁnal) stripe relative to the information jointly encoded by all initial (resp. ﬁnal) stripes (i.e., the message m).
Let Si♦ = {g˜i♦,j | j ∈ [n♦]} be the encoding vectors for a particular stripe, and let S♦ = i∈[λ♦] Si♦. Let U = SI ∩ SF be the encoding vectors of unchanged nodes, and deﬁne Ui,j = SiI ∩ SjF , where the index i or j is dropped if λI = 1 or λF = 1, respectively. Let Ai = {g˜iI,j | j ∈ Di} be the encoding vectors of nodes that are read from initial stripe i, and deﬁne A = {g˜iI,j | (i, j) ∈ D} as the set of all encoding vectors of nodes that are read. Finally, let N = SF \ SI be the encoding vectors of new nodes, and deﬁne Ni = SiF \ SI as the encoding vectors of new nodes of a particular stripe i. Notice that it must hold that N ⊆ span(A). For simplicity, we sometimes refer to a node and its encoding vector interchangeably.
III. SPLIT REGIME
The split regime of convertible codes corresponds to the case where a single initial stripe is split into multiple ﬁnal stripes. This regime is, in some sense, the opposite of the merge regime, in which multiple initial stripes are combined into one ﬁnal stripe. Speciﬁcally, an (nI , kI ; nF , kF ) convertible code is in the split regime if kI = ςkF for an integer ς ≥ 2, with arbitrary nI and nF . Notice that in this regime we have that M = lcm(kI , kF ) = kI and thus λI = 1 and λF = ς.
First, in Section III-A, we show a lower bound on access cost for the split regime. In Section III-B we show a matching upper bound on access cost by showing that for every systematic [nI , ςkF ] MDS code C there exists an access-optimal (nI , kI = ςkF ; nF , kF ) convertible code having C as its initial code by presenting a conversion procedure whose cost matches the lower bound.
A. Access cost lower bound for the split regime
In this subsection, we lower bound the access cost of conversion in the split regime. This is done by ﬁrst showing a lower bound on write access cost, and then showing a lower bound on the read access cost of conversion.
The following fact simpliﬁes the analysis of the split regime.
Proposition 2. For a linear MDS (nI , kI = ςkF ; nF , kF ) convertible code, all possible pairs of initial and ﬁnal partitions are equivalent (up to relabeling).
Proof. There is only one possible initial partition PI = {[kI ]}, hence any two ﬁnal partitions can be made equivalent by relabeling nodes.
Therefore, we do not need to consider differences in partitions in our analysis of the split regime.
Proposition 3. In a linear MDS (nI , kI = ςkF ; nF , kF ) convertible code, there are at most kF unchanged nodes in each of the ﬁnal stripes (i.e., at least rF new nodes per stripe). Hence, there are at most kI unchanged nodes in total.
Proof. For any ﬁnal stripe i ∈ [ς], any subset V ⊆ SiF of size at least kF + 1 is linearly dependent due to the MDS property. Thus, V ⊆ SI contradicts the fact that CI is MDS. Hence, each ﬁnal stripe i has at most kF unchanged nodes.
Therefore, the total write access cost in the split regime is at least ςrF . Now we focus on bounding the read access cost. The general strategy we use to obtain bounds on read access cost is to consider a specially chosen set W of kF nodes from a ﬁnal stripe, which by the MDS property of the ﬁnal code is enough to decode all data in that stripe. We then use the fact that ﬁnal stripes are the result of conversion to identify a set V of initial nodes that contain all the information contained in W. The MDS property of the initial code constrains the information available in V, which allows us to derive a lower bound on its size and thus a lower bound on the number of read nodes.

4
Lemma 4. For all linear MDS (nI , kI = ςkF ; nF , kF ) convertible codes, the read access set D satisﬁes |D| ≥ (ς − 1)kF + min{rF , kF }.
Proof. If rF ≥ kF , then all data should be decodable by accessing only new nodes in the ﬁnal stripes, and the result follows easily since all data must have been read to create the new nodes. Therefore, assume for the rest of this proof that rF < kF .
Suppose, for the sake of contradiction, that |D| < (ς − 1)kF + rF . Let u be a node in some ﬁnal stripe i ∈ [ς] which is neither read nor written. Such a stripe and node exist since otherwise every node in the ﬁnal stripes would be accessed (for either read or write) and thus SF would be in the span of A, which is a contradiction since rk(SF ) = kI .
Let W1 be a subset of nodes of the same ﬁnal stripe i such that W1 ⊆ Ni and |W1| = rF . Such a subset exists by virtue of Proposition 3. Further, let W2 ⊆ SiF \ (W1 ∪ {u}) be such that |W2| = kF − rF . Clearly W = W1 ∪ W2 is of size |W| = kF and can reconstruct the contents of u, by the MDS property of the ﬁnal code. In other words, u ∈ span(W).
Let W2 = (W2 ∩ Ui) be the unchanged nodes in W2. Since W1 and W2 \ W2 only have new nodes, they are both contained in span(A), therefore W ⊆ span(A ∪ W2). Notice that the subset V = (A ∪ W2) consists only of initial nodes. Furthermore, it holds that rk(A) ≤ |D| and rk(W2) ≤ |W2| = kF − rF < kF . Thus:
rk(V) ≤ rk(A) + rk(W2) ≤ |D| + (kF − rF ) < kI .
This implies that W is spanned by less than kI initial nodes (which do not include u). However, by the MDS property of the initial code, any subset of less than kI initial nodes that does not contain node u, has no information about u. This causes a contradiction with the fact that u ∈ span(W) ⊆ span(V). Thus, we must have |D| ≥ (ς − 1)kF + rF .
It is easy to show that if we only read unchanged nodes, it is not possible to do better than the default approach. This follows from the fact that unchanged nodes are already present in the ﬁnal stripes and hence using them to create the new nodes will contradict with the MDS property. Retired nodes, on the other hand, do not have this drawback. Thus, intuitively, based on Lemma 4, one might expect to achieve an efﬁcient conversion by reading from the retired nodes. However, we next show that it is not possible to achieve lower read access cost than the default approach when rI < rF .
Lemma 5. For all linear MDS (nI , kI = ςkF ; nF , kF ) convertible codes, if rI < rF then the read access set D satisﬁes |D| ≥ ςkF .
Proof. Suppose, for the sake of contradiction, that |D| < ςkF . Let u be a node in some ﬁnal stripe i ∈ [ς] which is neither read nor written. Such a stripe and node always exist as described in the proof of Lemma 4. We will choose a subset of nodes W ⊆ SiF of size |W| = kF . By the MDS property of the ﬁnal code, node u is decodable from W, i.e., u ∈ span(W). There are two cases for the choice of W depending on the total number of accessed nodes in stripe i: Case 1: If |Ni| + |Ui ∩ A| ≥ kF , then let W ⊆ Ni ∪ (Ui ∩ A). That is, W only contains nodes that are read or written. It is easy to see that W ⊆ span(A).
Clearly, A contains only initial nodes, and the following holds:
rk(A) ≤ |D| < ςkF = kI .
However, this is a contradiction with the fact that u ∈ span(W), since by the MDS property of the initial code, A contains no information about node u. Case 2: If |Ni| + |Ui ∩ A| < kF , then choose W = (W1 ∪ W2), where W1 = (Ni ∪ (Ui ∩ A)) and W2 is any subset of (SiF \ (W1 ∪ {u})) of size |W2| = kF − |W1|. That is, W contains all the nodes of ﬁnal stripe i that are read or written (in addition to other unchanged nodes distinct from u). It is easy to see that W1 ⊆ span(A) and thus W ⊆ span(A ∪ W2). Furthermore, the subset V = (A ∪ W2) consists only of initial nodes.
Notice that there are at most (|SI | − |Ui|) = (kI + rI − |Ui|) read nodes outside of ﬁnal stripe i (i.e., in SI \ Ui). Therefore, we can bound rk(A) by rk(A) ≤ kI +rI −|Ui|+|Ui ∩A|. On the other hand, it is clear that rk(W2) ≤ |W2| = kF −|Ni|−|Ui ∩A|. Combining these, we get:
rk(V) ≤ rk(A) + rk(W2) ≤ kI + rI + kF − |Ui| − |Ni| ≤ kI + rI − rF < kI.
However, this is a contradiction with the fact that u ∈ span(W) ⊆ span(V), since by the MDS property of the initial codes, V contains no information about node u.
By combining all the results in this subsection, we obtain the following lower bound on the access cost of conversion in the split regime.
Theorem 6. The total access cost of any linear MDS (nI , kI = ςkF ; nF , kF ) convertible code is at least (ς − 1)kF + min{rF , kF } + ςrF if rI ≥ rF , and at least ςnF otherwise.

5
Proof. Follows from Proposition 3 and Lemmas 4 and 5.
As we show in the next subsection, this lower bound is tight since it is achievable.
B. Access-optimal convertible codes for the split regime
In this subsection we present a construction of access-optimal convertible codes in the split regime. Under this construction, any systematic MDS code can be used as the initial code. The ﬁnal code corresponds to the projection of the initial code onto the coordinates of any kF systematic nodes. Since our construction can be applied to existing codes and only speciﬁes the conversion procedure, we introduce the following deﬁnition capturing the property of codes that can be converted efﬁciently.
Deﬁnition 2. A code CI is (nF , kF )-optimally convertible if and only if there exists an [nF , kF ] code CF (along with partitions and conversion procedure) that form an access-optimal (nI , kI ; nF , kF ) convertible code.
The conversion procedure that leads to optimal access cost (meeting the lower bound in Theorem 6) is as follows. Conversion procedure: All the systematic nodes are used as unchanged nodes. When rI < rF or rF ≥ kF , the conversion is trivial since one cannot do better than the default approach. The conversion procedure for the nontrivial case proceeds as follows. For all but one ﬁnal stripe, all unchanged nodes are read ((ς − 1)kF in total), and the new nodes are naively constructed from them. For the remaining ﬁnal stripe, rF retired nodes are read, and then the unchanged nodes from the other ﬁnal stripes are used to remove their interference from the retired nodes to obtain rF new nodes.
Theorem 7. Every systematic linear MDS [nI , kI = ςkF ] code CI is (nF , kF )-optimally convertible.
Proof. If rF > min{rI , kF }, then the default approach achieves the bound stated in Theorem 6. Thus, assume rF ≤ min{rI , kF }. Let GI = [I | PI ] be the generator matrix of CI and assume nodes are numbered in the same order as the columns of GI . Deﬁne CF as the code generated by the matrix formed by taking the ﬁrst kF rows of GI , and columns 1, . . . , kF and kI + 1, . . . , kI + rF . Let (i − 1)kF + 1, . . . , ikF be the columns of the unchanged nodes corresponding to ﬁnal stripe i ∈ [ς]. Consider the following conversion procedure: read the the subset of unchanged nodes U = {kF + 1, . . . , ςkF } and the retired nodes R = {kI + 1, . . . , kI + rF }. To construct the new nodes for stripe 1, simply project the nodes of R onto their ﬁrst kF coordinates by using nodes U . To construct the new nodes for stripe i = 1, simply use then nodes in U . This conversion procedure reads a total of |U | + |R| = (ς − 1)kF + rF nodes and writes a total of ςrF new nodes, which matches the bound from Theorem 6.
Notice that convertible codes created using the construction above are stable. We show this property is, in fact, necessary.
Lemma 8. All access-optimal convertible codes for the split regime are stable.
Proof. Theorem 7 shows that there exist stable access-optimal codes for the split regime. Since any unstable convertible code must incur higher write access cost and at least as much read access cost, it cannot be access-optimal.
IV. GENERAL REGIME In this section, we will study the general regime of convertible codes with arbitrary valid parameter values (i.e. any nI > kI and nF > kF ). Recall that the choice of partition functions was inconsequential in the split and merge regimes. In contrast, it turns out that the choice of initial and ﬁnal partitions play an important role in the general regime. This makes the general regime signiﬁcantly harder to analyze. We deal with this complexity by reducing conversion in the general regime to generalized versions of the split and merge conversions, and by identifying the conditions on initial and ﬁnal partitions to minimize total access cost. In Section IV-A, we explore a generalization of the split regime and of the merge regime. In Section IV-B, these generalizations are used to lower bound the access cost of conversion in the general regime. In Section IV-C, we describe a conversion procedure and construction for access-optimal conversion in the general regime which utilizes ideas from the constructions for generalizations of split and merge regimes.
A. Generalized split and merge regimes
The generalized split and merge regimes are similar to the split and merge regimes, except that the generalized variants allow for initial or ﬁnal stripes of unequal sizes. This ﬂexibility enables the generalized split and merge regimes to be used as building blocks in the analysis of the general regime. In these generalized variants, the message length M is deﬁned to be max{kI , kF } (which coincides with the deﬁnition of M in the split and merge regime), but now the sets in the initial and ﬁnal partitions need not be all of the same size.
Since the initial (or ﬁnal) stripes might be of different lengths, we deﬁne them as shortenings of a common code C.
Deﬁnition 3. An s-shortening of an [n, k] code C is the code C formed by all the codewords in C that have 0 in a ﬁxed subset of s positions, with those s positions deleted.

6

Shortening a code has the effect of decreasing the length n and dimension k while keeping (n − k) ﬁxed. It can be shown

that an s-shortening of an [n, k] MDS code is an [n − s, k − s] MDS code. Lengthening is the inverse operation of shortening,

and has the effect of increasing length n and dimension k while keeping (n − k) ﬁxed. For linear codes, an s-lengthening of a

code can be deﬁned as adding s additional columns to its parity check matrix. Similarly, it can be shown that for an [n, k]

MDS code, there exists an s-lengthening of it that is an [n + s, k + s] MDS code (assuming a large enough ﬁeld size).
1) Generalized split regime: In the generalized split regime, λI = 1 is ﬁxed, λF > 1 is arbitrary, and the ﬁnal partition
PF = {P1F , . . . , PλFF } is such that |PiF | = kiF and i∈[λF ] kiF = kI . Let k∗F = maxi∈[λF ] kiF . Then CF is a [nF , k∗F ] MDS code, and the code corresponding to each ﬁnal stripe is some ﬁxed shortening of CF . In this case, we deﬁne rF = nF − k∗F .

Deﬁnition 4. A (nI , kI = code deﬁned by:

λi=F1 kiF ; nF , {kiF }λi=F1) convertible code for the generalized split regime is a variant of a convertible

1) CI and CF as [nI , kI ] and [nF , k∗F ] codes, where k∗F = maxi∈[λF ] kiF , 2) a partition PF = {P1F , . . . , PλFF } where |PiF | = kiF , and 3) a conversion procedure such that each ﬁnal stripe i, is an si-shortening of CF where si = k∗F − kiF .

The generalized split regime has an access cost lower bound similar to the split regime presented in Section III. We show this by showing that a more efﬁcient conversion procedure for the generalized split regime would imply the existence of a conversion procedure for split regime violating Theorem 6.
Theorem 9. For all linear MDS (nI , kI = λi=F1 kiF ; nF , {kiF }λi=F1) convertible codes, the read access set D satisﬁes: |D| ≥ kI − max{k∗F − rF , 0}, where k∗F = max kiF .
i∈[λF ]

Proof. Suppose, for the sake of contradiction, that there exists a conversion procedure with read access cost |D| < kI −

max{k∗F − rF , 0} for some convertible code in the generalized split regime with codes CI and CF . We modify the initial

code

CI

by

lengthening

it

to

an

[n

I s

,

ksI

]

MDS

code

Cs,

such

that

ksI

=

λF k∗F

and

rI

=

nI − kI

=

nIs − ksI .

This

adds

λF (kF − kF ) = (kI − kI ) extra “pseudo-nodes” to the initial code, which we denote with W.

i=1 ∗

i

s

We then deﬁne a new conversion procedure from code Cs to code CF which uses the conversion procedure for the generalized

split regime convertible code as a subroutine, and then simply reads all the added pseudo-nodes to construct the new nodes.

This procedure only reads the read access set D from Cs along with the (ksI − kI ) pseudo-nodes.

Hence, the total read access is,

|D ∪ W| < (kI − max{k∗F − rF , 0}) + (ksI − kI ) ≤ (λF − 1)k∗F + min{rF , k∗F }.

However,

the

codes

Cs

and

CF

with

the

new

conversion

procedure

clearly

form

an

MDS

(n

I s

,

ksI

= λF k∗F ; nF , k∗F )

convertible

code. Therefore, this is in contradiction to Theorem 6. Then, it must hold that |D| ≥ kI − max{k∗F − rF , 0}.

This lower bound is achievable for all pairs of initial and ﬁnal parameters. Similar to the case of the split regime, shown in Section III-B, we can use any systematic MDS codes as initial and ﬁnal codes, and access all but a set of nodes of size k∗F (forming the largest ﬁnal stripe) to perform this conversion, as described below.
Conversion procedure: All the systematic nodes are used as unchanged nodes. When rI < rF or rF ≥ k∗F , the conversion is trivial since one cannot do better than the default approach. The conversion procedure for the nontrivial case proceeds as follows. For all but the largest ﬁnal stripe, all unchanged nodes are read (ςkF − k∗F in total), and the new nodes are naively constructed from them. For the largest ﬁnal stripe, the rF retired nodes are read, and then the unchanged nodes from the other ﬁnal stripes are used to remove their interference from the retired nodes to obtain rF new nodes.
2) Generalized merge regime: In the generalized merge regime, the sets in the initial partition need not be all of the same size. In this case, we ﬁx M = kF and λF = 1, while λI > 1 is arbitrary. The initial partition PI = {P1I , . . . , PλII } is such that |PiI | = kiI and i∈[λI] kiI = kF . Let k∗I = maxi∈[λI] kiI . Then CI is a [nI , k∗I ] MDS code, rI = nI − k∗I , and the code corresponding to each initial stripe is some ﬁxed shortening of CI .

Deﬁnition

5.

A

(n

I

,

{k

I i

}λi=I 1

;

n

F

,

k

F

=

code deﬁned by:

λi=I 1 kiI ) convertible code for the generalized merge regime is a variant of a convertible

1) CI , CF as [nI , k∗I ] and [nF , kF ] codes, where k∗I = maxi∈[λI] kiI 2) partition PI = {P1I , . . . , PλII } where |PiI | = kiI , and 3) a conversion procedure such that each initial stripe i, is an si-shortening of CI where si = k∗I − kiI .

The next theorem gives a lower bound on the read access cost of a (nI , {kiI }λi=I 1; nF , kF = λi=I 1 kiI ) convertible code.

Theorem 10. For all (nI , {kiI }λi=I 1; nF , kF = if rI < rF , then |Di| ≥ kiI for all i ∈ [λI ].

λI i=1

kiI )

convertible

code,

|Di|

≥

min{kiI ,

rF }

for

all

i

∈

[λI ].

Furthermore,

7

Proof. Follows from the proofs of Lemmas 10, 11, and 13 in [1], with some straightforward modiﬁcations to account for the difference in the number of nodes of each initial stripe.

We

can

achieve

this

lower

bound

by

shortening

an

access-optimal

(n

I

,

k∗I

;

n

F m

,

kmF

)

convertible

code,

where

kmF

=

λI k∗I

and

nFm = kmF + rF .

B. Access cost lower bound for the general regime
In this subsection, we study the access cost lower bound for conversions in the general regime (i.e., for all valid parameter values, nI > kI and nF > kF ). As in the merge and split regime, we show that when rI ≥ rF , signiﬁcant reduction in access cost can be achieved. However when rI < rF , one cannot do better than the default approach.
For an (nI , kI ; nF , kF ) convertible code with kI = kF and partitions (PI , PF ), let ki,j = |PiI ∩ PjF | for (i, j) ∈ [λI ] × [λF ] and let ki,∗ = maxj∈[λF ] ki,j .
Lemma 11. For all linear MDS (nI , kI ; nF , kF ) convertible codes with kI = kF :
|Di| ≥ kI − max{ki,∗ − rF , 0} for all i ∈ [λI ].
Moreover, if rI < rF then |Di| ≥ kI for all i ∈ [λI ].
Proof. Let i ∈ [λI ] be an initial stripe. There are two cases. Case ki,∗ < kI : In this case, we can reduce this conversion to a conversion in the generalized split regime by focusing on initial stripe i, and considering messages which are zero everywhere outside of PiI . This is equivalent to a (nI , kI ; ki,∗ + rF , {ki,j}λj=F1) convertible code. Then, the result follows from Theorem 9. Case ki,∗ = kI : Let j = argmaxj ∈[λF ] ki,j . In this case, we can reduce this conversion to conversion in the generalized merge regime by focusing on ﬁnal stripe j, and considering messages which are zero everywhere outside of PjF . This is equivalent to a (nI , {ki,j}λi=I 1; nF , kF ) convertible code. Then, the result follows from Theorem 10.
We prove a lower bound on the total access cost of conversion in the general regime by using Lemma 11 on all initial stripes and ﬁnding a partition that minimizes the value of the sum.
Theorem 12. For every linear MDS (nI , kI ; nF , kF ) convertible code such that kI = kF , it holds that:
|D| ≥ λI rF + (λI mod λF )(kI − max{kF mod kI , rF })

if rF < min{kI , kF }. Furthermore, if rI < rF or rF ≥ min{kI , kF }, then |D| ≥ M .

Proof. Clearly, it holds that |D| = same lemma we have:

λi=I 1 |Di|. Then, the case rI < rF follows directly from Lemma 11. Otherwise, by the

λI

λI

|D| = |Di| ≥ kI − max{ki,∗ − rF , 0}.

(1)

i=1

i=1

First, we consider the case kI > kF . Notice that in this case (λI mod λF ) = λI and (kF mod kI ) = kF . If rF ≥ kF , then the result is trivial, so assume rF < kF . Since ki,∗ ≤ kF for all i ∈ [λI ], we have:

λI
|D| ≥ kI − max{ki,∗ − rF , 0} ≥ λI (kI + rF − kF ),
i=1

which proves the result. Now, we consider the case kI < kF . Assume, for now, that the right hand side of inequality 1 is minimized when:

kI ,

for 1 ≤ i ≤ (λI − (λI mod λF ))

ki,∗ = (kF mod kI ), otherwise.

(2)

Then, from inequality 1 we have:

|D| ≥ λI kI − (λI − (λI mod λF )) max{kI − rF , 0} − (λI mod λF ) max{(kF mod kI ) − rF , 0}

(3)

If rF ≥ kI , then the result is trivial, so assume rF < kI . Then, by manipulating the terms of inequality 3, the result is obtained.
It only remains to prove that the right hand side of inequality 1 is minimized when Eq. (2) holds. Notice that this is equivalent to showing that s = λi=I 1 max{ki,∗ − rF , 0} is maximized by the proposed assignment. To prove this, we will show that any optimal assignment to the variables ki,j can be modiﬁed to be of the proposed form, without decreasing the value of the objective s. Firstly, it is straightforward to check that there exists a feasible assignment to the
variables ki,j that satisﬁes the statement.

8

split procedure Initial stripes

merge procedure Intermediate stripes

read node Final stripes

Fig. 1. Conversion procedure from [6, 5] to [13, 12] (λI = 12 and λF = 5). Read access cost is 18 compared to 60 in the default approach (70% savings).

merge procedure Initial stripes

split procedure Intermediate stripes

read node Final stripes

Fig. 2. Conversion procedure from [13, 12] to [6, 5] (λI = 5 and λF = 12). Read access cost is 40, compared to 60 in the default approach (33.3% savings in read access cost).

Suppose we have an optimal assignment for variable ki,j that is not of the proposed form and assume, without loss of generality, that k1,∗ ≥ · · · ≥ kλI,∗. Let 1 ≤ i ≤ (λI − (λI mod λF )) be the least such that ki,∗ < kI , and let j = argmaxj ∈[λF ] ki,j . It must hold that ki,∗ > max{rF , kF mod kI }, otherwise this assignment could not be optimal. Notice that ki ,∗ = kI for all i < i and since kI (kF − ki,∗), there exists at least one i > i such that ki ,j > 0. Furthermore, there exists j = j such that ki,j > 0, since ki,∗ < kI . Then, we can “swap” elements from ki,j with ki ,j. This increases ki,∗ and decreases ki ,∗ by at most the same amount. Since ki,∗ > rF , this cannot decrease the value of the objective s. We can repeat this procedure until ki,∗ = kI for all 1 ≤ i ≤ (λI − (λI mod λF )).
Notice now that for every (λI − (λI mod λF )) ≤ i ≤ λI it holds that:

ki,∗ ≤ kF mod kI

(4)

otherwise, there must exist some j ∈ [λF ] such that λi=I 1 ki,j > kF . If rF < (kF mod kI ), then inequality 4 must hold with equality. Otherwise, each such ki,∗ will contribute exactly rF to the objective s, so they can be modiﬁed to be of the desired form without decreasing s.

C. Access-optimal convertible codes for the general regime
In this subsection we prove that the lower bound from Theorem 12 is achievable by presenting convertible code constructions that are access-optimal in the general regime. We ﬁrst present the conversion procedure for our construction and then describe the construction of the initial and ﬁnal codes that are compatible with this conversion procedure.
1) Conversion procedure: Conversion in the general regime can be achieved by combining the conversion procedures of codes in the generalized split and merge regimes. In the case where rI < rF , we access kI nodes from each initial stripe and use the default approach. For the case where rI ≥ rF , we present the conversion procedure by considering three cases: kI = kF , kI < kF , and kI > kF . Case kI = kF : Notice that nI ≥ nF since rI ≥ rF . This is a degenerate case where any nF nodes from the initial stripe can be kept unchanged.

9

Case kI < kF : We will separate the nodes of initial stripes into λF disjoint groups with the same amount of information. This

requires splitting some initial stripes into what we call intermediate stripes, which are then assigned to different groups. We will ﬁnally merge each group to form the λF ﬁnal stripes. Speciﬁcally (see Fig. 1):

1) Assign kF/kI initial stripes to each group (dashed boxes in Fig. 1).

2)

Use

an

(n

I

,

k

I

;

n

F

,

{k

F i

}λiˆ=F1

)

conversion

procedure

to

(generalized)

split

the

(λI

mod λF )

remaining

initial

stripes

to

obtain λˆF intermediate stripes, where λˆF = kI/(kF mod kI) , kiF = (kF mod kI ) for i ∈ [λˆF −1], and kλFˆF = (kF mod kI )

if (kF mod kI ) | kI and kλFˆF = (kI mod (kF mod kI )) otherwise. Each intermediate stripe is assigned to a different

group.

3) The conversion procedure for generalized merge is used to turn each stripe group into a single ﬁnal stripe.

The total number of nodes read during conversion is λI rF + (λI mod λF )(kI − max{kF mod kI , rF }), which matches

Theorem 12. Case kI > kF : Conversion occurs in two steps (see Fig. 2):
1) First, use an (nI , kI ; nF , {kiF }λiˆ=F1) conversion procedure to (generalized) split each initial stripe, where λˆF = ( kI/kF ), kiF = kF for i ∈ [λˆF − 1] (corresponding to ﬁnal stripes), and kλFˆF = kF if kF | kI (corresponding to another ﬁnal stripe) and kλFˆF = (kF mod kI ) otherwise (corresponding to an intermediate stripe).
2) Assemble the λI (kF mod kI ) remaining nodes from the intermediate stripes into (λF mod λI ) ﬁnal stripes. This is done

using the default approach, since all the remaining nodes would have been already accessed in the ﬁrst step.

The total number of nodes read in this case during conversion is λI (rF + kI − kF ), which matches Theorem 12. Therefore, the total access cost of conversion when rI ≥ rF and kI = kF is (λI + λF )rF + (λI mod λF )(kI − max{kF mod kI , rF }), while the access cost of the default approach is λF nF .

2) Access-optimal construction: Since the conversion procedure in Section IV-C1 is based on the generalized split and merge

regimes, we only need to ensure that the constructed codes can perform those conversions with optimal access cost.

Theorem 13. For all kF ≤ kI , every systematic linear MDS [nI , kI ] code CI is (nF , kF )-optimally convertible. For all kF ≤ ςkI with integer ς > 2, every access-optimal systematic linear MDS (nI , kI ; nF , kF = ςkI ) convertible code is (nF , kF )-optimally convertible.

Proof. Recall, from Section IV-A1 that any systematic [nI , kI ] code CI can be used as the initial code of an access-optimal convertible code in the generalized split regime (i.e., an (nI , kI = λi=F1 kiF ; nF , {kiF }λi=F1) convertible code). Since the conversion procedure for the general regime in the case where kI > kF only uses conversions from the generalized split regime and
conversions from the generalized merge regime that can be carried out using the default approach, it is clear that any systematic code CI can be used. Similarly, from Section IV-A2 we know that any [nI , kI ] code CI that is (nF , ςkI )-optimally convertible for an integer ς ≥ 2 can achieve conversion with optimal access cost in a (nI , {kiI }λi=I 1; nF , kF = λi=I 1 kiI ) convertible code, where λI ≤ ς. Since the conversion procedure for the general regime in the case where kI < kF only uses conversions from the generalized split and merge regimes, it is clear that any (nF , ςkI )-optimally convertible code CI such that ς ≥ kF/kI can
be used.

Therefore, the constructions for the merge regime presented in [1] can be used to construct access-optimal convertible codes in the general regime.

REFERENCES
[1] F. Maturana and K. V. Rashmi, “Convertible codes: New class of codes for efﬁcient conversion of coded data in distributed storage,” in 11th Innovations in Theoretical Computer Science Conference (ITCS 2020), ser. Leibniz International Proceedings in Informatics (LIPIcs), T. Vidick, Ed., vol. 151. Dagstuhl, Germany: Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, 2020, pp. 66:1–66:26.
[2] S. Ghemawat, H. Gobioff, and S. Leung, “The Google ﬁle system,” in ACM SIGOPS Operating Systems Review, vol. 37-5. ACM, 2003, pp. 29–43. [3] D. Borthakur, R. Schmidt, R. Vadali, S. Chen, and P. Kling, “HDFS RAID - Facebook.” [Online]. Available: http://www.slideshare.net/ydn/hdfs-raid-facebook [4] C. Huang, H. Simitci, Y. Xu, A. Ogus, B. Calder, P. Gopalan, J. Li, and S. Yekhanin, “Erasure coding in Windows Azure storage,” in Proceedings of
USENIX Annual Technical Conference (ATC), 2012. [5] Apache Software Foundation, “Apache hadoop: HDFS erasure coding,” accessed: 2019-07-23. [Online]. Available: https://hadoop.apache.org/docs/r3.0.0/
hadoop-project-dist/hadoop-hdfs/HDFSErasureCoding.html [6] K. V. Rashmi, N. B. Shah, D. Gu, H. Kuang, D. Borthakur, and K. Ramchandran, “A solution to the network challenges of data recovery in erasure-coded
distributed storage systems: A study on the Facebook warehouse cluster,” in Proceedings of USENIX HotStorage, Jun. 2013. [7] M. Sathiamoorthy, M. Asteris, D. Papailiopoulos, A. G. Dimakis, R. Vadali, S. Chen, and D. Borthakur, “XORing elephants: Novel erasure codes for big
data,” in VLDB Endowment, 2013. [8] K. V. Rashmi, N. B. Shah, D. Gu, H. Kuang, D. Borthakur, and K. Ramchandran, “A Hitchhiker’s guide to fast and efﬁcient data reconstruction in
erasure-coded data centers,” in ACM SIGCOMM, 2014. [9] S. Kadekodi, K. V. Rashmi, and G. R. Ganger, “Cluster storage systems gotta have HeART: improving storage efﬁciency by exploiting disk-reliability
heterogeneity,” USENIX FAST, 2019. [10] K. V. Rashmi, N. B. Shah, and P. V. Kumar, “Enabling node repair in any erasure code for distributed storage,” in 2011 IEEE International Symposium
on Information Theory Proceedings. IEEE, 2011, pp. 1235–1239. [11] B. K. Rai, V. Dhoorjati, L. Saini, and A. K. Jha, “On adaptive distributed storage systems,” in 2015 IEEE international symposium on information theory
(ISIT). IEEE, 2015, pp. 1482–1486.

10
[12] Y. Hu, X. Zhang, P. P. Lee, and P. Zhou, “Generalized optimal storage scaling via network coding,” in 2018 IEEE International Symposium on Information Theory (ISIT). IEEE, 2018, pp. 956–960.
[13] M. Sonowal and B. K. Rai, “On adaptive distributed storage systems based on functional MSR code,” in 2017 International Conference on Wireless Communications, Signal Processing and Networking (WiSPNET). IEEE, 2017, pp. 338–343.
[14] S. Mousavi, T. Zhou, and C. Tian, “Delayed parity generation in MDS storage codes,” in 2018 IEEE International Symposium on Information Theory (ISIT), Jun. 2018, pp. 1889–1893.
[15] A. G. Dimakis, P. B. Godfrey, Y. Wu, M. J. Wainwright, and K. Ramchandran, “Network coding for distributed storage systems,” IEEE Transactions on Information Theory, vol. 56, no. 9, pp. 4539–4551, sep 2010.
[16] D. Papailiopoulos, A. Dimakis, and V. Cadambe, “Repair optimal erasure codes through Hadamard designs,” IEEE Transactions on Information Theory, vol. 59, no. 5, pp. 3021–3037, May 2013.
[17] V. R. Cadambe, C. Huang, J. Li, and S. Mehrotra, “Polynomial length MDS codes with optimal repair in distributed storage,” in 2011 Conference Record of the Forty Fifth Asilomar Conference on Signals, Systems and Computers (ASILOMAR). IEEE, 2011, pp. 1850–1854.
[18] I. Tamo, Z. Wang, and J. Bruck, “Zigzag codes: MDS array codes with optimal rebuilding,” IEEE Transactions on Information Theory, vol. 59, no. 3, pp. 1597–1616, 2013.
[19] V. Guruswami and M. Wootters, “Repairing Reed-Solomon codes,” in ACM Symposium on Theory of Computing, 2016, pp. 216–226. [20] K. V. Rashmi, N. B. Shah, and P. V. Kumar, “Optimal exact-regenerating codes for distributed storage at the MSR and MBR points via a product-matrix
construction,” IEEE Transactions on Information Theory, vol. 57, no. 8, pp. 5227–5239, 2011. [21] B. Sasidharan, G. K. Agarwal, and P. V. Kumar, “A high-rate MSR code with polynomial sub-packetization level,” in 2015 IEEE International Symposium
on Information Theory (ISIT). IEEE, 2015, pp. 2051–2055. [22] N. B. Shah, K. V. Rashmi, P. V. Kumar, and K. Ramchandran, “Distributed storage codes with repair-by-transfer and non-achievability of interior points
on the storage-bandwidth tradeoff,” IEEE Transactions on Information Theory, vol. 58, no. 3, pp. 1837–1852, Mar. 2012. [23] M. Ye and A. Barg, “Explicit constructions of high-rate MDS array codes with optimal repair bandwidth,” IEEE Transactions on Information Theory,
vol. 63, no. 4, pp. 2001–2014, 2017. [24] K. Mahdaviani, S. Mohajer, and A. Khisti, “Product matrix MSR codes with bandwidth adaptive exact repair,” IEEE Transactions on Information Theory,
vol. 64, no. 4, pp. 3121–3135, 2018. [25] N. B. Shah, K. V. Rashmi, P. V. Kumar, and K. Ramchandran, “Interference alignment in regenerating codes for distributed storage: Necessity and code
constructions,” IEEE Transactions on Information Theory, vol. 58, no. 4, pp. 2134–2158, 2011. [26] C. Suh and K. Ramchandran, “Exact-repair MDS code construction using interference alignment,” IEEE Transactions on Information Theory, pp.
1425–1442, Mar. 2011. [27] S. El Rouayheb and K. Ramchandran, “Fractional repetition codes for repair in distributed storage systems,” in Allerton Conference on Control, Computing,
and Communication, Urbana-Champaign, Sep. 2010. [28] A. Chowdhury and A. Vardy, “New constructions of MDS codes with asymptotically optimal repair,” in 2018 IEEE International Symposium on
Information Theory, 2018, pp. 1944–1948. [29] H. Dau and O. Milenkovic, “Optimal repair schemes for some families of full-length Reed-Solomon codes,” in 2017 IEEE International Symposium on
Information Theory (ISIT). IEEE, 2017, pp. 346–350. [30] K. V. Rashmi, N. B. Shah, and K. Ramchandran, “A piggybacking design framework for read-and download-efﬁcient distributed storage codes,” IEEE
Transactions on Information Theory, vol. 63, no. 9, pp. 5802–5820, 2017. [31] X. Su, X. Zhong, X. Fan, and J. Li, “Local re-encoding for coded matrix multiplication,” in 2020 IEEE International Symposium on Information Theory,
(ISIT), 2020.

