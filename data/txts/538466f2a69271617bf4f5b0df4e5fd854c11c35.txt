arXiv:1508.04485v1 [cs.IT] 18 Aug 2015

SAFFRON: A Fast, Efﬁcient, and Robust Framework for Group Testing based on Sparse-Graph Codes
Kangwook Lee, Ramtin Pedarsani, and Kannan Ramchandran
Dept. of Electrical Engineering and Computer Sciences University of California, Berkeley
{kw1jjang, ramtin, kannanr}@eecs.berkeley.edu

Abstract

Group testing tackles the problem of identifying a population of K defective items from a set of n items by

pooling groups of items efﬁciently in order to cut down the number of tests needed. The result of a test for a group

of items is positive if any of the items in the group is defective and negative otherwise. The goal is to judiciously

group subsets of items such that defective items can be reliably recovered using the minimum number of tests, while

also having a low-complexity decoding procedure.

We describe SAFFRON (Sparse-grAph codes Framework For gROup testiNg), a non-adaptive group testing

paradigm that recovers at least a (1 − ǫ)-fraction (for any arbitrarily small ǫ > 0) of K defective items with high

probability with m = 6C(ǫ)K log2 n tests, where C(ǫ) is a precisely characterized constant that depends only on ǫ. For instance, it can provably recover at least (1 − 10−6)K defective items with m ≃ 68K log2 n tests. The computational complexity of the decoding algorithm of SAFFRON is O(K log n), which is order-optimal.

Further, we describe a systematic methodology to robustify SAFFRON such that it can reliably recover the set of K

defective items even in the presence of erroneous or noisy test results. We also propose Singleton-Only-SAFFRON,

a variant of SAFFRON, that recovers all the K defective items with m = 2e(1 + α)K log K log2 n tests with

probability 1 − O

1 Kα

, where α > 0 is a constant. By leveraging powerful design and analysis tools from modern

sparse-graph coding theory, SAFFRON is the ﬁrst approach to reliable, large-scale probabilistic group testing that

offers both precisely characterizable number of tests needed (down to the constants) together with order-optimal

decoding complexity.

Extensive simulation results are provided to validate the tight agreement between theory and practice. As a

concrete example, we simulate a case where K = 128 defective items have to be recovered from a population of n ≃ 4.3 × 109 items even when up to 2% of the group test results are reported wrongly (i.e., negative tests are

reported as positive and vice versa). We run the robustiﬁed SAFFRON 1000 times. We observe that all K = 128 defective items are successfully recovered in every run with m ≃ 8.3 × 105 tests, and the decoding time takes only

about 3.8 seconds on average on a laptop with a 2 GHz Intel Core i7 and 8 GB memory.

1 Introduction
Group testing tackles the problem of identifying a population of K defective items from a set of n items by pooling groups of items efﬁciently in order to cut down the number of tests needed. The result of a test for a group of items is positive if any of the items in the group is defective and negative otherwise. The goal is to judiciously group subsets of items such that defective items can be reliably recovered using the minimum number of tests, while also having a low-complexity decoding procedure.
Group testing has been studied extensively in the literature. Group testing arose during the Second World War [1]: in order to detect all soldiers infected with the syphilis virus without needing to test them individually, which was too expensive and slow, the blood samples of subsets of soldiers were pooled together and tested as groups, so that groups that tested negative would immediately exonerate all the individuals in the group. Since then, varied theoretical aspects of group testing have been studied, and more applications of group testing have been discovered in a variety of ﬁelds spanning across biology [2], machine learning [3], medicine [4], computer science [5], data analysis [6], and signal processing [7].

1

1.1 Our Contributions

The problem of group testing has been a very active area of research, and many variants have been studied in the literature. Despite the long history of group testing, our paper has some novel intellectual and practical contributions to the ﬁeld. Our paper falls speciﬁcally into the well-studied category of large-scale probabilistic group testing where both the ambient test population size and the number of defective items are scalable, and where a targeted arbitrarily-tiny fraction of defective items can be missed.
In this work, we introduce SAFFRON (Sparse-grAph codes Framework For gROup testiNg), a powerful framework for non-adaptive group testing based on modern sparse-graph coding theory [8]. Our main intellectual contribution is that we are, to the best of our knowledge, the ﬁrst to leverage the tools of sparse-graph coding theory for both group testing code design, and performance analysis, based on powerful density evolution techniques. Recall that sparse-graph codes (e.g. Low-Density-Parity-Check (LDPC) codes [8]) form the backbone of reliable modern communication systems (e.g. telecommunications, wireless cellular systems, satellite and deep-space communications, etc.). However, pooling test design for our targeted group testing problem seems quite different from code design for the noisy communication problem, and it is not clear if the tools of the latter are even applicable here. Concretely, classical coding theory deals with the design of codes based on ﬁnite-ﬁeld arithmetic: e.g., in the binary-ﬁeld case, this corresponds to the modulo-2 or XOR world. In contrast, group testing deals with the Boolean OR world, where each observed test output is the binary OR of the states of each of the component input items in the test. The non-linearity of the OR operator is at odds with ﬁnite-ﬁeld arithmetic, and complicates the use of classical coding theory in the group testing problem. Our main intellectual contribution is to show how this challenge can be overcome, where we show how elegant density evolution methods and simple randomized sparse-graph coding designs can lead to powerful group test codes as well.
A second contribution, which follows from the use of these powerful coding theory tools, is that we are able to specify precise constants in the number of tests needed while simultaneously having provable performance guarantees and order-optimal decoding complexity in the large-scale probabilistic group testing setting. To the best of our knowledge, this is new.
We summarize our main contributions as follows.

(i) The SAFFRON scheme recovers, with high probability, an arbitrarily-close-to-one fraction, 1 − ǫ, of the
defective items with m = C(ǫ)K log2 n tests, where C(ǫ) is a constant that depends only on ǫ and can be precisely computed (See Table 2). Moreover, the computational complexity of our decoding algorithm is O(K log n), which is order-optimal. For instance, SAFFRON reliably recovers at least (1−10−6)K defective
items with m ≃ 68K log2 n tests.

(ii) We propose a variant of the SAFFRON scheme, Singleton-Only-SAFFRON, which recovers all the defective

items with high probability, 1−O

1 Kα

, at the cost of m = 2e(1+α)K log K log2 n tests. The computational

complexity of the decoding algorithm is O(K log K log n).

(iii) SAFFRON and its variant can be systematically robustiﬁed to noise and errors by increasing the number of tests by a constant factor that does not change the order-complexity of the scheme.

Extensive simulation results are provided to validate the tight agreement between theory and practice. As a
concrete example, we simulate a case where K = 128 defective items have to be recovered from a population of n ≃ 4.3 × 109 items with 2% errors in test results. We run the robustiﬁed SAFFRON 1000 times. We observe that all K = 128 defective items are successfully recovered in every run with m ≃ 8.3 × 105 tests, and the decoding
time takes only about 3.8 seconds on average on a laptop with a 2 GHz Intel Core i7 and 8 GB memory.

1.2 Related Works

We provide a brief survey of the existing results in the literature. We refer the readers to [2, 9, 10] for a detailed

survey.

We ﬁrst summarize the known results on the minimum number of tests required to solve a (non-adaptive)

group testing problem. For group testing algorithms with zero-error reconstruction, the best known lower bound

on

the

number

of

required

tests

is

Ω(

K log

2
K

lo

g

n)

[11, 12].

The

best

known

group

testing

scheme

under

this

setup

requires O(K2 log n) tests [1]. Although the zero-error reconstruction property is deﬁnitely a desired property,

such group testing schemes typically involve exhaustive table searches in their reconstruction procedures, and
hence require a high computational and memory complexity of O(K2n log n) [13]. The notable exception is a recent work [14], which is the ﬁrst scheme that requires O(K2 log n) tests, while having an efﬁcient decoding algorithm of computational complexity poly(K) · O(K2 log n log2 (K2 log n)) + O(K4 log2 n).

Several relaxations of the group testing problem have been studied in the literature. One such relaxation is

allowing a small error probability as well as relaxing the requirement of perfect identiﬁcation. That is, the goal is

to design a group testing scheme that identiﬁes an approximate answer with high probability. Many approaches

2

have been proposed to design group testing schemes that allow an efﬁcient decoding algorithm for these relaxed yet

important problems. One such approach is random pooling design based on random bipartite graphs. For instance,

randomized group testing schemes based on left-regular random bipartite graphs and right-regular random bipartite

graphs are studied, respectively in [15] and [16]. Other lines of work have made use of existing pooling designs.

In [13, 17], the authors use randomly chosen pools from carefully designed pools that are initially tailored for

a zero-error reconstruction setting. With certain success probabilities, these schemes ﬁnd a large fraction of the

K defective items, while wrongly identifying a small fraction of normal items as defective items. Despite the

simplicity of this class of constructions, performance analysis is rather convoluted and cumbersome. Further, these

schemes are generally difﬁcult to make robust to noise.

Another line of work is based on an information-theoretic formulation of the group testing problem. That is, one

assumes a prior distribution on the set of defective items, and searches for a group testing scheme with vanishing

error probability. In [18], the authors present information-theoretic bounds: with a uniform prior over the location

of

K

defective items,

Θ(K

log(

n K

))

tests

are necessary and sufﬁcient (via

random coding).

Mazumdar presents

near-optimal explicit constructions in [10]. Chan et al. propose novel group testing algorithms and compare their

performances with the fundamental lower bounds [19]. Several works have proposed group testing schemes with

efﬁcient decoding algorithms. In [6], the authors present a simple group testing procedure that efﬁciently recovers a large fraction of K defective items with O(K log2 n) tests. While the proposed decoding algorithm runs in
time (K log n)O(1), the algorithm returns O(K log n) false positives, which need to be double-checked using a

2-stage algorithm. One of the most notable exceptions is [20]. In this work, Cai et al. propose GROTESQUE,

a class of efﬁcient group testing schemes, which is the ﬁrst adaptive group testing algorithm that achieves both

an order-optimal number of tests and an order-optimal decoding complexity, but at the cost of using O(log K)

adaptive stages. Their non-adaptive scheme requires O(K log K log n) tests, and has a decoding complexity is O(K(log n + log2 K)).

1.3 Paper Organization

The rest of the paper is organized as follows. In Section 2, we formally deﬁne the problem, and provide the basic ideas, based on which we develop SAFFRON. In Section 3, we provide a detailed description of SAFFRON and its decoding algorithm. In Section 4, we provide the main theoretical results of the paper. In Section 5, we robustify SAFFRON so that it can reliably recover the defective items even with some erroneous test results. Finally, we provide extensive simulation results in Section 6, verifying our theoretical guarantees as well as demonstrating the practical performance of SAFFRON.

2 Group Testing Problem and Overview of the Main Results
We formally deﬁne the group testing problem as follows. Consider a group testing problem with n items. Among them, exactly K items are defective. We deﬁne the support vector x ∈ {0, 1}n, of which the ith component is 1 if and only if item i is defective. That is, xi = 1{item i is defective} for 1 ≤ i ≤ n. Deﬁning supp (·) as the set of indices of non-zero elements, |supp (x) | = K.
A subset of items can be pooled and tested, and the test result is either 1 (positive) if any of the items in the subset is defective, or 0 (negative) otherwise. For notational simplicity, we denote a subset by a binary row vector, a, of which the ith component is 1 if and only if item i belongs to the subset. Then, a group testing result y can be expressed as

n

y = a, x d=ef aixi,

(1)

i=1

where ∨ is a boolean OR operator. Let m be the number of pools. Denoting the ith pool by ai, we deﬁne the group testing matrix as A d=ef (aT1 , aT2 , . . . , aTm)T ∈ {0, 1}m×n. The group testing results from m pools can also be represented as a column vector y = (y1, y2, . . . , ym)T ∈ {0, 1}m, where yi is the outcome of the ith test. Then,

 a1, x 

 y = A ⊙ x d=ef 

a2, x .

 .

(2)

 

..

 

am, x

The goal is to design the group testing matrix A and efﬁciently recover the set of defective items using the m test results. We denote the decoding function by gA : {0, 1}m → {0, 1}n. We want the decoding result xˆ = gA(y)
to be close to the true support vector x with some guarantee.

3

Depending on different applications, one can deﬁne ‘closeness’ and ‘guarantee’ in different ways. Let us ﬁrst discuss various notions of ‘closeness’. The most stringent objective is exact recovery: xˆ = x. Another objective, slightly looser, is partial recovery without false detections: one wants to make sure that set (xˆ) ⊆ set (x) and |set (xˆ) | ≥ (1 − ǫ)K. Another criterion is to ﬁnd a superset of all the defective items without missed detections, i.e., set (xˆ) ⊇ set (x) and |set (xˆ) | ≤ (1 + ǫ)K.
There are also several types of guarantees. The most stringent guarantee is perfect guarantee: for any x, the corresponding estimate has to be close with probability 1. Another popular guarantee is probabilistic guarantee. That is, the decoder will provide an exact or close estimate with high probability.
Our proposed approach, SAFFRON, recovers an arbitrarily-close-to-one fraction of the defective items (partial recovery) with high probability (probabilistic guarantee). On the other hand, we propose the variant of the SAFFRON scheme that recovers all the defective items (perfect recovery) with high probability.
An important generalization of the problem is to ﬁnd the set of defective items with erroneous or noisy test results. We show that SAFFRON can be robustiﬁed to noise, while maintaining its plain architecture.
The main results of this paper are stated in the following (informal) theorem.
Theorem 2.1. Consider a group testing problem with n items and K defective items. SAFFRON recovers a (1 − ǫ)fraction of the defective items for arbitrarily-close-to-zero constant ǫ with high probability. The number of tests and the computational complexity of the decoding algorithm are O(K log(n)), which is order-optimal in both noiseless and noisy settings.
Remark 1. In some applications, it is possible to design pools in an adaptive way. In other words, the (i + 1)th pool, ai+1, can be ‘adaptively’ designed after observing the ﬁrst i test results or (y1, y2, . . . , yi). Such a scheme is called an adaptive group testing scheme. While an adaptive group testing scheme requires a lower number of tests and can potentially lead to a more efﬁcient decoding algorithm, our focus here is only on non-adaptive group testing for the following reasons. First, adaptive group testing is generally applicable in limited settings of interest, whereas nonadaptive group testing applies broadly to any group testing setting. Moreover, non-adaptive group testing enjoys an important architecture advantage. In contrast to adaptive group testing algorithms which are necessarily sequential in nature, non-adaptive group testing feature pre-determined pools, and can therefore be easily parallelized, leading to more efﬁcient implementation, especially in this era of large-scale parallel computing.
Table 1 summarizes our notation, which will be deﬁned throughout the paper.

Notation
n
K
m
M
x
y
zi zji ui uji bi ei supp (·) w(·) q G
x [n]

Deﬁnition Number of items Number of defective items Number of pools (tests) Number of right nodes (bundles of tests) Binary representation of the set of defective items Binary representation of the group test results Measurements from the ith right node Measurements from the jth stage of the ith right node Signature vector of the ith item The jth stage of the signature vector of the ith item Binary representation of i − 1 The ith standard basis vector The set of the indices of the non-zero elements Hamming weight or the number of ones of a vector Probability of each test outcome being wrong Bipartite graph representation of a sparse-graph code Bit-wise complement vector of x {1, 2, . . . , n}

Table 1: Summary of our notation

3 The SAFFRON Scheme: Main Idea
Our test matrix design is based on an architectural philosophy that is similar to the ones in [21–27]. The key idea of SAFFRON is the adoption of a design principle called ‘sparse signal recovery via sparse-graph codes’ that

4

is applicable to a varied class of problems such as computing a sparse Fast Fourier Transform, a sparse Walsh Hadamard Transform, and the design of systems for compressive sensing and compressive phase-retrieval. In all these problems, one designs an efﬁcient way of sensing or measuring an unknown sparse signal such that the decoder can estimate the unknown signal with a low decoding complexity. The overarching design principle is to 1) design a sensing matrix based on a sparse bipartite graph and to 2) decode the observed measurements using a simple peeling-like iterative algorithm. We show how this same design principle allows us to efﬁciently tackle the group testing problem.
Consider a bipartite graph with n left nodes and M right nodes. Here, the n left nodes correspond to the n items, and the M right nodes corresponds to the M bundles of test results. We design a bipartite graph based on left-regular construction. That is, each left node is connected to constant number d of right nodes uniformly at random.
We denote the incidence matrix of a bipartite graph G by TG ∈ {0, 1}M×n, or simply T if G is clear from the context. Let ti be the ith row of TG. We associate each left node with a carefully designed signature (column) vector u of length h, i.e., u ∈ {0, 1}h. Let us denote the signature vector of item i by ui. We deﬁne the signature matrix U d=ef [u1, u2, . . . , un−1, un] ∈ {0, 1}h×n.
Given a graph G and a signature matrix U , we design our group testing matrix A to be a row tensor product of TG and U , which is deﬁned as A = TG ⊗ U d=ef [AT1 , AT2 , . . . , ATM ]T ∈ {0, 1}hM×n, where Ai = U diag(ti) ∈ {0, 1}h×n, and diag(·) is the diagonal matrix constructed by the input vector. As an example, the row tensor product of matrices

0 1 0

101

(3)

T =  10 10 01  and U = 0 1 1

is

0 0 0

0 1 0





A = T ⊗ U =  10 01 00  . (4)





0 0 1

001

For notational simplicity, we deﬁne the observation vector corresponding to right node i as zi d=ef y(i−1)h+1:ih for 1 ≤ i ≤ M . Then,

zi = U ⊙ diag(ti)x, 1 ≤ i ≤ M.

(5)

In other words, zi is the bitwise logical ORing of all the signature vectors of the active left nodes that are connected to right node i.
Our decoding algorithm simply iterates through all the right node measurement vectors {zi}M i=1, and checks whether a right node is resolvable or not. A right node is resolvable if exactly one new defective item can be detected by processing the right node, i.e., the location index of the defective item is found. The decoding algorithm
is terminated when there is no more resolvable right node.
We now present the following terminologies. A right node that is connected to one and only one defective item is called a singleton. A right node that is connected to two defective items is called a doubleton. Later, we show
that with the aid of our signature matrix, 1) a singleton is resolvable, and 2) a doubleton is resolvable if one of the
two defective items is already identiﬁed (in the previous iterations of the algorithm).

5

3.1 Detecting and Resolving a Singleton

Consider the following signature matrix where the ith column is a vertical concatenation of bi and its complement, where bi is the L-bits binary representation of an integer i − 1, for i ∈ [n], so L = ⌈log2 n⌉. 1

 0 0 0 ... 1 1 

 0 0 0 ... 1 1 

 

..

.

...

...

...

...

..

 

.





 0 0 1 ... 1 1 

U1

b1 b2 b3 . . . bn−1 bn





 0 1 0 ... 0 1 

= b b b ... b

b

= 

1

1

1

...

0

 0

(6)

U1

123

n−1 n





 1 1 1 ... 0 0 

 

..

.

...

...

...

...

..

 

.





 1 1 0 ... 0 0 

1 0 1 ... 1 0

We now show that a singleton can be detected and resolved with the aid of this signature matrix. First, note that the sum of the weight of any binary vector and the weight of its complement is always the length of the vector, L. Thus, given a singleton, the weight of the measurement vector is L. Furthermore, if the right node is connected to zero or more than one defective items, the weight of the measurement vector will not be L. Therefore, by just checking the
weight of the right-node measurement vector, one can simply detect whether the right node is a singleton or not.
Further, one can also read the ﬁrst half of the measurement of the detected singleton to ﬁnd the index location of
the defective item. While having only U1 as the signature matrix sufﬁces for detecting and resolving singletons, in the folU1
lowing subsections, we show that to detect and resolve a doubleton, we need to expand the signature matrix. Thus, U1 will be one part of our ﬁnal signature matrix U . U1

3.2 Resolvable Doubletons

We now design the full signature matrix U by expanding U1 so that one can detect and resolve both singletons U1
and resolvable doubletons as follows.

 b1 b2 b3 . . . bn−2 bn−1 

 U1 

 

b1

b2

b3 . . . bn−1

bn

 

 U 1  U2 



 

bi1

bi2

bi3

...

bin 1



bin

 

 U =  U 2  =  bi1 bi2 bi3 . . . bin− −1 bin  , (7)

 U3  



U3

 bj1 bj2 bj3 . . . bjn−1 bjn 

bj1 bj2 bj3 . . . bjn−1 bjn

where s1 = (i1, i2, . . . , in) and s2 = (j1, j2, . . . , jn) are drawn uniformly at random from the set [n]n. Then, the measurement vector for the kth right node, zk, is

 U1 ⊙ diag(tk)x   z1k 

 U 1 ⊙ diag(tk)x   z2k 

z

= U ⊙ diag(t

  )x = 

U2 ⊙ diag(tk)x



 

d=ef

 

z3k

  .

(8)

k

k

 U 2 ⊙ diag(tk)x   z4k 





 U3 ⊙ diag(tk)x 

 

z5

 

k

U 3 ⊙ diag(tk)x

z6k

We call zwk the wth section of the kth right-node measurement vector. Figure 1 provides an illustration of a right-node measurement vector zk. Assume the support vector is x = (0, 1, 1, . . . , 0, 1, 0). That is, there are exactly K = 3 defective items: item 2, item 3 and item n − 1. Also, assume that the kth right node is connected to item 2, item n − 2 and item n − 1, i.e., tk = (0, 1, 0, . . . , 1, 1, 0). Consider the kth right node and its corresponding right-node

1For simplicity, the rest of paper will assume that n is a power of 2, and hence L = log2 n.

6

1 2 3 ··· n−2

 z1k   b2 + bn−1 

 z2k   b2 + bn−1 



zk

=

 

z3k



 

=

 

bi2 + bin−1

  

 z4k 

 bi2 + bi


1

 

n− 

 z5k   bj2 + bjn−1 

z6k bj2 + bjn−1

k

n−1 n

x = (0, 1, 1, . . . , 0, 1, 0) tk = (0, 1, 0, . . . , 1, 1, 0)

Figure 1: An illustration of a right-node measurement vector zk and its 6 sections. When the support vector x = (0, 1, 1, . . . , 0, 1, 0) and the kth row of the bipartite graph tk = (0, 1, 0, . . . , 1, 1, 0) are given, the kth right-node measurement vector zk is equal to u2 + un−1, as depicted in the ﬁgure. The right-node measurement vector consists of sections {zik}6i=1.

measurement vector zk. By (8), zk is equal to u2 + un−1, and it consists of 6 sections. We can also ﬁnd each section of zk by looking at the corresponding sections of u2 and un−1, as described in Figure 1. For instance, the ﬁrst section of the kth right-node measurement vector z1k is equal to b2 + bn−1.
Assume that right node k is connected to exactly one identiﬁed defective item, say ℓ0. The decoder ﬁrst guesses that the right node is a resolvable doubleton. That is, the right node is connected to exactly two defective items: one
of them is the identiﬁed defective item ℓ0, and the other is the unidentiﬁed defective item ℓ1. Thus,

z1k = uℓ ∨ uℓ = bℓ0 ∨ bℓ1 = bℓ0 ∨ bℓ1 .

(9)

z2k

0

1

bℓ

bℓ

bℓ ∨ bℓ

0

1

0

1

One can always recover any bit of bℓ1 as follows. Consider the ﬁrst bit of bℓ1 . If bℓ0,1 = 0, bℓ1,1 = z1k,1. If not, one can read the ﬁrst bit from the second section and invert it, i.e., bℓ1,1 = z2k,1. Therefore, if the assumption is true, the decoder is able to recover the other defective item’s index, ℓ1. Similarly, the decoder applies the decoding algorithm to the other four segments from z3k to z6k, and obtain two other indices, ℓ2 and ℓ3. Finally, the decoder checks whether ℓ2 = iℓ1 and whether ℓ3 = jℓ1 . If any of these conditions does not hold, the decoder concludes that the guess is wrong. If both conditions hold, the decoder concludes that the hypothesis is correct, declares the right
node to be resolved, and declares a new defective item of index ℓ1. Then,

Lemma 3.1. SAFFRON successfully detects and resolves all the singletons and all the resolvable doubletons. When

a right-node measurement vector is connected to more than 2 defective items, SAFFRON declares a wrong defective

item

with

probability

no

greater

than

1 n2

.

Proof. From the above decoding algorithm description, it is clear that SAFFRON correctly detects and resolves all

the singletons and resolvable doubletons. Consider a right node connected to more than 2 defective items. From

the ﬁrst two sections of the corresponding right-node measurement vector, SAFFRON reads the ﬁrst index ℓ1.

SAFFRON declares a wrong defective item only if item ℓ1 is not connected to the right node and the two check

equations hold. We note that when item ℓ1 is not connected to the right node, iℓ1 and jℓ1 are independent of ℓ2 and

ℓ3.

Thus,

the

probability

that

ℓ2

=

iℓ1

and

ℓ3

=

jℓ1

is

1 n2

.

Remark 2. Lemma 3.1 ensures that the signature matrix U in (11) can be used to detect and resolve all the singletons

and

all

the

resolvable

doubletons

with

error

probability

no

greater

than

1 n2

.

Later,

we

show

that

SAFFRON

performs

the described right-node decoding algorithm O(K) times in total. Thus, by the union bound, the probability of

having

any

error

in

O(K )

tests

is

bounded

by

O

(

K n2

),

which

always

approaches

zero

as

n

increases.

However,

if

7

the number of defective items is sublinear in n, to reduce the number of tests, one can keep only the ﬁrst 4 sections

in the signature matrix U . By doing so, the probability of having any error in O(K) tests is upper bounded by

O

(

K n

),

which

still

vanishes

since

K

=

o(n).

Therefore,

one

can

always

use

a

shorter

signature

matrix

in

order

to

save the number of tests by 33%, when the number of defective items is sublinear in n.

3.3 Example

In this section, we provide an illustrative example of the decoding algorithm of SAFFRON. Consider a group testing problem with n = 8 items and K = 3 defective items. Let x = (1, 0, 1, 0, 0, 0, 0, 1),
i.e., item 1, item 3 and item 8 are defective items. We show how SAFFRON can ﬁnd the set of defective items. Recall that we design our group testing matrix A to be a row tensor product of TG and U . Assume that a bipartite graph G is designed as follows. 2

0 1 1 1 0 1 0 0 TG =  11 10 10 10 01 00 11 11  ∈ {0, 1}M×n
01101101

We have M = 5 right nodes, and n = 8 items are connected to them according to TG. Assume that we drew random sequences s1 and s2, and the realization of them are as follows.

s1 = (5, 2, 4, 8, 7, 1, 3, 6), s2 = (3, 1, 5, 6, 3, 8, 2, 7)

(10)

Thus, the measurement matrix of SAFFRON is as follows.

0 0 0 0 1 1 1 1

 U1 

0 0 1 1 0 0 1 1

 

0

1

0

1

0

1

0

1

 





1 1 1 1 0 0 0 0





1 1 0 0 1 1 0 0





1 0 1 0 1 0 1 0





 

1

0

0

1

1

0

0

1

 

 U1 

 

0

0

1

1

1

0

1

0

 

  U2 

 

0

1

1

1

0

0

0

1

 

U

= 

U2

= 

0

1

1

0

0

1

1

0

 = [u1, u2, u3, u4, u5, u6, u7, u8] 

(11)

  U3 

 

1

1

0

0

0

1

0

1

 

U3

 

1

0

0

0

1

1

1

0

 





0 0 1 1 0 1 0 1





1 0 0 0 1 1 0 1





0 0 0 1 0 1 1 0





 1 1 0 0 1 0 1 0 

0 1 1 1 0 0 1 0

11101001

Using (5), we have the following equations for the 4th right-node measurement vectors.

 



z1

u3

y =  zz23  =  u1u∨1u∨3u∨8u8  (12)

z4

u3 ∨ u8

Thus, we will observe the following right-node measurement vectors.

z1 = (0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1)T

(13)

z2 = (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1)T

(14)

z3 = (1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1)T

(15)

z4 = (1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1)T

(16)

2 In the interest of conceptual clarity of the toy example, here we present a bipartite graph that is not left-regular.

8

We are now ready to decode these measurements. The decoding algorithm ﬁrst ﬁnds all the singletons by checking whether a right-node measurement’s weight is 3L = 3 log2 n. The weights are as follows.

w(z1) = 9, w(z2) = 17, w(z3) = 14, w(z4) = 14

(17)

Since w(z1) = 3 log2 n, the decoder declares that right node 1 is a singleton. Then, it can read off the ﬁrst 3 bits of z1. As z11 = (0, 1, 0), the decoder concludes that item 3 is defective.
In the second iteration, the algorithm inspects right nodes that are potentially resolvable doubletons including
defective item 3. Since T2,1 = T4,1 = 1, right nodes 2 and 4 are inspected. Consider right node 2. We hypothesize that the right node is a doubleton consisting of defective item 3 and
exactly one other unknown defective item. That is, we guess that z2 = u3 ∨ uℓ1 , and recover ℓ1, ℓ2 and ℓ3 as described in the previous section. Then,

ℓ1 = 6, ℓ2 = 8, ℓ1 = 3

(18)

By noticing that iℓ1 = i6 = 1 = ℓ2, jℓ1 = j6 = 8 = ℓ3, the decoder declares that the right node is not a resolvable doubleton that contains item 3.
Consider right node 4. The decoder again makes a guess that z4 = u3 ∨ uℓ1. Then, it obtains three indices as follows.

ℓ1 = 8, ℓ2 = 6, ℓ3 = 7

(19)

By noticing that iℓ1 = i8 = 6 = ℓ2, jℓ1 = j8 = 7 = ℓ3, the decoder declares that right node 4 is a resolvable doubleton including item 3. Moreover, it also ﬁnds that the other defective item’s index is ℓ1 = 8.
In the third iteration, the decoder knows that right node 2 is not resolvable anymore as it already includes two identiﬁed defective items. However, right node 3 now has a possibility of being a resolvable doubleton as the decoder found defective item 8 in the previous iteration, and defective item 8 is also in right node 3. The decoder hypothesizes that right node 3 is a doubleton, i.e., z3 = u8 ∨ uℓ1. Similarly, the decoder reads three indices, and the recovered three indices are as follows.

ℓ1 = 1, ℓ2 = 5, ℓ3 = 3

(20)

Because iℓ1 = i1 = 5 = ℓ2, jℓ1 = j1 = 3 = ℓ3, the decoder will conclude that right node 3 is a doubleton including defective item 8, and that the other defective item’s index is ℓ1 = 1.
The algorithm is terminated as there are no more right nodes to be resolved, concluding that items 1, 3 and 8
are defective items.

4 Main Results

In this section, we analyze the SAFFRON scheme. The main theoretical result of this paper is the following theorem.

Theorem 4.1. With m = 6C(ǫ)K log2 n tests, SAFFRON recovers at least (1−ǫ)K defective items with probability

1

−

O

(

K n2

),

where

ǫ

is

an

arbitrarily-close-to-zero

constant,

and

C(ǫ)

is

a

constant

that

depends

only

on

ǫ.

Table

2

shows some pairs of ǫ and C(ǫ).

Error ﬂoor, ǫ

C (ǫ)

=

d⋆ λ⋆

Left-deg, d⋆

10−3 6.13 7

10−4 7.88 9

10−5 9.63 10

10−6 11.36 12

10−7 13.10 14

10−8 14.84 15

10−9 16.57 17

10−10 18.30 19

Table 2: Pairs of ǫ and C(ǫ)

The computational complexity of the decoding algorithm is linear in the number of measurements, i.e., O(K log n), that is order-optimal.
Proof. First note that each right node is associated with 6 log2 n tests based on (5). Thus, we only need to show that the number of required right nodes to guarantee successful completion of the algorithm is C(ǫ)K.
We design a d-left-regular bipartite graph with n left nodes and M right nodes as follows. Each left node is connected to a set of d right nodes uniformly at random, independently from other left nodes. For the analysis, we focus on the pruned bipartite graph constructed by the K defective left nodes and the right nodes. Then, the

9

average right degree λ = KMd . Further, as K gets large, the degree distribution of right nodes approaches a Poisson

distribution with parameter λ. We deﬁne the right edge-degree distribution ρ(x) =

∞ i=1

ρi xi−1 ,

where

ρi

is

the

probability that a randomly selected edge in the graph is connected to a right node of degree i. Then, with this

design of random bipartite graphs,

ρi = iM Pr(degree of a random right node = i) = iM e−λ λi = e−λ λi−1 .

(21)

Kd

Kd i!

(i − 1)!

Hence, ρ(x) = e−λ(1−x). SAFFRON performs an iterative decoding procedure as follows. In the ﬁrst round, it ﬁnds all the singletons and
their corresponding defective items as described in Section 3.1. In the following rounds, it detects and resolves all the resolvable doubletons and recovers their corresponding defective items. This process is repeated until no new defective items are recovered during one iteration.
The fraction of defective items that cannot be identiﬁed at the end of this iterative decoding algorithm can be analyzed by density evolution [8, 28]. Density evolution is a tool to analyze a message-passing algorithm. At iteration j of the algorithm, an unidentiﬁed defective item passes a message to its neighbor right nodes that it has not been recovered. Let pj be the probability that a random defective item is not identiﬁed at iteration j. The density evolution relates pj to pj+1 as follows.

pj+1 = Pr(not resolvable from one children right node)d−1 = [1 − (ρ1 + ρ2(1 − pj))]d−1 ,

(22)

where ρ1 = e−λ, and ρ2 = λe−λ. To prove the above equation, consider the graph shown in Figure 2. At iteration

c1

c2

···

c

v

cd−3

cd−2

cd−1

Figure 2: A tree-like neighborhood of an edge between left node v and right node c. At iteration j + 1, a ‘not-recovered’ message is passed through this edge if and only if none of the other neighbors of v, {ci}di=−11, have been identiﬁed as either a singleton or a resolvable doubleton at iteration j.

j + 1, left node v passes a ‘not-recovered’ message to right node c if none of its other neighbor right nodes {ci}di=−11 has been identiﬁed as either a singleton or a resolvable doubleton at iteration j. The probability that a particular neighbor right node, say c1, has been resolved (either as a singleton or doubleton) at iteration j is ρ1 + ρ2(1 − pj). Then, given a tree-like neighborhood of v, all the messages are independent. Thus, the above equation follows.
To characterize the fraction of defective items that will not be recovered by the time the algorithm terminates, we ﬁnd the limit of the sequence {pj} as j → ∞. Let ǫ = limj→∞ pj. One can approximately calculate

ǫ = [1 − (ρ1 + ρ2)]d−1 = 1 − e−λ − λe−λ d−1 .

(23)

We can also pictorially see how pj evolves as follows. We ﬁrst draw a vertical line from (pj, pj) to (pj, γ(p)) and then a horizontal line from (pj, γ(pj)) to (γ(pj), γ(pj)) = (pj+1, pj+1). We repeat the above procedure until pj converges to a ﬁxed point. Figure 3 plots the function γ(p) d=ef [1 − (ρ1 + ρ2(1 − p))]d−1 when λ = 1.038 and d = 19. Starting from p1 = 1, we observe that pj converges to ǫ = 1 − e−λ − λe−λ d−1 ≃ 10−10.
We now ﬁnd a pair of design parameters (d, M ) that minimize the number of right nodes M (thus the number
of tests) given a targeted reliability ǫ.

(d − 1) log(1 − e−λ − λe−λ) = log ǫ.

(24)

10

100 p γ(p)
10-2

10-4

10-6

10-8

10-10

10-12

10-12 10-10 10-8

10-6

10-4

10-2

100

p

Figure 3: Density evolution. Plotted is the function γ(p) = [1 − (ρ1 + ρ2(1 − p))]d−1 with λ = 1.038 and d = 19 along with y = p. Note that γ(p) meets the identity function at p = 10−10. The dash-dotted line shows how {pj} evolves starting from pj = 1 as j increases.

We solve the following optimization problem numerically.

min M = Kd (25)

λ>0

λ

subject to (d − 1) log(1 − e−λ − λe−λ) = log ǫ.

(26)

We numerically solve the optimization problem and attain the optimal λ⋆ and d⋆ as a function of ǫ. Some of the

optimal design parameters for different reliability levels are shown in Table 2.

We deﬁne C(ǫ)

=

M K

=

d⋆ λ⋆

.

Up to now, we have analyzed the average fraction of unidentiﬁed defective items over a randomly constructed

bipartite graph. To complete the proof, we need to show three more steps. First, we need to show that after a

ﬁxed number of iterations, pj gets arbitrarily close to ǫ. Second, we need to show that with high probability, a

constant-depth neighborhood of a random left node is a tree. Finally, using the steps 1 and 2, we show that the

actual fraction of unidentiﬁed defective items is highly concentrated around its average. These proofs are identical

to the ones (Corollary 2.5., Lemma 2.6., Lemma 2.7.) in [29], which we omit for the purpose of readability.

4.1 A Variant of SAFFRON: Singleton-Only-SAFFRON

We now present a variant of the SAFFRON scheme that only detects and resolves singletons. We call this scheme Singleton-Only-SAFFRON. Clearly, the decoding algorithm of Singleton-Only-SAFFRON is not iterative; instead, it detects and resolves all singletons in a single-stage procedure. We remark that Singleton-Only-SAFFRON is closely related to the non-adaptive GROTESQUE, proposed in [20]: both schemes detect and resolve singletons only. However, Singleton-Only-SAFFRON requires signiﬁcantly lower number of tests than the non-adaptive GROTESQUE. This is because our deterministic signature matrix is more efﬁcient than the random signature matrices.
We show that using only singletons costs us an extra factor O(log K) in the number of tests and computational complexity. However, the Singleton-Only-SAFFRON scheme can recover all the K defective items with high probability.
The measurement matrix of Singleton-Only-SAFFRON is similar to the one of SAFFRON with the difference that the signature matrix only consists of U1 and U 1 as stated in (6). The reason is that the algorithm does not intend to detect and resolve doubletons, as explained in Section 3.2.

Theorem 4.2. With m = 2e(1+α)K log K log2 n ≃ 5.437(1+α)K log K log2 n tests, Singleton-Only-SAFFRON

ﬁnds

all

the

K

defective

items

with

probability

1

−

O

(

1 Kα

),

where

e

is

the

base

of

the

natural

logarithm,

and

α > 0. The computational complexity of the decoding algorithm is linear in the number of measurements, i.e.,

O(K log K log n).

Proof. First note that each right node is associated with 2 log2 n tests based on (6). Thus, we only need to show that the number of required right nodes to guarantee successful completion of the algorithm is e(1 + α)K log K.

11

We design a bipartite graph with M = e(1 + α)K log K right nodes. Each left node is connected to a certain

right node with

probability p

=

1 K

independently of

everything else.

Then,

the

average degree of

a

right node is

λ = Kp = 1. Note that the probability that a certain defective item is not connected to any singletons is as follows.

M M pi(1 − p)M−i(1 − e−1)i = (p(1 − e−1) + (1 − p))M = (1 − pe−1)M

(27)

i=0 i

Hence, the probability that any of the K items is not found can be bounded using union bound as follows.

Pe ≤ K(1 − pe−1)M ≤ K e−pe−1 (1+α)eK log K

(28) (29)

= K−α

(30)

In (29), we use 1 − x ≤ e−x for all x.

5 Robustiﬁed SAFFRON for Noisy Group Testing
In this section, we robustify SAFFRON such that it can recover the set of K defective items with erroneous or noisy test results. We assume an i.i.d. noise model. That is, each test result is ‘wrong’ with probability q, i.e.,

y = A ⊙ x + w,

(31)

where the addition is over binary ﬁeld, and w is an i.i.d. noise vector whose components are 1 with probability

0

<

q

<

1 2

and

0

otherwise.

3

Our approach is simple: we design the robust signature matrix U ′ consisting of encoded columns of Uj for

1 ≤ j ≤ 3 and their complements. Intuitively, we treat each column of Uj as a message that needs to be transmitted

over a noisy memoryless communication channel. An efﬁcient modern error-correcting code guarantees reliable

decoding of the signature. Spatially-coupled LDPC codes have the following properties [30].

• It has an encoding function f (·) : {0, 1}N → {0, 1}N/R and a decoding function g(·) : {0, 1}N/R → {0, 1}N , and its decoding complexity is O(N ).

• If R satisﬁes

R < 1 − H(q) − δ = q log2 q + (1 − q) log2 (1 − q) − δ,

(32)

for an arbitrarily small constant δ > 0, then Pr(g(x + w) = x) < 2−ζN as N approaches inﬁnity, for some constant ζ > 0.
Note that each column of Uj is of length log2 n. Thus, N = log2 n in this setup. Given such an error-correcting code, we design the signature matrix U for the robust SAFFRON scheme as follows.

 f (b1) f (b2) f (b3) . . . f (bn−2) f (bn−1) 

 

f (b1)

f (b2)

f (b3)

...

f (bn−2)

f (bn−1)

 





U =  f (bi1 ) f (bi2 ) f (bi3 ) . . . f (bin−1 ) f (bin )  ∈ {0, 1} 6 loRg2 n ×n (33)

 

f (bi1 )

f (bi2 )

f (bi3 )

...

f (bin 1 )

f (bin )

 

−





 f (bj1 ) f (bj2 ) f (bj3 ) . . . f (bjn−1 ) f (bjn ) 

f (bj1 ) f (bj2 ) f (bj3 ) . . . f (bjn−1 ) f (bjn )

We now describe how the robustiﬁed SAFFRON detects and resolves a singleton. Consider a singleton right node k. Then, the right-node measurement vector is of the following form.

zk = uk + w

(34)

The decoder ﬁrst applies the decoding function g(·) to the ﬁrst, third, and ﬁfth segments of the right-node measurement vector and obtains g(z1k), g(z3k), and g(z5k). Let ℓ1 − 1 be the decimal representation of g(z1k), ℓ2 − 1 be the
3If q > 21 , one can always take the complement of all the test results, and treat the channel as if each test result is wrong with crossover probability 0 < q˜ = 1 − q < 12 .

12

decimal representation of g(z3k), and ℓ3 − 1 be the decimal representation of g(z5k). We use the following singleton detection rule.

iℓ1 = ℓ2, jℓ1 = ℓ3

(35)

If the above conditions are satisﬁed, the decoder declares a singleton and the location index of the defective item ℓ1.

Lemma 5.1.

Robustiﬁed-SAFFRON misses a singleton with probability no greater than

3 nζ

.

Robustiﬁed-SAFFRON

wrongly

declares

a

defective

item

with

probability

no

greater

than

1 n2+ζ

.

Proof. Robustiﬁed-SAFFRON misses a singleton only if any of the 3 decoded indices is wrong. The probability

of

such

an event is

upper bounded by

3 nζ

by

the

union bound.

Robustiﬁed-SAFFRON

wrongly declares a

defective

item only if ℓ1 is wrongly decoded, but (35) still holds. Such an event happens with probability no greater than

1 n2+ζ

.

Lemma

5.1

implies

that

the

robustiﬁed

SAFFRON

scheme

will

miss

fewer

than

3 nζ

-fraction

of

singletons.

We

compensate this loss by increasing the number of right nodes: instead of using M right nodes, we use M

1

+

3 nζ

right nodes, so that the effective number of right nodes becomes M

1

+

3 nζ

1

−

3 nζ

≃ M.

Now, consider right node k that is a resolvable doubleton with an identiﬁed defective item ℓ0 and an unidentiﬁed

defective item ℓ1. Then, the right-node measurement vector is of the following form.







 z1 

f (bℓ0 )

f (bℓ1 )

 w1 

k
 z2 

 f (bℓ0 ) 

 f (bℓ1 ) 

k
 w2 

 

k
z3

 

 f (biℓ ) 

 f (biℓ ) 

 

k
w3

 

 

k
z4k

 = uℓ0 ∨ uℓ1 + wk = 

f (b

0
)

 

∨

 



f (b

1
)

 

+





k
wk4

 

(36)

 

z5

 

k



iℓ0 

 f (bj ) 



iℓ1 

 f (bj ) 

 

w5

 

k

z6k



ℓ0  

ℓ1 

wk6

f (bjℓ )

f (bjℓ )

0

1

Consider the ﬁrst two sections of the measurement vector z1k and z2k. We show that since the decoder knows uℓ0 , it can get access to the measurement uℓ1 + wk. To this end, the decoder ﬁrst looks at the ﬁrst bit of uℓ0. If this bit is 0, then the ﬁrst bit of z1k is indeed the ﬁrst bit of f (bℓ1) + wk1. Now, if the ﬁrst bit of uℓ0 is 1, the decoder complements the ﬁrst bit of z2k to get the ﬁrst bit of f (bℓ1) + wk2. Similar procedure can be performed for all bits. By collecting all the bits, the decoder has access to f (bℓ1) + wk′1, where wk′1 has the same statistics as the original i.i.d. noise. Then, it can apply the decoding function to obtain ℓ1. Similarly, using the other sections of the measurement vector, the decoder can recover ℓ2 and ℓ3. Thus, by testing the detection rules in (35), the decoder can detect a resolvable doubleton.
We now present the following theorem for noisy group testing.

Theorem 5.2. With m = 6β(q)C(ǫ)K log2 n tests, Robustiﬁed-SAFFRON can recover at least (1 − ǫ)K defective

items

with

probability

1−O(

K n2+ζ

),

where

ǫ

is

an

arbitrarily-close-to-zero

constant,

C

(ǫ)

is

a

constant

that

depends

only

on

ǫ,

and

β(q)

=

1 R

>

1 1−H(q)−δ

for

an

arbitrarily

small

constant δ

>

0.

Table

2

shows

some

pairs

of

ǫ

and

C(ǫ). The computational complexity of the decoding algorithm is linear in the number of tests, i.e., O(K log n).

5.1 The Robustiﬁed Singleton-Only-SAFFRON

The Singleton-Only-SAFFRON scheme can also be robustiﬁed in a similar manner. We design the signature matrix U for the robustiﬁed SAFFRON scheme as follows.
 f (b1) f (b2) f (b3) . . . f (bn−2) f (bn−1)  U =  f (bi1 ) f (bi2 ) f (bi3 ) . . . f (bin−1 ) f (bin )  ∈ {0, 1} 3 loRg2 n ×n (37)
f (bj1 ) f (bj2 ) f (bj3 ) . . . f (bjn−1 ) f (bjn )

As explained before, by decoding the three sections of the measurement vector and checking whether three decoded indices satisfy (35), the decoder can detect and resolve singletons.

Theorem 5.3. With m = 3e(1 + α)β(q)K log K log2 n ≃ 8.1548(1 + α)β(q)K log K log2 n tests, the robus-

tiﬁed Singleton-Only-SAFFRON can ﬁnd all K

defective

items

with

probability

1

−

O

(

1 Kα

),

where β(q)

=

1 R

>

1 1−H(q)−δ

for

an

arbitrarily

small

constant

δ

>

0

and

some

constant

α

>

0.

The

computational

complexity

of

the

decoding algorithm is linear in the number of measurements, i.e., O(K log K log n).

13

Average fraction of unidentified defective items

100

d = 3

d = 5

10-1

d = 7 d = 9

10-2

10-3

10-4

1

2

3

4

5

6

7

Number of right nodes per defective item, M/K

Figure 4: The average fraction of unidentiﬁed defective items obtained via simulations. For different pairs of (d, M ), we simulated SAFFRON 1000 times and measured the average fraction of unidentiﬁed defective items. We set n = 216, K = 100,
d ∈ {3, 5, 7, 9} and K ≤ M ≤ 7K.

6 Simulation results

In this section, we evaluate the performance of the SAFFRON scheme and the robust SAFFRON scheme via extensive simulations. We implement simulators for both schemes in Python and test them on a laptop 4.

6.1 SAFFRON

The SAFFRON scheme recovers with high probability an arbitrarily-close-to-one fraction of K defective items with O(K log n) tests, as stated in Theorem 4.1. The theorem also characterizes the optimal pairs of (d⋆, λ⋆) for a target
recovery performance ǫ: as the fraction of unidentiﬁed defective items ǫ decreases, the corresponding optimal leftdegree d⋆ increases. For different pairs of (d, M ), we run SAFFRON 1000 times and measure the average fraction of unidentiﬁed defective items: we choose n = 216, K = 100, d ∈ {3, 5, 7, 9} and K ≤ M ≤ 7K. Plotted in
Figure 4 are the average fractions of unidentiﬁed defective items obtained via simulations for different values of d.
As expected, we can observe that if M is close to K, the average fraction of unidentiﬁed defective items can be
minimized by setting d = 3, and if M is close to 7K, higher values of d perform better.
We now simulate how computationally-efﬁcient SAFFRON’s decoding algorithm is. We measure the average runtime of SAFFRON with n = 232, while increasing the value of K. In Figure 5a, we plot the simulation results, and they clearly demonstrate the O(K) factor of the computational complexity. Similarly, we repeat simulations with K = 25 = 32, while increasing the value of n. In Figure 5b, we plot the average runtime of SAFFRON with a logarithmic x-axis: we can clearly observe the O(log n) factor of the computational complexity.

6.2 Robustiﬁed-SAFFRON

We now evaluate the robustiﬁed SAFFRON scheme. In our setting, we choose n = 232 ≃ 4.3 × 109 and K = 27 =

128. For random bipartite graphs, we use d = 12 and M = 11.36K. The noise model is the one we described in

Section 5. We vary the probability of error q from 0.03 to 0.05: a test result is ﬂipped with probability from 3% to

5%.

While we made use of capacity-achieving codes in Theorem 5.2, we use Reed-Solomon codes for simulations

for simplicity [31]. A Reed-Solomon code takes a message of ck symbols from a ﬁnite ﬁeld of size cq ≥ cn, for a

prime

power

cq ,

and

then

encodes

the

message

into

cn

symbols.

This

code

can

correct

upto

any

⌊

cn

−ck 2

⌋

symbol

errors. By using a ﬁeld of size cq = 28, a binary representation of length L (= log2 n) can be viewed as a 4-symbol

message, i.e., ck = 4. Thus, the overall number of tests is as follows:

m = 11.36K ×

cn

× 6 log n .

ck

2

Number of right nodes

Number of message bits

Error-correcting code expansion

(38)

4We used a laptop with 2 GHz Intel Core i7 and 8 GB memory.

14

Average runtime of SAFFRON (seconds) Average runtime of SAFFRON (seconds)

20 Average runtime of SAFFRON Linear fit
15

0.4 Average runtime of SAFFRON Linear fit
0.3

10

0.2

5

0.1

0

0

500

1000

1500

2000

Number of defective items, K

(a) Runtime with n = 232 and varying K.

0

20

28

216

224

232

240

248

Number of items, n

(b) Run-time with K = 25 and varying n.

Figure 5: Time complexity of SAFFRON. We measure run-time of SAFFRON for varying values for n and K.

By having cn = ck + 2t, the robustiﬁed SAFFRON scheme can correct upto t symbol errors within each section of the right-node measurement vector. Thus, we evaluate the performance of the robustiﬁed SAFFRON scheme with cn ∈ {6, 8, . . . , 16} for various noise levels. We measure the average fraction of unidentiﬁed defective items over 1000 runs for each setup. Figure 6 shows the simulation results; the x-axis is the block-length of the used code, and the logarithmic y-axis is the average fraction of unidentiﬁed defective items. We can observe that for a higher noise level q, the minimum block length required to achieve a certain value of ǫ increases.
We also observe that the robustiﬁed SAFFRON perfectly recovers all defective items even with the presence of erroneous test results with certain parameters. For instance, with q = 0.02, we test the robustiﬁed SAFFRON 1000 times with cn = 12. For all the test cases, it successfully recovers all K = 128 defective items from the population of n ≃ 4.3 × 109 items with m = 838080 ≃ 100200 n tests. Further, the decoding time takes only about 3.8 seconds on average. Similarly, we observe the perfect recovery with q = 0.01 and cn ≥ 12 and with q = 0.005 and cn ≥ 6.

7 Conclusion

In this paper, we have proposed SAFFRON (Sparse-grAph codes Framework For gROup testiNg), which recovers

an arbitrarily-close-to-one (1 − ǫ)-fraction of K defective items with high probability with 6C(ǫ)K log2 n tests, where C(ǫ) is a relatively small constant that depends only on ǫ. Also, the computational complexity of the decod-

ing algorithm of SAFFRON is order-optimal. We have described the design and analysis of SAFFRON based on

the powerful modern coding-theoretic tools of sparse-graph coding and density evolution. We have also proposed a

variant of SAFFRON, Singleton-Only-SAFFRON, which recovers all defective items with 2e(1+α)K log K log2 n

tests,

with

probability

1

−

O

(

1 Kα

).

Further,

we

robustify

SAFFRON

and

Singleton-Only-SAFFRON

by

using

mod-

ern error-correcting codes so that they can recover the set of defective items with noisy test results. To support

our theoretical results, we have provided extensive simulation results that validate the theoretical efﬁcacy and the

practical potential of SAFFRON.

References
[1] F. K. Hwang et al., “Combinatorial group testing and its applictions,” 2000.
[2] H.-B. Chen and F. Hwang, “A survey on nonadaptive group testing algorithms through the angle of decoding,” Journal of Combinatorial Optimization, vol. 15, no. 1, pp. 49–59, 2008. [Online]. Available: http://dx.doi.org/10.1007/s10878-007-9083-3
[3] D. Malioutov and K. Varshney, “Exact rule learning via boolean compressed sensing,” in Proceedings of The 30th International Conference on Machine Learning, 2013, pp. 765–773.
[4] A. Ganesan, S. Jaggi, and V. Saligrama, “Learning immune-defectives graph through group tests,” arXiv preprint arXiv:1503.00555, 2015.
[5] M. Goodrich, M. Atallah, and R. Tamassia, “Indexing information for data forensics,” in Applied Cryptography and Network Security, ser. Lecture Notes in Computer Science, J. Ioannidis, A. Keromytis,

15

Average fraction of unidentified defective items

100

10-1

10-2

10-3

10-4

10-5

q = 0.03

q = 0.04

q = 0.05

10-6

6

8

10

12

14

16

Block length, cn

Figure 6: Noisy simulation results. We evaluate performance of our algorithm with noisy group testing results. For each pair of parameters, we measure the average fraction of missed defective items.

and M. Yung, Eds. Springer Berlin Heidelberg, 2005, vol. 3531, pp. 206–221. [Online]. Available: http://dx.doi.org/10.1007/11496137 15
[6] A. Gilbert, M. Iwen, and M. Strauss, “Group testing and sparse signal recovery,” in 42nd Asilomar Conference on Signals, Systems and Computers, Oct 2008, pp. 1059–1063.
[7] A. Emad and O. Milenkovic, “Poisson group testing: A probabilistic model for nonadaptive streaming boolean compressed sensing,” in IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), May 2014, pp. 3335–3339.
[8] T. Richardson and R. Urbanke, Modern Coding Theory. Cambridge University Press, 2008.
[9] H. Q. Ngo and D.-Z. Du, “A survey on combinatorial group testing algorithms with applications to dna library screening,” vol. 55, pp. 171–182, 2000.
[10] A. Mazumdar, “Nonadaptive group testing with random set of defectives via constant-weight codes,” arXiv preprint arXiv:1503.03597, 2015.
[11] A. G. D’yachkov and V. V. Rykov, “Bounds on the length of disjunctive codes,” Problemy Peredachi Informatsii, vol. 18, no. 3, pp. 7–13, 1982.
[12] ——, “Superimposed distance codes,” Problems Control Inform. Theory/Problemy Upravlen. Teor. Inform., vol. 18, no. 4, pp. 273–250, 1989.
[13] H. Q. Ngo and D.-Z. Du, “New constructions of non-adaptive and error-tolerance pooling designs,” Discrete Mathematics, vol. 243, no. 13, pp. 161 – 170, 2002. [Online]. Available: http://www.sciencedirect.com/science/article/pii/S0012365X00004659
[14] P. Indyk, H. Q. Ngo, and A. Rudra, “Efﬁciently decodable non-adaptive group testing,” in Proceedings of the Twenty-ﬁrst Annual ACM-SIAM Symposium on Discrete Algorithms, ser. SODA ’10. Philadelphia, PA, USA: Society for Industrial and Applied Mathematics, 2010, pp. 1126–1142. [Online]. Available: http://dl.acm.org/citation.cfm?id=1873601.1873692
[15] W. J. Bruno, E. Knill, D. J. Balding, D. Bruce, N. Doggett, W. Sawhill, R. Stallings, C. C. Whittaker, and D. C. Torney, “Efﬁcient pooling designs for library screening,” Genomics, vol. 26, no. 1, pp. 21–30, 1995.
[16] F. K. Hwang, “Random k-set pool designs with distinct columns,” Probab. Eng. Inf. Sci., vol. 14, no. 1, pp. 49–56, Jan. 2000. [Online]. Available: http://dx.doi.org/10.1017/S0269964800141051
[17] A. Macula, “Probabilistic nonadaptive group testing in the presence of errors and dna library screening,” Annals of Combinatorics, vol. 3, no. 1, pp. 61–69, 1999. [Online]. Available: http://dx.doi.org/10.1007/BF01609876
16

[18] G. K. Atia and V. Saligrama, “Boolean compressed sensing and noisy group testing,” Information Theory, IEEE Transactions on, vol. 58, no. 3, pp. 1880–1901, 2012.
[19] C. L. Chan, S. Jaggi, V. Saligrama, and S. Agnihotri, “Non-adaptive group testing: Explicit bounds and novel algorithms,” in Information Theory Proceedings (ISIT), 2012 IEEE International Symposium on, July 2012, pp. 1837–1841.
[20] S. Cai, M. Jahangoshahi, M. Bakshi, and S. Jaggi, “Grotesque: Noisy group testing (quick and efﬁcient),” in Communication, Control, and Computing (Allerton), 2013 51st Annual Allerton Conference on, Oct 2013, pp. 1234–1241.
[21] S. Pawar and K. Ramchandran, “Computing a k-sparse n-length discrete fourier transform using at most 4k samples and o(k log k) complexity,” in Information Theory Proceedings (ISIT), 2013 IEEE International Symposium on, July 2013, pp. 464–468.
[22] ——, “A robust sub-linear time R-FFAST algorithm for computing a sparse DFT,” CoRR, vol. abs/1501.00320, 2015. [Online]. Available: http://arxiv.org/abs/1501.00320
[23] X. Li, J. Bradley, S. Pawar, and K. Ramchandran, “The spright algorithm for robust sparse hadamard transforms,” in Information Theory (ISIT), 2014 IEEE International Symposium on, June 2014, pp. 1857–1861.
[24] X. Li, S. Pawar, and K. Ramchandran, “Sub-linear time support recovery for compressed sensing using sparsegraph codes,” in Information Theory Proceedings (ISIT), 2015 IEEE International Symposium on, July 2015.
[25] R. Pedarsani, K. Lee, and K. Ramchandran, “Phasecode: Fast and efﬁcient compressive phase retrieval based on sparse-graph codes,” in Communication, Control, and Computing (Allerton), 2014 52nd Annual Allerton Conference on, Sept 2014, pp. 842–849.
[26] ——, “Capacity-approaching phasecode for low-complexity compressive phase retrieval,” in Information Theory Proceedings (ISIT), 2015 IEEE International Symposium on, July 2015.
[27] D. Yin, K. Lee, R. Pedarsani, and K. Ramchandran, “Fast and robust compressive phase retrieval with sparsegraph codes,” in Information Theory Proceedings (ISIT), 2015 IEEE International Symposium on, July 2015.
[28] A. Shokrollahi, “LDPC codes: An introduction,” in Coding, cryptography and combinatorics. Springer, 2004, pp. 85–110.
[29] R. Pedarsani, K. Lee, and K. Ramchandran, “Phasecode: Fast and efﬁcient compressive phase retrieval based on sparse-graph-codes,” CoRR, vol. abs/1408.0034, 2014. [Online]. Available: http://arxiv.org/abs/1408.0034
[30] S. Kudekar, T. Richardson, and R. Urbanke, “Threshold saturation via spatial coupling: Why convolutional LDPC ensembles perform so well over the BEC,” Information Theory, IEEE Transactions on, vol. 57, no. 2, pp. 803–834, Feb 2011.
[31] D. Costello and S. Lin, “Error control coding,” New Jersey, 2004.
17

