Learning to Organize Knowledge and Answer Questions with N-Gram Machines

arXiv:1711.06744v4 [cs.CL] 3 Mar 2019

Fan Yang∗ Jiazhong Nie

William W. Cohen

Ni Lao†

Carnegie Mellon University, Pittsburgh, PA

Google LLC, Mountain View, CA

SayMosaic Inc., Palo Alto, CA

{fanyang1,wcohen}@cs.cmu.edu, niejiazhong@google.com, ni.lao@mosaix.ai

Abstract
Though deep neural networks have great success in natural language processing, they are limited at more knowledge intensive AI tasks, such as open-domain Question Answering (QA). Existing end-to-end deep QA models need to process the entire text after observing the question, and therefore their complexity in responding a question is linear in the text size. This is prohibitive for practical tasks such as QA from Wikipedia, a novel, or the Web. We propose to solve this scalability issue by using symbolic meaning representations, which can be indexed and retrieved efﬁciently with complexity that is independent of the text size. We apply our approach, called the N-Gram Machine (NGM), to three representative tasks. First as proof-of-concept, we demonstrate that NGM successfully solves the bAbI tasks of synthetic text. Second, we show that NGM scales to large corpus by experimenting on “life-long bAbI”, a special version of bAbI that contains millions of sentences. Lastly on the WIKIMOVIES dataset, we use NGM to induce latent structure (i.e. schema) and answer questions from natural language Wikipedia text, with only QA pairs as weak supervision.
1 Introduction
Knowledge management and reasoning is an important task in Artiﬁcial Intelligence. It involves organizing information in the environment into structured object (e.g. knowledge storage). Moreover, the structured object is designed to enable complex querying by agents. In this paper, we focus on the case where information is represented in text. An exemplar task is question answering from large corpus. Traditionally, the study of knowledge management and reasoning is divided into independent subtasks, such as Information Extraction [7, 22] and Semantic Parsing [6, 13, 16]. Though great progress has been made on each individual tasks, dividing the tasks upfront (i.e. designing the structure or schema) is costly, as it heavily relies on human experts, and sub-optimal, as it cannot adapt to the query statistics. To remove the bottleneck of dividing the task, end-to-end models have been proposed for question answering, such as Memory Networks [21, 31]. However, these networks lack scalability– the complexity of reasoning with the learned memory is linear of the corpus size, which prohibits applying them to large web-scale corpus.
We present a new QA system that treats both the schema and the content of a structured storage as discrete hidden variables, and infers these structures automatically from weak supervisions (such as QA pair examples). The structured storage we consider is simply a set of “n-grams”, which we show can represent a wide range of semantics, and can be indexed for efﬁcient computations at scale. We present an end-to-end trainable system which combines a text auto-encoding component for encoding
∗ Part of the work was done while the author was interning at Google † Part of the work was done while the author was working at Google
Preprint. Work in progress.

knowledge, and a memory enhanced sequence to sequence component for answering questions from the encoded knowledge. The system we present illustrates how end-to-end learning and scalability can be made possible through a symbolic knowledge storage.

1.1 Question Answering: Deﬁnition and Challenges
We ﬁrst deﬁne question answering as producing the answer a given a corpus T = t1, . . . , t|T |, which is a sequence of text piece’s, and a question q. Both ti = ti,1, . . . , ti,|ti| and q = q1, . . . , q|q| are sequences of words. We focus on extractive question answering, where the answer a is always a word in one of the sentences. In Section 4 we illustrate how this assumption can be relaxed by named entity annotations. Despite its simple form, question answering can be incredibly challenging. We identify three main challenges in this process, which our new framework is designed to meet.

Scalability A typical QA system, such as Watson [8] or any of the commercial search engines [4], processes millions or even billions of documents for answering a question. Yet the response time is restricted to a few seconds or even fraction of seconds. Answering any possible question that is answerable from a large corpus with limited time means that the information need to be organized and indexed for fast access and reasoning.

Representation A fundamental building block for text understanding is paraphrasing. Consider answering the question “Who was Adam Smith’s wife?’ from the Web. There exists the following snippet from a reputable website “Smith was born in Kirkcaldy, ... (skipped 35 words) ... In 1720, he married Margaret Douglas”. An ideal system needs to identify that “Smith” in this text is equivalent to “Adam Smith” in the question; “he” is referencing “Smith”; and text expressions of the form “X married Y” answer questions of the form “Who was X’s wife?”.
By observing users’ interactions, a system may capture certain equivalence relationships among expressions in questions [3]. However, given these observations, there is still a wide range of choices for how the meaning of expressions can be represented. Open information extraction approaches [1] represent expressions by themselves, and rely on corpus statistics to calculate their similarities. This approach leads to data sparsity, and brittleness on out-of-domain text. Vector space approaches [20, 31, 24, 21] embeds text expressions into latent continuous spaces. They allow ﬂexible matching of semantics for arbitrary expressions, but are hard to scale to knowledge intensive tasks, which require inference with large amount of data.

Reasoning The essence of reasoning is to combine pieces of information together. For example, from co-reference(“He”, “Adam Smith”) and has_spouse(“He”, “Margaret Douglas”) to has_spouse(“Adam Smith”, “Margaret Douglas”). As the number of relevant pieces grows, the search space grows exponentially – making it a hard search problem [15]. Since reasoning is closely coupled with how the text meaning is stored, an optimal representation should be learned end-to-end (i.e. jointly) in the process of knowledge storing and reasoning.

1.2 N-Gram Machines: A Scalable End-to-End Approach

We propose to solve the scalability issue of neural

network text understanding models by learning to represent the meaning of text as a symbolic knowl- Text

Knowledge Store

Answer

edge storage. Because the storage can be indexed be-

fore being used for question answering, the inference

Execution

step can be done very efﬁciently with complexity

Generation

that is independent of the original text size. More speciﬁcally the structured storage we consider is sim-

Question

Program

Latent Observed

ply a set of “n-grams”, which we show can represent complex semantics presented in bAbI tasks [30] and can be indexed for efﬁcient computations at scale. Each n-gram consists of a sequence of tokens, and

Figure 1: An end-to-end QA system. Both the knowledge store and the program are nondifferentiable and hidden.

each token can be a word, or any predeﬁned special

symbol. Different from conventional n-grams, which are contiguous chunks of text, the “n-grams”

considered here can be any combination of arbitrary words and symbols. The whole system (Figure 1)

consists of learnable components which convert text into symbolic knowledge storage and questions

2

into programs (details in Section 2.1). A deterministic executor executes the programs against the knowledge storage and produces answers. The whole system is trained end-to-end with no human annotation other than the expected answers to a set of question-text pairs.

2 N-Gram Machines

In this section we ﬁrst describe the N-Gram Machine (NGM) model structure, which contains three sequence to sequence modules, and an executor that executes programs against knowledge storage. Then we describe how this model can be trained end-to-end with reinforcement learning. We use the bAbI dataset [30] as running examples.

2.1 Model Structure

Knowledge storage Given a corpus T = t1, . . . , t|T | NGM produces a knowledge storage G = g1, . . . , g|T |, which is a list of n-grams. An n-gram gi = gi,1, . . . , gi,N is a sequence of symbols, where each symbol gi,j is either a word from text piece ti or a symbol from the model vocabulary. The knowledge storage is probabilistic – each text piece ti produces a distribution over n-grams, and the probability of a knowledge storage can be factorized as the product of n-gram
probabilities(Equation 1). Example knowledge storages are shown in Table 2 and Table 5. For
certain tasks the model needs to reason over time. So we associate each n-gram gi with a time stamp τ (gi) := i with is simply its id in corpus T .

Programs The programs in NGM are similar to those introduced in Neural Symbolic Machines [16], except that NGM functions operate on n-grams instead of Freebase triples. NGM functions specify how symbols can be retrieved from a knowledge storage as in Table 1. Pref and Suff return symbols from all the matched n-grams, while PrefMax and SuffMax return from the latest matches.

Table 1: Functions in NGMs. G is the knowledge storage (will be implicit in the actual program), and the input n-gram is v = v1, . . . , vL. We use gi,:L to denote the ﬁrst L symbols in gi, and gi,−L: to denote the last L symbols of gi in reverse order.
Pref(v, G) = {gi,L+1 | gi,:L = v, ∀gi ∈ G} Suff(v, G) = {gi,−L−1 | gi,−L: = v, ∀gi ∈ G} PrefMax(v, G) = {argmaxg∈Pref(v,G)τ (g)} SuffMax(v, G) = {argmaxg∈Suff(v,G)τ (g)}

More formally a program p is a list of statement p1, ..., p|p|, where pi is either a special expression Return indicating the end of the program, or is of the form f v1...vL where f is a function in Table 1 and v1...vL are L input arguments of f . When an expression is executed, it returns a set of symbols by matching its arguments in G, and stores the result in a new variable symbol (e.g., V1) to reference the result (see Table 2 for an example). Though executing a program on a knowledge storage as described above is deterministic, probabilities are assigned to the execution results, which are the products of probabilities of the corresponding program and knowledge storage. Since the knowledge storage can be indexed using data structures such as hash tables, the program execution time is independent of the size of the knowledge storage.

Seq2Seq components NGM uses three sequence-to-sequence [28] neural network models to deﬁne probability distributions over n-grams and programs:

• A knowledge encoder that converts text pieces to n-grams and deﬁnes a distribution P (g|t, c; θenc). It is also conditioned on context c which helps to capture long range dependencies such as document title or co-references3. The probability of a knowledge storage G = g1 . . . g|T | is deﬁned as the product of its n-grams’ probabilities:

P (G|T ; θenc) = Πgi∈GP (gi|ti, ci; θenc)

(1)

• A knowledge decoder that converts n-grams back to text pieces and deﬁnes a distribution P (t|g, c; θdec). It enables auto-encoding training, which is crucial for efﬁciently ﬁnding good knowledge representations (See Section 2.2).

3Ideally it should condition on the partially constructed G at time i, but that makes it hard to do LSTM batch training and is beyond the scope of this work.

3

• A programmer that converts questions to programs and deﬁnes a distribution P (p|q, G; θprog). It is conditioned on the knowledge storage G for code assistance [16] – before generating each token the programmer can query G for valid next tokens given a n-gram preﬁx, and therefore avoid writing invalid programs.
We use the CopyNet [9] architecture, which has copy [29] and attention [2] mechanisms. The programmer is also enhanced with a key-variable memory [16] for compositing semantics.

2.2 Optimization

Given an example (T, q, a) from the training set, NGM maximizes the expected reward

OQA(θenc, θprog) =

P (G|T ; θenc)P (p|q, G; θprog)R(G, p, a),

(2)

Gp

where the reward function R(·) returns 1 if executing p on G produces a and 0 otherwise. Since the training explores an exponentially large latent spaces, it is very challenging to optimize OQA.
To reduce the variance of inference we approximate the expectations with beam searches instead of
sampling. The summation over all programs is approximated by summing over programs found by a beam search according to P (p|q, G; θprog). For the summation over knowledge storages G, we ﬁrst run beam search for each text piece based on P (gi|ti, ci; θenc), and then sample a set of knowledge storages by independently sampling from the n-grams of each text piece. We further introduce two
techniques to iteratively reduce and improve the search space:

Stabilized Auto-Encoding (AE) We add an auto-encoding objective to NGM, similar to the text summarization model proposed by Miao et al [19]. The auto-encoding objective can be optimized by variational inference [14, 23]:
OVAE(θenc, θdec) = Ep(z|x;θenc)[log p(x|z; θdec) + log p(z) − log p(z|x; θenc)], (3)
where x is text, and z is the hidden discrete structure. However, it suffers from instability due to the strong coupling between encoder and decoder – the training of the decoder θdec relies solely on a distribution parameterized by the encoder θenc, which changes throughout the course of training. To improve the training stability, we propose to augment the decoder training with a more stable objective – predict the data x back from noisy partial observations of x, which are independent of θenc. More speciﬁcally, for NGM we force the knowledge decoder to decode from a ﬁxed set of hidden sequences z ∈ ZN (x), which includes all n-gram of length N that consist only words from text x:
OAE(θenc, θdec) = Ep(z|x;θenc)[log p(x|z; θdec)] + log p(x|z; θdec), (4)
z∈ZN (x)
The knowledge decoder θdec converts knowledge tuples back to sentences and the reconstruction log-likelihoods approximate how informative the tuples are, which can be used as reward for the knowledge encoder. We also drop the KL divergence (last two terms in Equation 3) between language model p(z) and the encoder, since the z’s are produced for NGM computations instead of human reading, and does not need to be in ﬂuent natural language. Sequential Denoising Autoencoder [11].

Structure Tweaking (ST) NGM contains two discrete hidden variables – the knowledge storage G, and the program p. The training procedure only gets rewarded if these two representations agree on the symbols used to represent certain concept (e.g., "X is the producer of a movie Y"). To help exploring the huge search space more efﬁciently, we apply structure tweak, a procedure which is similar to code assist [16], but works in an opposite direction – while code assist uses the knowledge storage to inform the programmer, structure tweak adjusts the knowledge encoder to cooperate with an uninformed programmer.

Algorithm 1 Structure tweak.
Input: knowledge storage G; statement f v1 . . . vL from an uninformed programmer. Initialize G = ∅ if f (v1 . . . vL, G) = ∅ or f (v1, G) = ∅ then
return Let p = v1 . . . vm be the longest n-gram preﬁx/sufﬁx matched in G Let Gp be the set of n-grams matching p. for g = s1 . . . sN ∈ Gp do
Add v1 . . . vmvm+1sm+2 . . . sN to G Output tweaked n-grams G .

Together they allow the decisions in one part of

the model to be inﬂuence by the decisions from other parts – similar to Gibbs sampling.

4

More speciﬁcally, during training the programmer always performs an extra beam search with code assist turned off. If the result programs lead to execution failure, the programs can be used to propose tweaked n-grams (Algorithm 1). For example, when executing Pref john journeyed on the knowledge storage in Table 2 matching the preﬁx john journeyed fails at symbol journeyed and returns empty result. At this point, journeyed can be used to replace inconsistent symbols in the partially matched n-grams (i.e. john to bedroom), and produces john journeyed bathroom. These tweaked tuples are then added into the replay buffer for the knowledge encoder ( Appendix A.1.2), which helps it to adopt a vocabulary which is consistent with the programmer.

Now the whole model has parameters θ = [θenc, θdec, θprog], and the training objective function is

O(θ) = OAE (θenc, θdec) + OQA(θenc, θprog)

(5)

Because the knowledge storage and the program are non-differentiable discrete structures, we optimize our objective by a coordinate ascent approach – optimizing the three components in alternation with REINFORCE [32]. See Appendix A.1.2 for detailed training update rules.

3 bAbI Reasoning Tasks

Sentences

Knowledge Tuples

We apply the N-Gram Machine (NGM) to solve a set of text reasoning tasks in the Facebook bAbI dataset [30]. We ﬁrst demonstrate that the model can learn to build knowledge storage

Mary went to the kitchen She picked up the milk John went to the bedroom Mary journeyed to the garden

mary to kitchen mary the milk john to bedroom mary to garden

and generate programs that accurately answer the questions. Then we show the scalability advantage of NGMs by applying it to longer stories up to 10 million sentences.
The Seq2Seq components are implemented as one-layer recurrent neural networks with Gated Recurrent Unit [5]. The hidden dimension and the vocabulary embedding dimension are both 8. We use beam size 2 for the knowledge encoder, sample size 5 for the knowledge store,

Table 2: Example knowledge storage for bAbI tasks. To deal with coreference resolution we alway append the previous sentence as extra context to the left of the current sentence during encoding. assuming that variable V1 stores {mary} from previous executions. Executing the expression Pref V1 to returns a set of two symbols {kitchen, garden}. Similarly, executing PrefMax V1 to would instead produces {garden}.

and beam size 30 for the programmer. We take

a staged training procedure by ﬁrst train with only the auto-encoding objective for 1k epochs, then

add the question answering objective for 1k epochs, and ﬁnally add the structured tweak for 1k

epochs. For all tasks, we set the n-gram length to 3.

3.1 Extractive bAbI Tasks

The bAbI dataset contains 20 tasks in to-

T1 T2 T11 T15 T16

tal. We consider the subset of them that are extractive question answering tasks (as deﬁned in Section1.1). Each task is learned separately. In Table 3, we report results on the test sets. NGM outperforms

MemN2N

0.0 83.0 84.0 0.0 44.0

QA

0.7 2.7 0.0 0.0 9.8

QA + AE

70.9 55.1 100.0 24.6 100.0

QA + AE + ST 100.0 85.3 100.0 100.0 100.0

MemN2N [27] on all tasks listed. The Table 3: Test accuracy on bAbI tasks with auto-encoding

results show that auto-encoding is essen- (AE) and structure tweak (ST)

tial to bootstrap learning– without auto-

encoding the expected rewards are near zero; but auto-encoding alone is not sufﬁcient to achieve

high rewards (See Section 2.2). Since multiple discrete latent structures (i.e. knowledge tuples and

programs) need to agree with each other over the choice of their representations for QA to succeed,

the search becomes combinatorially hard. Structure tweaking is an effective way to reﬁne the search

space – improving the performance of more than half of the tasks. Appendix A.2 gives detailed

analysis of auto-encoding and structure tweaks.

3.2 Life-long bAbI
To demonstrate the scalability advantage of NGM we conduct experiments on question answering from large synthetic corpus. More speciﬁcally we generated longer bAbI stories using the open-source

5

script from Facebook4. We measure the answering time and answer quality of MemN2N [27]5 and NGM at different scales. The answering time is measured by the amount of time used to produce an answer when a question is given. For MemN2N, this is the neural network inference time. For NGM, because the knowledge storage can be built and indexed in advance, the response time is dominated by LSTM decoding.
Figure 2 compares query response time of MemN2N and NGM. We can see that MemN2N scales poorly – the inference time increases linearly as the story length increases. In comparison the answering time of NGM is not affected by story length. 6 To compare the answer quality at scale, we apply MemN2N and NGM to solve three life-long bAbI tasks (Task 1, 2, and 11). For each life-long task, MemN2N is run for 10 trials and the test accuracy of the trial with the best validation accuracy is used. For NGM, we use the same models trained on Figure 2: Scalability comparison. Story length is the regular bAbI tasks. We compute the aver- number of sentences in each QA pair. age and standard deviation of test accuracy from these three tasks. MemN2N performance is competitive with NGM when story length is no greater than 400, but decreases drastically when story length further increases. On the other hand, NGM answering quality is the same for all story lengths. These scalability advantages of NGM are due to its “machine” nature – the symbolic knowledge storage can be computed and indexed in advance, and the program execution is robust on stories of various lengths.
4 Schema Induction from Wikipedia
We conduct experiments on the WIKIMOVIES dataset to test NGM’s ability to induce an relatively simple schema from natural language text (Wikipedia) with only weak supervision (question-answer pairs), and correctly answer question from the constructed schema.
The WIKIMOVIES benchmark [21] consists of question-answer pairs in the domain of movies. It is designed to compare the performance of various knowledge sources. For this study we focus on the document QA setup, for which no predeﬁned schema is given, and the learning algorithm is required to form an internal representation of the knowledge expressed in Wikipedia text in order to answer questions correctly. It consists of 17k Wikipedia articles about movies. These questions are created ensuring that they are answerable from the Wikipedia pages. In total there are more than 100,000 questions which fall into 13 general classes. See Table 4 for an example document and related questions. Following previous work [21] we split the questions into disjoint training, development and test sets with 96k, 10k and 10k examples, respectively.
4.1 Text Representation
The WIKIMOVIES dataset comes with a list of entities (movie titles, dates, locations, persons, etc.), and we use Stanford CoreNLP [18] to annotate these entities in text. Following previous practices in semantic parsing [6, 16] we leverage the annotations, and replaced named entity tokens with their tags for LSTM encoders, which signiﬁcantly reduces the vocabulary size of LSTM models, and improves their generalization ability. Different than those of the bAbI tasks, the sentences in Wikipedia are generally very long, and their semantics cannot ﬁt into a single tuple. Therefore, following the practices in [21], instead of treating a full sentence as a text piece, we treat each annotated entity (we call it the anchor entity) plus a small window of 3 words in front of it as a text piece. We expect this small window to encode the relationship between the central entity (i.e. the movie title of the Wikipedia page) and the anchor entity. So we skip annotated entities in front of the anchor entity
4https://github.com/facebook/bAbI-tasks 5https://github.com/domluna/memn2n 6The crossover of the two lines is when the story length is around 1000, which is due to the difference in neural network architectures – NGM uses recurrent networks while MemN2N uses feed-forward networks.
6

Example document: Blade Runner Blade Runner is a 1982 American neo-noir dystopian science ﬁction ﬁlm directed by Ridley Scott and starring Harrison Ford, Rutger Hauer, Sean Young, and Edward James Olmos. The screenplay, written by Hampton Fancher and David Peoples, is a modiﬁed ﬁlm adaptation of the 1968 ... Example questions and answers Ridley Scott directed which ﬁlms? Gladiator, Alien, Prometheus, Blade Runner, ... (19 ﬁlms in total) What year was the movie Blade Runner released? 1982 What ﬁlms can be described by android? Blade Runner, A.I. Artiﬁcial Intelligence
Table 4: Example document and question-answer pairs from the WikiMovies task.

Annotated Text Windows(size=4): Blade Runner
is a [1982] DATE ﬁlm directed by [Ridley Scott] PERSON by and starring [Harrison Ford] PERSON ... and starring and [Edward James Olmos] PERSON screenplay written by [Hampton Fancher] PERSON written by and [David Peoples] PERSON Annotated Questions
[Ridley Scott] PERSON directed which ﬁlms What year was the movie [Blade Runner] MOVIE released What is movie written by [Hampton Fancher] PERSON

Knowledge Tuples [Blade Runner] when [1982] [Blade Runner] director [Ridley Scott] [Blade Runner] acted [Harrison Ford] ... [Blade Runner] acted [Edward James Olmos] [Blade Runner] writer [Hampton Fancher] [Blade Runner] writer [David Peoples] Programs Suff [Ridley Scott] director Pref [Blade Runner] when Suff [Hampton Fancher] writer

Table 5: Annotated document and questions (left), and corresponding knowledge tuples and programs generated by NGM (right). We always append the tagged movie title ([Blade Runner] MOVIE) to the left of text windows as context during LSTM encoding.

when creating the text windows. We also append the movie title as the context during encoding. Table 5 gives examples of the ﬁnal document and query representation after annotation and window creation.

4.2 Experiment Setup
Each training example (T, q, a) consists of T the ﬁrst paragraph of a movie Wikipedia page; a question q from the WIKIMOVIES for which its answer a appears in the paragraph 8. We applied the same staged training procedure as we did for the bAbI tasks, but use LSTMs with larger capacities (with 200 dimensions). 100 dimension GloVe embeddings [25] are used as the input layer. After training we apply knowledge encoder to all Wikipedia text with greedy decoding, and then aggregate all the ngrams into a single knowledge storage G∗. Then we apply programmer with G∗ to every test question and greedy decode a program to execute and calculate F1 measure using the expected answers.

Question Type

KB IE DOC NGM U.B.

Director To Movie Writer To Movie Actor To Movie Movie To Director Movie To Actors Movie To Writer Movie To Year

0.90 0.78 0.91 0.90 0.91 0.97 0.72 0.91 0.85 0.89 0.93 0.66 0.83 0.77 0.86 0.93 0.76 0.79 0.82 0.91 0.91 0.64 0.64 0.63 0.74 0.95 0.61 0.64 0.53 0.86 0.95 0.75 0.89 0.84 0.92

Avg (extractive)

0.93 0.80 0.70 0.76 0.87

Movie To Genre

0.97 0.84 0.86 0.72 0.75

Movie To Language 0.96 0.62 0.84 0.68 0.74

Movie To Tags

0.94 0.47 0.48 0.43 0.59

Tag To Movie

0.85 0.35 0.49 0.30 0.59

Movie To Ratings

0.94 0.75 0.92

-

-

Movie To Votes

0.92 0.92 0.92

-

-

Avg (non-extractive) 0.93 0.75 0.66 0.36 0.42

√

√

No schema design

√√

√

No data curation

√√

√

Scalable inference

4.3 Results
We compare NGM with other approaches with different knowledge representations [21]. KB is the least scal-

Table 6: Scalability and test accuracy on WikiMovie tasks.7U.B. is the recall upper bound for NGM, which
assumes that the answer appears in the relevant text, and
has been identiﬁed by certain named entity annotator.

7We calculate macro average, which is not weighted by the number of queries per type. 8To speedup training we only consider the ﬁrst answer of a question if there are multiple answers to this
question. E.g., only consider “Gladiator” for the question “Ridley Scott directed which ﬁlms?”

7

able approach among all–needing human to provide both the schema and the contents of the structured knowledge. IE is more scalable populating the contents of the structured knowledge, using information extractors pre-trained by human annotated examples. DOC represents end-to-end deep models, which do not require any supervision other than question answer pairs, but are not scalable at answering time, because of the differentiable knowledge representations.
Table 6 shows the performance of different approaches. We separate the questions into two categories. The ﬁrst category consists of questions which are extractive – assuming that the answer appears in the relevant Wikipedia text, and has been identiﬁed by Stanford CoreNLP9 named entity annotator. NGM performance is comparable to IE and DOC approaches, but there is still a gap from the KB approach. This is because the NGM learned schema might not be perfect – e.g., mixing writer and director as the same relation. The second category consists of questions which are not extractive (e.g., for IMDB rating or vote predictions, the answers never appear in the Wikipedia page.), or we don’t have a good entity annotator to identify potential answers. Here we implemented simple annotators for genre and language which have 59% and 74% coverage respectively. We don’t have a tag annotator, but the tags can be partially covered by other annotators such as language or genre. It remains as a challenging open question of how to expand NGM’s capability to deal with non-extractive questions, and deﬁne text pieces without good coverage entity annotators.
5 Related Work
Training highly expressive discrete latent variable models on large datasets is a challenging problem due to the difﬁculties posed by inference [12, 23]–speciﬁcally the huge variance in the gradient estimation. Mnih et al[23] applies REINFORCE [32] to optimize a variational lower-bound of the data log-likelihood, but relies on complex schemes to reduce variance in the gradient estimation. We use a different set of techniques to learn N-Gram Machines, which are simpler and with less model assumptions. Instead of Monte Carlo integration, which is known for high variance and low data efﬁciency, we apply beam search. Beam search is very effective for deterministic environments with sparse reward [16, 10], but it leads to a search problem. At inference time, since only a few top hypotheses are kept in the beam, search could get stuck and not receive any reward, preventing learning. We solve this hard search problem by having 1) a stabilized auto-encoding objective to bias the knowledge encoder to more interesting hypotheses; and 2) a structural tweak procedure which retrospectively corrects the inconsistency among multiple hypotheses so that reward can be achieved.
The question answering part of NGM our model (Figure 3) is similar to the Neural Symbolic Machine (NSM) [16], which is a memory enhanced sequence-to-sequence model that translates questions into programs in λ-calculus [17]. The programs, when executed on a knowledge graph, can produce answers to the questions. Our work extends NSM by removing the assumption of a given knowledge bases or schema, and instead learns to generate storage by end-to-end training to answer questions.
6 Conclusion
We present an end-to-end trainable system for efﬁciently answering questions from large corpus of text. The system combines an text auto-encoding component for encoding the meaning of text into symbolic representations, and a memory enhanced sequence-to-sequence component that translates questions into programs. We show that the method achieves good scaling properties and robust inference on syntactic and natural language text. The system we present here illustrates how a bottleneck in knowledge management and reasoning can be by alleviated by end-to-end learning of a symbolic knowledge storage.
References
[1] Gabor Angeli, Melvin Jose Johnson Premkumar, and Christopher D. Manning. Leveraging linguistic structure for open domain information extraction. In ACL (1), pages 344–354. The Association for Computer Linguistics, 2015.
[2] Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly learning to align and translate. arXiv preprint arXiv:1409.0473, 2014.
9https://stanfordnlp.github.io/CoreNLP/
8

[3] Steven Baker. Helping computers understand language. Ofﬁcial Google Blog, 2010.
[4] Sergey Brin and Lawrence Page. The anatomy of a large-scale hypertextual web search engine. Comput. Netw. ISDN Syst., 30(1-7):107–117, April 1998.
[5] Junyoung Chung, Caglar Gulcehre, KyungHyun Cho, and Yoshua Bengio. Empirical evaluation of gated recurrent neural networks on sequence modeling. arXiv preprint arXiv:1412.3555, 2014.
[6] Li Dong and Mirella Lapata. Language to logical form with neural attention. In Association for Computational Linguistics (ACL), 2016.
[7] Xin Dong, Evgeniy Gabrilovich, Geremy Heitz, Wilko Horn, Ni Lao, Kevin Murphy, Thomas Strohmann, Shaohua Sun, and Wei Zhang. Knowledge vault: A web-scale approach to probabilistic knowledge fusion. In Proceedings of the 20th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, KDD ’14, pages 601–610, New York, NY, USA, 2014. ACM.
[8] David A. Ferrucci, Eric W. Brown, Jennifer Chu-Carroll, James Fan, David Gondek, Aditya Kalyanpur, Adam Lally, J. William Murdock, Eric Nyberg, John M. Prager, Nico Schlaefer, and Christopher A. Welty. Building watson: An overview of the deepqa project. AI Magazine, 31(3):59–79, 2010.
[9] Jiatao Gu, Zhengdong Lu, Hang Li, and Victor OK Li. Incorporating copying mechanism in sequence-to-sequence learning. arXiv preprint arXiv:1603.06393, 2016.
[10] Kelvin Guu, Panupong Pasupat, Evan Zheran Liu, and Percy Liang. From language to programs: Bridging reinforcement learning and maximum marginal likelihood. In ACL (1), pages 1051– 1062. Association for Computational Linguistics, 2017.
[11] Felix Hill, Kyunghyun Cho, and Anna Korhonen. Learning distributed representations of sentences from unlabelled data. In Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages 1367–1377. Association for Computational Linguistics, 2016.
[12] Geoffrey E. Hinton, Simon Osindero, and Yee-Whye Teh. A fast learning algorithm for deep belief nets. Neural Comput., 18(7):1527–1554, July 2006.
[13] Robin Jia and Percy Liang. Data recombination for neural semantic parsing. In Association for Computational Linguistics (ACL), 2016.
[14] Diederik P. Kingma and Max Welling. Auto-encoding variational bayes. ICLR, 2014.
[15] Ni Lao, Tom Mitchell, and William W Cohen. Random walk inference and learning in a large scale knowledge base. In Proceedings of the Conference on Empirical Methods in Natural Language Processing, pages 529–539. Association for Computational Linguistics, 2011.
[16] Chen Liang, Jonathan Berant, Quoc Le, Kenneth D. Forbus, and Ni Lao. Neural symbolic machines: Learning semantic parsers on freebase with weak supervision. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 23–33, Vancouver, Canada, July 2017. Association for Computational Linguistics.
[17] P. Liang, M. I. Jordan, and D. Klein. Learning dependency-based compositional semantics. In Association for Computational Linguistics (ACL), pages 590–599, 2011.
[18] Christopher D. Manning, Mihai Surdeanu, John Bauer, Jenny Finkel, Steven J. Bethard, and David McClosky. The Stanford CoreNLP natural language processing toolkit. In Association for Computational Linguistics (ACL) System Demonstrations, pages 55–60, 2014.
[19] Yishu Miao and Phil Blunsom. Language as a latent variable: Discrete generative models for sentence compression. the 2016 Conference on Empirical Methods in Natural Language Processing (EMNLP), 2016.
[20] Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Corrado, and Jeff Dean. Distributed representations of words and phrases and their compositionality. In C. J. C. Burges, L. Bottou, M. Welling, Z. Ghahramani, and K. Q. Weinberger, editors, Advances in Neural Information Processing Systems 26, pages 3111–3119. Curran Associates, Inc., 2013.
[21] Alexander Miller, Adam Fisch, Jesse Dodge, Amir-Hossein Karimi, Antoine Bordes, and Jason Weston. Key-value memory networks for directly reading documents. arXiv preprint arXiv:1606.03126, 2016.
9

[22] Tom M. Mitchell, William W. Cohen, Estevam R. Hruschka Jr., Partha Pratim Talukdar, Justin Betteridge, Andrew Carlson, Bhavana Dalvi Mishra, Matthew Gardner, Bryan Kisiel, Jayant Krishnamurthy, Ni Lao, Kathryn Mazaitis, Thahir Mohamed, Ndapandula Nakashole, Emmanouil Antonios Platanios, Alan Ritter, Mehdi Samadi, Burr Settles, Richard C. Wang, Derry Tanti Wijaya, Abhinav Gupta, Xinlei Chen, Abulhair Saparov, Malcolm Greaves, and Joel Welling. Never-ending learning. In Proceedings of the Twenty-Ninth AAAI Conference on Artiﬁcial Intelligence, January 25-30, 2015, Austin, Texas, USA., pages 2302–2310, 2015.
[23] Andriy Mnih and Karol Gregor. Neural variational inference and learning in belief networks. In Proceedings of the 31st International Conference on International Conference on Machine Learning - Volume 32, ICML’14, pages II–1791–II–1799. JMLR.org, 2014.
[24] Arvind Neelakantan, Quoc V Le, and Ilya Sutskever. Neural programmer: Inducing latent programs with gradient descent. arXiv preprint arXiv:1511.04834, 2015.
[25] Jeffrey Pennington, Richard Socher, and Christopher D. Manning. Glove: Global vectors for word representation. In EMNLP, 2014.
[26] Tom Schaul, John Quan, Ioannis Antonoglou, and David Silver. Prioritized experience replay. In International Conference on Learning Representations, Puerto Rico, 2016.
[27] Sainbayar Sukhbaatar, Jason Weston, Rob Fergus, et al. End-to-end memory networks. In Advances in neural information processing systems, pages 2440–2448, 2015.
[28] Ilya Sutskever, Oriol Vinyals, and Quoc V Le. Sequence to sequence learning with neural networks. In Advances in neural information processing systems, pages 3104–3112, 2014.
[29] Oriol Vinyals, Meire Fortunato, and Navdeep Jaitly. Pointer networks. In Advances in Neural Information Processing Systems, pages 2692–2700, 2015.
[30] Jason Weston, Antoine Bordes, Sumit Chopra, Alexander M Rush, Bart van Merriënboer, Armand Joulin, and Tomas Mikolov. Towards ai-complete question answering: A set of prerequisite toy tasks. arXiv preprint arXiv:1502.05698, 2015.
[31] Jason Weston, Sumit Chopra, and Antoine Bordes. Memory networks. arXiv preprint arXiv:1410.3916, 2014.
[32] Ronald J Williams. Simple statistical gradient-following algorithms for connectionist reinforcement learning. Machine learning, 8(3-4):229–256, 1992.
10

A Supplementary Material

A.1 N-Gram Machines Details A.1.1 Model Structure Details Figure 3 shows the overall model structure of an n-gram machine.

Generate ( learning) Execute (no learning) Messages

Reward

Answer

Expected Answer

Variable Function Word
Knowledge Decoder
Reconstruction

Knowledge Storage
Knowledge Encoder

Executor

Code assist:
can be followed by or

Structure Tweak:

Can you change

to

?

Program Programmer

Reconstruction loss Story

Question

Figure 3: N-Gram Machine. The model contains two discrete hidden structures, the knowledge storage and the program, which are generated from the story and the question respectively. The executor executes programs against the knowledge storage to produce answers. The three learnable components, knowledge encoder, knowledge decoder, and programmer, are trained to maximize the answer accuracy as well as minimize the reconstruction loss of the story. Code assist and structure tweak help the knowledge encoder and programmer to communicate and cooperate with each other.

A.1.2 Optimization Details

The training objective function is

O(θ) = OAE (θenc, θdec) + OQA(θenc, θprog)

(6)

=

[β(gi) + P (gi|ti, ci; θenc)] log P (ti|gi, ci; θdec)

(7)

i gi

+

P (G|T ; θenc)P (p|q(j), G; θprog)R(G, p, a(j))

(8)

j Gp

where i is the index to text unit and j is the index to question answer pairs. β(gi) is 1 if gi only contains tokens from ti and 0 otherwise.

For training stability and to overcome search failures, we augment this objective with experience replay [26], and the gradients with respect to each set of parameters are:

∇θdec O (θ) =

[β(gi) + P (gi|ti, ci; θenc)]∇θdec log P (ti|gi, ci; θdec),

(9)

i gi

∇θenc O (θ) =

[P (gi|ti, ci; θenc) log P (ti|gi, ci; θdec)

(10)

i gi

+ R(G (gi)) + R(G(gi))]∇θenc log P (gi|ti, ci; θenc),

(11)

where

R(G) =

P (G|T ; θenc)P (p|q(j), G; θprog)R(G, p, a(j))

(12)

j G∈G p

11

is the total expected reward for a set of valid knowledge stores G, G(gi) is the set of knowledge stores which contain the tuple gi, and G (gi) is the set of knowledge stores which contains the tuple gi through tweaking.
∇θprog O (θ) = αI p ∈ B(j) + P (p|q(j), G; θprog) (13)
j Gp
· P (G|T ; θenc)R(G, p, a(j))∇θprog log P (p|q(j), G; θprog), (14)
where B(j) is the experience replay buffer for q(j). α = 0.1 is a constant. During training, the program with the highest weighted reward (i.e. P (G|T ; θenc)R(G, p, a(j))) is added to the replay buffer.
A.2 Details of bAbI Tasks
A.2.1 Details of auto-encoding and structured tweak
To illustrate the effect of auto-encoding, we show in Figure 4 how informative the knowledge tuples are by computing the reconstruction log-likelihood using the knowledge decoder for the sentence "john went back to the garden". As expected, the tuple (john went garden) is the most informative. Other informative tuples include (john the garden) and (john to garden). Therefore, with auto-encoding training, useful hypotheses have large chance to be found by a small knowledge encoder beam size (2 in our case).
Figure 4: Visualization of the knowledge decoder’s assessment of how informative the knowledge tuples are. Yellow means high and red means low.

Table 7 lists sampled knowledge storages learned with different objectives and procedures. Knowledge storages learned with auto-encoding are much more informative compared to the ones without. After structure tweaking, the knowledge tuples converge to use more consistent symbols – e.g., using went instead of back or travelled. Our experiment results show the tweaking procedure can help NGM to deal with various linguistic phenomenons such as singular/plural (“cats” vs “cat”) and synonyms (“grabbed” vs “got”). More examples are included in the supplementary material A.2.2.

Table 7: Sampled knowledge storage with question answering (QA) objective, auto-encoding (AE) objective, and structure tweak (ST) procedure. Using AE alone produces similar tuples to QA+AE. The differences between the second and the third column are underlined.

QA
went went went mary mary mary john john john mary mary mary there there there
cats cats cats mice mice mice is is cat

QA + AE
daniel went office mary back garden john back kitchen mary grabbed football sandra got apple
cats afraid wolves mice afraid wolves gertrude is cat

QA + AE + ST
daniel went office mary went garden john went kitchen mary got football sandra got apple
cat afraid wolves mouse afraid wolves gertrude is cat

A.2.2 Model generated knowledge storages and programs for bAbI tasks
The following tables show one example solution for each type of task. Only the tuple with the highest probability is shown for each sentence.

12

Table 8: Task 1 Single Supporting Fact

Story
Daniel travelled to the office. John moved to the bedroom. Sandra journeyed to the hallway. Mary travelled to the garden. John went back to the kitchen. Daniel went back to the hallway.
Question
Where is Daniel?

Knowledge Storage
Daniel went office John went bedroom Sandra went hallway Mary went garden John went kitchen Daniel went hallway
Program
PrefMax Daniel went

Table 9: Task 11 Basic Coreference

Story
John went to the bathroom. After that he went back to the hallway. Sandra journeyed to the bedroom After that she moved to the garden
Question
Where is Sandra?

Knowledge Storage
John went bathroom John he hallway Sandra Sandra bedroom Sandra she garden
Program
PrefMax Sandra she

Table 10: Task 15 Basic Deduction

Story
Sheep are afraid of cats. Cats are afraid of wolves. Jessica is a sheep. Mice are afraid of sheep. Wolves are afraid of mice. Emily is a sheep. Winona is a wolf. Gertrude is a mouse.
Question
What is Emily afraid of?

Knowledge Storage
Sheep afraid cats Cat afraid wolves Jessica is sheep Mouse afraid sheep Wolf afraid mice Emily is sheep Winona is wolf Gertrude is mouse
Program
Pref Emily is Pref V1 afraid

Table 11: Task 16 Basic Induction

Story
Berhard is a rhino. Lily is a swan. Julius is a swan. Lily is white. Greg is a rhino. Julius is white. Brian is a lion. Bernhard is gray. Brian is yellow.
Question
What color is Greg?

Knowledge Storage
Bernhard a rhino Lily a swan Julius a swan Lily is white Greg a rhino Julius is white Brian a lion Bernhard is gray Brian is yellow
Program
Pref Greg a Suff V1 a Pref V2 is

13

