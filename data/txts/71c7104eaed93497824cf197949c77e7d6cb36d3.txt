PullNet: Open Domain Question Answering with Iterative Retrieval on Knowledge Bases and Text
Haitian Sun Tania Bedrax-Weiss William W. Cohen Google AI Language
{haitiansun,tbedrax,wcohen}@google.com

arXiv:1904.09537v1 [cs.CL] 21 Apr 2019

Abstract
We consider open-domain queston answering (QA) where answers are drawn from either a corpus, a knowledge base (KB), or a combination of both of these. We focus on a setting in which a corpus is supplemented with a large but incomplete KB, and on questions that require non-trivial (e.g., “multi-hop”) reasoning. We describe PullNet, an integrated framework for (1) learning what to retrieve (from the KB and/or corpus) and (2) reasoning with this heterogeneous information to ﬁnd the best answer. PullNet uses an iterative process to construct a question-speciﬁc subgraph that contains information relevant to the question. In each iteration, a graph convolutional network (graph CNN) is used to identify subgraph nodes that should be expanded using retrieval (or “pull”) operations on the corpus and/or KB. After the subgraph is complete, a similar graph CNN is used to extract the answer from the subgraph. This retrieve-and-reason process allows us to answer multi-hop questions using large KBs and corpora. PullNet is weakly supervised, requiring question-answer pairs but not gold inference paths. Experimentally PullNet improves over the prior state-ofthe art, and in the setting where a corpus is used with incomplete KB these improvements are often dramatic. PullNet is also often superior to prior systems in a KB-only setting or a text-only setting.
1 Introduction
Open domain Question Answering (QA) is the task of ﬁnding answers to questions posed in natural language, usually using text from a corpus (Dhingra et al., 2017; Joshi et al., 2017; Dunn et al., 2017), or triples from a knowledge base (KB) (Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Yih et al., 2015). Both of these approaches have limitations. Even the largest KBs are incomplete (Min et al., 2013), which limits

recall of a KB-based QA system. On the other hand, while a large corpus may contain more answers than a KB, the diversity of natural language makes corpus-based QA difﬁcult (Chen et al., 2017; Welbl et al., 2018; Kwiatkowski et al., 2019; Yang et al., 2018).
In this paper we follow previous research (Sawant et al., 2019; Sun et al., 2018) in deriving answers using both a corpus and a KB. We focus on tasks in which questions require compositional (sometimes called “multi-hop”) reasoning, and a setting in which the KB is incomplete, and hence must be supplemented with information extracted from text. We also restrict ourselves in this paper to answers which correspond to KB entities. For this setting, we propose an integrated framework for (1) learning what to retrieve, from either a corpus, a KB, or a combination, and (2) combining this heterogeneous information into a single data structure that allows the system to reason and ﬁnd the best answer. In prior work, this approach was termed an early fusion approach, and shown to improve over late fusion methods, in which two QA systems, one corpus-based and one KB-based, are combined in an ensemble.
The system we describe, PullNet, builds on the GRAFT-Net1 early fusion system. GRAFT-Net uses heuristics to build a question-speciﬁc subgraph which contains sentences from the corpus, entities from the KB, and facts from the KB. A graph CNN (Kipf and Welling, 2016; Li et al., 2016; Schlichtkrull et al., 2017) variant is then used to reason over this graph and select an answer. However, as we will show experimentally, GRAFT-Net’s heuristics often produce subgraphs that far from optimal: they are generally much larger than necessary, and often do not contain the answer at all.
1Graphs of Relations Among Facts and Text Networks.

PullNet also uses a reasoning process based on a graph CNN to ﬁnd answers. However, PullNet learns how to construct the subgraph, rather than using an ad hoc subgraph-building strategy. More speciﬁcally, PullNet relies on a small set of retrieval operations, each of which takes a node in an existing subgraph, and then expand the node by retrieving new information from the KB or the corpus. PullNet learns when and where to apply these “pull” operations with another graph CNN classiﬁer. The “pull” classiﬁer is weakly supervised , using question-answer pairs for supervision.
The end result is a learned iterative process for subgraph construction, which begins with a small subgraph containing only the question text and the entities which it contains, and gradually expands the subgraph to contain information from the KB and corpus that are likely to be useful. The incremental question-guided subgraph construction process results in high-recall subgraphs that are much smaller than the ones created heuristically, making the ﬁnal answer extraction process easier. The process is especially effective for multi-hop questions, which naively would require expanding the subgraph to include all corpus and KB elements that are k hops away from the question.
PullNet improves over the current state-ofthe-art for KB-only QA on several benchmark datasets, and is superior to, or competitive with, corpus-only QA on several others. For multi-hop questions, this improvement is often dramatic: for instance, MetaQA (Zhang et al., 2018) contains multi-hop questions based on a small movie KB, originally associated with the WikiMovies dataset (Miller et al., 2016). In a KB-only setting, PullNet improves hits-at-one performance for 3-hop MetaQA questions from 62.5% to 91.4%. Perhaps more interestingly, PullNet obtains performance of 85.2% hits-at-one with a KB from which half of the triples have been removed, if that KB is supplemented with a corpus. We note that this result improves by 7% (absolute improvement) over a pure corpus-based QA system, and by more than 25% over a pure KB-based QA system. In a similar incomplete-KB setting, PullNet improves over GRAFTNet by 6.8% on the ComplexWebQuestions dataset (Talmor and Berant, 2018).
2 Related Work
This paper has focused on QA for multi-hop questions using large KBs and text corpora as the

information sources from which answers can be drawn. The main technical contribution is an iterative question-guided retrieval mechanism that retrieves information from KBs, corpora, or combinations of both. The iterative retrieval makes it possible to follow long paths of reasoning on large KBs, and as we show below, this leads to new state-of-the art results on two datasets of this sort. The hybrid KB/text retrieval, and the ability to reason over combinations of text and KBs, lets us extend these results to settings where only text is available, and to settings where text and an incomplete KB is available. These contributions are based on much prior work.
A long line of QA models have been developed which answer questions based on a single passage of text (Dhingra et al., 2016; Yu et al., 2018; Seo et al., 2016; Gao et al., 2018; Liu et al., 2017; Devlin et al., 2018). Generally, these “reading comprehension” systems operate by encoding the passage and question into an embedding space, and due to memory limitations cannot be applied to a large corpus instead of a short passage. To address this limitation a number of systems have been designed which use a “retrieve and read” pipeline (Chen et al., 2017; Dhingra et al., 2017; Joshi et al., 2017; Dunn et al., 2017; Wang et al., 2018, 2017), in which a retrieval system with high recall is piped into a reading comprehension system that can ﬁnd the answer. An alternative approach is “phrase-indexed” QA (Seo et al., 2018), where embedded phrases in a document are indexed and searched over. Such systems differ from PullNet in that only a single round of retrieval is used; however, for questions that requires multi-hop reasoning, we believe is difﬁcult for a single retrieval step to ﬁnd the relevant information. These systems are also not able to use both KB and text for QA.
SplitQA (Talmor and Berant, 2018) is a textbased QA system that cam decompose complex questions (e.g. conjunction, composition) into simple subquestions, and perform retrieval on them sequentially. Although it uses iterative retrieval for multi-hop questions, unlike PullNet, SplitQA does not also use a KB as an information source. Also, since SplitQA has been applied only to the Complex WebQuestions dataset, it is unclear how general its question decomposition methods are.
There has also been much work on QA from

KBs alone, often using methods based on memory networks (Sukhbaatar et al., 2015), semantic parsing (Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005) or reinforcement learning Das et al. (2017a). Extending such KB-based work to also use text, however, is non-trivial. In (Das et al., 2017b) one approach for a hybrid text-based and KB-based QA system is described, where keyvalue memory networks are used to store text as well as KB facts encoded with a universal schema representation (Riedel et al., 2013). We use a similar method as one of our baselines, following (Sun et al., 2018). Another line of QA work from text and KBs is exempliﬁed by AQQU (Bast and Haussmann, 2015) and its successors (Sawant et al., 2019). These systems focus on questions that, like the questions in the SimpleWebQuestions dataset, can be interpreted as identifying an entity based on a relationship and related entity, plus (potentially) additional restrictions described in text, and it is unclear how to extend such approaches to multi-hop questions.
GRAFT-Net (Sun et al., 2018) supports multihop reasoning on both KBs and text by introducing a question subgraph built with facts and text, and uses a learned graph representation (Kipf and Welling, 2016; Li et al., 2016; Schlichtkrull et al., 2017; Scarselli et al., 2009) to perform the “reasoning” required to select the answer. We use the same representation and reasoning scheme as GRAFT-Net, but do not require that the entire graph be retrieved in a single step. In our experimental comparisons, this gives signiﬁcant performance gains for multi-hop reasoning tasks.
Combinations of KBs and text have also been used for relation extraction and Knowledge Base Completion (KBC) (Lao et al., 2012; Toutanova et al., 2015; Das et al., 2017a). The QA task differs from KBC in that in QA, the inference process must be conditioned on a natural-language question, which leads to different constraints on which methods can be used.
3 The PullNet Model
PullNet retrieves from two “knowledge sources”, a text corpus and a KB. Given a question, PullNet will use these to construct a question subgraph that can be used to answer the question. The question subgraph is constructed iteratively. Initially the subgraph depends only on the question. PullNet then iteratively expands the subgraph by choos-

ing nodes from which to “pull” information about, from the KB or corpus as appropriate. The question subgraph is heterogeneous, and contains both entities, KB triples, and entity-linked text.
In this section, we will ﬁrst introduce notation deﬁning the heterogeneous graph structure we use. Then we will introduce the general iterative retrieval process. Finally, we will discuss the retrieval operations used on the corpus and KB, and the classiﬁcation operations on the graph which determine where to perform the retrievals.
3.1 The Question Subgraph
A question subgraph for question q, denoted Gq = {V, E}, is a hetogeneous graph that contains information from both the text corpus and the KB relevant to q. Let V denote the set of vertices, which we also call nodes. Following GRAFT-Net (Sun et al., 2018), there are three types of nodes: entity nodes Ve, text nodes Vd, and fact nodes Vf , with V = Ve∪Vd∪Vf . A entity node ve ∈ Ve represents an entity from the knowledge base. A text node vd ∈ Vd represents a document from the corpus, with a sequence of tokens denoted (w1, . . . , w|d|). In this paper, a document is always a single sentence, to which an entity linker (Ji et al., 2014) has been applied to detect and ground entity mentions. A fact node vf ∈ Vf represents a triplet (vs, r, vo) from the KB, with subject and objects vs, vo ∈ Ve and relation r. We let E denote the set of edges between nodes. An edge connects a fact node vf and an entity node ve exists iff fact vf has ve as its subject or object. An edge connects a text node vd with entity node ve iff the entity is mentioned in the text.
3.2 Iterative subgraph expansion and classiﬁcation
3.2.1 Overview
We start with a question subgraph Gq0 = {V0, E0} where V0 = {eqi} is the list of entities mentioned in the question and E0 is an empty set. We iteratively expand the question subgraph Gq0 until it contains the information required to answer the question.
The algorithm is shown in Alg 1. Brieﬂy, we expand the graph in T iterations. In each iteration, we choose k entities to expand, and then for each selected entity, we retrieve a set of related documents, and also a set of related facts. The new documents are then passed through an entity-linking

system to identify entities that occur in them, and the head and tail entities of each fact will also be extracted. The last stage in the iteration is to update the question graph by adding all these new edges. After the t-th iteration of expansion, an additional classiﬁcation step is applied to the ﬁnal question subgraph which predicts the answer entity.

Algorithm 1 PullNet

1: Initialize question graph G0q with question q and question entities, with V0 = {eqi } and E0 = ∅.
2: for t = 1, · · · , T do
3: Classify and select the entity nodes in the graph with
probability larger than {vei } = classify pullnodes(Gtq, k)

4: for all ve in {vei } do

5:

Perform pull operation on selected entity nodes

{vdi } = pull docs(ve, q) {vfi } = pull facts(ve, q)

6:

for all vd in {vdi } do

7:

Extracted entities in new document nodes

{ve(d)i } = pull entities(vd)

8:

for all vf in {vfi } do

9:

Extract head and tail of new fact nodes

{ve(f)i } = pull headtail(vf )

10: Add new nodes and edges to question graph Gtq+1 = update(Gtq)

11: Select entity node in ﬁnal graph that is the best answer vans = classify answer(GTq )

We will now describe the operations used in Alg 1.
3.2.2 Pull Operations
Pull operations either retrieve information from a knowledge source, or extract entities from a fact or document.
The two extraction operations are relatively simple. The pull entities(vd) operation inputs a document node vd, calls an entity linker and returns all entities mentioned in vd. The pull headtail(vf ) operation inputs a fact node vf and returns the subject and object entity of fact vf .
The retrieval operations are more complex. The pull docs(ve, q)) operation retrieves relevant documents from the corpus. We use an IDF-based retrieval system, Lucene (McCandless et al., 2010) and assume that all sentences have been entitylinked prior to being indexed. The retrieved documents are constrained to link to entity ve, and are ranked by their IDF similarity to the question q.

Only the top Nd documents in this ranking are returned.
The pull facts(ve, q) operation retrieves the top Nf facts from the KB about entity ve. The retrieved facts are constrained to have ve as their subject or object, and are ranked based on the similarity S(r, q) between the fact’s relation r and the question q. Since it is not obvious how to assess relevance of a fact to a question q, we learn a S(r, q) as follows. Let hr be an embedding of relation r, which is looked up from an embedding table, and let q = (w1, . . . , w|q|) be the sequence of words for question q. Similarity is deﬁned as the dot-product of the last-state LSTM representation for q with the embedding for r. This dot-product is then passed through a sigmoid function to bring it into a range of [0, 1]: as we explain below, we will train this similarity function as a classiﬁer which predicts which retrieved facts are relevant to the question q. The ﬁnal ranking method for facts is thus
hq = LSTM(w1, . . . , w|q|) ∈ Rn S(r, q) = sigmoid(hTr hq)
3.2.3 Classify Operations
Two types of classify operations are applied to the nodes in a subgraph Gtq. These operations are applied only to the entity nodes in the graph, but they are based on node representations computed by the graph CNN, so the non-entity nodes and edges also affect the classiﬁcation results.
During subgraph construction, the classify pullnodes(Gtq) operation returns a probability an entity node ve should be expanded in the next iteration. In subgraph construction, we choose the k nodes with the highest probability in each iteration. After the subgraph is complete, the classify answer(Gtq) operation predicts whether an entity node answers the question. The highest-scoring entity node is returned as the ﬁnal answer.
We use the same CNN architecture used by GRAFT-Net (Sun et al., 2018) for classiﬁcation. GRAFT-Net’s source is open-domain and it supports node classiﬁcation on heterogeneous graphs containing facts, entities, and documents. GraftNet differs from other graph CNN implementations, in using special mechanisms to distribute representations across different types of nodes and edges: notably, document nodes are represented with LSTM encodings, extended by mechanisms

that allow the representations for entity nodes ve to be passed into a document vd that mentions ve, and mechanisms that allow the LSTM hidden states associated with an entity mention to be passed out of vd to the associated entity node ve.
3.2.4 The Update Operation
The update operation takes the question subgraph Gtq−1 from the previous iteration and updates it by adding the newly retrieved entity nodes {ve(f)i } ∪ {ve(d)i }, the text nodes {vdi }, and the fact nodes {vfi}. It also updates the set of edges E based on the deﬁnitions of Section 3.1. Note that some new edges are derived when pull operations are performed on text nodes and fact node, but other new edges may connect newly-added nodes with nodes that already exist in the previous subgraph.
3.3 Training
To train PullNet, we assume that we only observe question and answer pairs, i.e., the actual inference chain required to answer the question is latent. We thus need to use weak supervision to train the classiﬁers and similarity scores described above.
To train these models, we form an approximation of the ideal question subgraph for question q as follows. Note that in training, the answer entities are available. We use these to ﬁnd all shortest paths in the KB between the question entities and answer entities. Each entity e that appears in such a shortest path will be marked as a candidate intermediate entities. For each candidate intermediate entity e we record its minimal distance te from the question nodes.
When we train the classify pullnodes classiﬁer in iteration t, we treat as positive examples only those entities e that are connected to a candidate intermediate entity e with distance et = t+1. Likewise in training the similarity function S(hr, q) we treat as positive relations leading to candidate intermediate entities e at distance et = t + 1. This encourages the retrieval to focus on nodes that lie on shortest paths to an answer.
In training we use a variant of teacher forcing. When training, we pull from all entity nodes with a predicted score larger than some threshold , rather than only the top k nodes. If, during training, a candidate intermediate entity is not retrieved in iteration te, we add it to the graph anyway. The values T and are hyperparameters, but here we

always pick for T , the number of retrieval steps, maximum length of the inference chain needed to ensure full coverage of the answers.
We use the same classiﬁer on the graph in the retrieval step as in answer selection, except that we change last fully-connected layer. The classiﬁers used for retrieval in the different iterations are identical.
The learned parts of the model are implemented in PyTorch, using an ADAM optimizer (Kingma and Ba, 2014), and the full retrieval process of Alg 1 is performed on each minibatch.
4 Experiments and Results
4.1 Datasets
MetaQA (Zhang et al., 2018) consists of more than 400k single and multi-hop (up to 3-hop) questions in the domain of movies. The questions were constructed using the knowledge base provided by the WikiMovies (Miller et al., 2016) dataset. We use the “vanilla” version of the queries: for this version, the 1-hop questions in MetaQA are exactly the same as WikiMovies. We use the KB and text corpus that are supplied with the WikiMovies dataset (Miller et al., 2016), and run use a simple exact match on surface forms to perform entity linking. The KB used here is relatively small, with about 43k entities and 135k triples. WebQuestionsSP (Yih et al., 2015) contains 4737 natural language questions that are answerable using Freebase2. The questions require up to 2-hop reasoning from knowledge base, and 1-hop reasoning using the corpus. We use Freebase as our knowledge base but for ease of experimentation restrict it to a subset of Freebase which contains all facts that are within 2-hops of any entity mentioned in the questions of WebQuestionsSP. This smaller KB contains 164.6 million facts and 24.9 million entities. We use Wikipedia as our text corpus and again use a simple entity-linker: we link entities by exact matching to any surface form annotated in FACC1 project (Gabrilovich et al., 2013).3 Complex WebQuestions 1.1 (Complex WebQ) (Talmor and Berant, 2018) is generated from WebQuestionsSP by extending the question entities or adding constraints to answers, in order to construct
2We use the same train/dev/test splits as GRAFT-Net (Sun et al., 2018).
3If two overlapping spans are possible matches, we match only the longer of them.

more complex multi-hop questions4. There are four types of question: composition (45%), conjunction (45%), comparative (5%), and superlative (5%). The questions require up to 4-hops of reasoning on knowledge base and 2-hops on the corpus. We use the same KB and corpus as used for WebQuestionsSP.

MetaQA 1-hop MetaQA 2-hop MetaQA 3-hop WebQuestionsSP Complex WebQ

Train 96,106 118,980 114,196 2,848 27,623

Dev 9,992 14,872 14,274 250 3,518

Test 9,947 14,872 14,274 1,639 3,531

Table 1: Statistics of all datasets.

4.2 Tasks
We explored several different QA settings: KB only (complete), corpus only, incomplete KB only, and incomplete KB paired with the corpus.
In the KB only complete setting, the answer always exists in knowledge base: for all of these datasets, this is true because the questions were crowd-sourced to enforce this conditions. This is the easiest setting for QA, but arguably unrealistic, since with a more natural distribution of questions, a KB is likely to be incomplete. Note that PullNet can be used in this setting by simply removing the pull docs operation.
In the text only setting we use only the corpus. Again, PullNet can operate in this setting by removing the pull facts operation.
In the incomplete KB setting, we simulate KBbased QA on anincomplete KB by randomly discarding some of the triples in the KB: speciﬁcally, we randomly drop a fact from the knowledge base with probability p = 50%.
In the incomplete KB plus text setting, we pair the same incomplete knowledge base with the corpus. In principle this allows a learned QA system to adopt many different hybrid strategies. For simple 1-hop queries, a model might use the KB when the required fact exists, and “back off” to text when the KB is missing information. In multihop or conjunctive queries, the reasoning done in answering the question might involve combining inferences done with text and inferences done with KB triples.
4We use Complex WebQuestions v1.1, where the author re-partition the train/dev/test data to prevent the leakage of information.

Comment. One point to note is that our training procedure is based on ﬁnding shortest paths in a complete KB, and we use this same procedure on the incomplete KB setting as well. Thus the weak training that we use should, in the incompleteKB settings, be viewed as a form of weak supervision, with labels that are intermediate in informativeness between pure distant training (with only question-answer pairs) and gold inference paths (a setting that has been extensively investigated on some of these datasets, in particular WebQuestionsSP).
4.3 Baselines
We choose Key-Value Memory Network (Miller et al., 2016) and GRAFT-Net (Sun et al., 2018) as our baseline models: to the best of our knowledge, these are the only ones that can use both text and KBs for question answering. However, both models are limited in the number of facts and text that can ﬁt into memory. Thus, we create a separate retrieval process as a pre-processing step, which will be discussed below.
Key-Value Memory Network (KVMem) (Miller et al., 2016) maintains a memory table which stores KB facts and text encoded into key-value pairs. The encoding of KB facts is the same as is presented in Miller et al. (2016). For text, we use an bi-directional LSTM to encode the text for the key and take the entities mentioned in the text as values. Our implementation shows comparable performance on the WikiMovies (MetaQA 1-hop) datasets as reported previously, as shown in Table 2.
For GRAFT-Net (Sun et al., 2018), we use the implementation published by the author5; however, we run it on somewhat different data as described in Section 4.4.
4.4 Subgraph Retrieval for Baseline Models
Text was retrieved (non-iteratively) using the IDFbased similarity to the question. It is less obvious how to perform KB retrieval: we would like to retrieve as many facts as possible to maximize the recall of answers, but it is infeasible to take all facts that are within k-hop away from question entities since the number grows exponentially, and there is no widely-used heuristic, corresponding to IDF-based text retrieval, for extracting subsets of
5https://github.com/OceanskySun/ GraftNet

MetaQA (1-hop) / wikimovies

MetaQA (2-hop)

MetaQA (3-hop)

50% 50% KB

50% 50%KB

50% 50% KB

KB Text KB + Text KB Text KB + Text KB Text KB + Text

KV-Mem*

96.2 75.4 63.6 75.7 82.7 7.0 41.8 48.4 48.9 19.5 37.6 35.2

GraftNet*

97.0 82.5 64

91.5 94.8 36.2 52.6 69.5 77.7 40.2 59.2 66.4

PullNet (Ours) 97.0 84.4 65.1 92.4 99.9 81.0 52.1 90.4 91.4 78.2 59.7 85.2

KV-Mem

93.9 76.2 –

–

–

–

–

–

–

–

–

–

GraftNet

96.8 86.6 68.0 92.6

–

–

–

–

–

–

–

–

VRN

97.5 –

–

–

89.9 –

–

–

62.5 –

–

–

Table 2: Hits@1 on MetaQA compared to baseline models. Number below the double line are from original papers: KV-Mem (KB) (Miller et al., 2016), KV-Mem (Text) (Watanabe et al., 2017), GraftNet (Sun et al., 2018), and VRN (Zhang et al., 2018). * Reimplemented or different data.

a KB. We elected to ﬁrst run the PageRank-Nibble algorithm (Andersen et al., 2006) with = 1e−6 and pick the top m entities. PageRank-Nibble efﬁciently approximates a personalized PageRank (aka random walk with reset) seeded from the questions (not the answers, which are of course not available at test time). We then ﬁnd all entities from these top m entities that are within k-hops of the question entities. Finally, we collect all facts from the knowledge base that connect any pair of the retrieved entities. This allows us to easily vary the number of KB facts that are retrieved.
The retrieval results are shown in Table 3 and 4. For the smaller MetaQA KB, the proposed retrieval method ﬁnds high-coverage graphs. For ComplexWebQuestions, the recall is only 64%, even with a graph with nearly 2000 nodes: this is expected, since retrieving the relevant entities for a multi-hop question from a KB with millions of entities is a difﬁcult task.

1-hop 2-hop 3-hop

wikimovies-KB 0.995 / 9.17 0.983 / 47.3 0.923 / 459.2

wikimovies-KB (50%) 0.544 / 4.58 0.344 / 28.6 0.522 / 316.6

Table 3: Retrieval performance for baseline retrieval model on MetaQA with 500 PageRank-Nibble entities (recall / # entities in graph)

ble to the state-of-the-art6. For the other three settings, the performance of our re-implementation is slightly worse than the results reported in by original GRAFT-Net paper (Sun et al., 2018); this is likely because we use a simpler retrieval module.
In the KB-only setting, PullNet shows a large improvement over the baseline models on 2-hop and 3-hop questions. For the text only setting, PullNet also improves on the baselines, and other prior models, by a large margin. Finally, PullNet also shows signiﬁcant improvements over baselines in the text and incomplete-KB-plus-text settings. We also see that PullNet is able to effectively combine KB and text information, as this setting also greatly outperforms the incomplete KB alone or the text alone.7
4.5.2 WebQuestionsSP
Table 5 presents the results on the WebQuestionsSP dataset. PullNet is comparable with GRAFTNet on the complete KB only setting and slightly worse on the text only setting, but is consistently better than GRAFT-Net on the incomplete KB setting or the incomplete KB plus text setting. It is also signiﬁcantly better than the reimplemented GRAFT-Net, which uses the less highly-engineered retrieval module.

WebQuestionsSP Complex WebQ

Freebase 0.927 / 1876.9 0.644 / 1948.7

Freebase (50%) 0.485 / 1212.5 0.542 / 1849.2

Table 4: Retrieval performance for baseline retrieval model on WebQuestionsSP and Complex WebQuestions with 2000 PageRank-Nibble entities (recall / # entities in graph)

4.5 Main Results
4.5.1 MetaQA The experimental results for MetaQA are shown in Table 2. For 1-hop questions in MetaQA (which is identical to WikiMovies), our model is compara-

4.5.3 Complex WebQuestions
Complex WebQuestions contains multi-hop questions against FreeBase: intuitively, one would expect that single-shot retrieval of facts and text would not be able to always ﬁnd efﬁcient information to answer such questions. Table 6 shows
66.7% questions in Wikimovies are ambiguous, e.g. questions about movies with remakes without specifying years.
7Another way to perform QA in the incomplete KB plus text setting would be to ensemble two QA systems, one which uses the incomplete KB, and one which uses the text. Although we do not make that comparison here, prior work (Sun et al., 2018) did show that GRAFT-Net outperforms such “late fusion” approaches.

KV-Mem* GraftNet* PullNet (Ours)
GraftNet NSM

WebQuestionsSP

50% 50% KB

KB

Text KB + Text

46.7 23.2 32.7 31.6 66.4 24.9 48.2 49.7 68.1 24.8 50.3 51.9

67.8 25.3 47.7 49.9

69.0 (F1) –

–

–

Table 5: Hits@1 on WebQuestionsSP compared to baseline models. Number below the double line are from original papers: GraftNet (Sun et al., 2018), and NSM (Liang et al., 2017) (which only reports F1 in their paper). * Reimplemented or different data.

our results for Complex WebQuestions on the development set. An expected, PullNet shows signiﬁcant improvement over GRAFT-Net and KVMem on all four settings. Once again we see some improvement when pairing the incomplete knowledge base with text, compared to using the incomplete knowledge base only or the text only.

KV-Mem* GraftNet* PullNet (Ours)

Complex WebQuestions (dev) 50% 50% KB
KB Text KB + Text 21.1 7.4 14.8 15.2 32.8 10.6 26.1 26.9 47.2 13.1 31.5 33.7

Table 6: Hits@1 on Complex WebQuestions (dev) compared to baseline models. * Reimplemented or different data.

SplitQA PullNet

Complex WebQuestions (test)

GoogleSnippet Wikipedia Freebase

34.2

–

–

29.7

13.8

45.9

Table 7: Hits@1 on Complex WebQuestions (test).
Researchers are only allowed limited submissions on the Complex WebQuestions test set, however, some results for the test set are shown in Table 7. Results with the text-only (Wikipedia) setting are comparable to the dev set results (13.8% instead of 13.1%) as are results with the KB-only setting (45.9% instead of 47.2%).
For completeness, we also compare to SplitQA (Talmor and Berant, 2018). SplitQA takes a multihop question and decomposes it into several simple sub-questions, and sends each of these to subquestions to the Google search engine. After that, it applies a reading comprehension model to gather information from the web snippets returned by Google to ﬁnd answers. Using this same collection of Google snippets as the corpus, our model has 4.5% lower hists-at-one than SplitQA. However, the snippet corpus is arguably biased toward

the SplitQA model, since it was collected specifically to support it. We also note unlike SplitQA, PullNet relies only on open-source components and corpora. 4.6 Further Results 4.6.1 Retrieval Performance of PullNet We compare the retrieval performance of PullNet and PageRank-Nibble on multi-hop questions with a complete KB, varying the number of entities retrieved by PageRank-Nibble. The results in Figure 1 show that PullNet retrieves far fewer entities but obtains higher recall.
Figure 1: Recall of graphs retrieved by PageRankNibble compared with PullNet. Left: MetaQA (3-hop). Right: Complex WebQuestions.
We also further explored the effectiveness of iterative retrieval for multi-hop questions on a text corpus. The results are shown in Figure 2. Again, PullNet with multiple iterations of retrieval, obtains higher recall than a single iteration of IDFbased retrieval on both the MetaQA (3-hop) and the Complex WebQuestions dataset.
Figure 2: Recall of a single round of retrieval with Apache Lucene compared with PullNet. Left: MetaQA (3-hop). Right: Complex WebQuestions.

Figure 3 shows the recall of question subgraphs on MetaQA (3-hop) questions as training proceeds. Performance of the retrieval components of PullNet converges relatively quickly, with recall saturating after 10-20,000 examples (about 10-20% of a single epoch).

about 3 epochs for PullNet.

Figure 4: Performance of PullNet and GRAFT-Net under wall clock training time.

Figure 3: Recall of question subgraph on MetaQA 3hop questions.
4.6.2 Training Efﬁciency
We also analyze the training efﬁciency of PullNet. PullNet’s algorithm is quite different from prior systems, since learning and retrieval are interleaved: in most prior systems, including GRAFTNet, retrieval is performed only once, before learning. Intuitively, interleaving learning with the relatively slow operation of retrieval is potentially slower; on the other hand, PullNet’s ﬁnal question subgraph is smaller than GRAFT-Net, which makes learning potentially faster.
To study these issues, we plot the Hits@1 performance of learned model versus wall clock time in Figure 4. This experiment is run on Complex WebQuestions in the KB-only setting, using one high-end GPU. To be fair to GRAFT-Net, we used a fast in-memory implementation of PageRankNibble (based on SciPy sparse matrices), which takes about 40 minutes to complete. GRAFT-Net takes an average of 31.9 minutes per epoch, while PullNet is around four times slower, taking an average of 114 minutes per epoch.
As the graph shows, initially PullNet’s performance is better, since GRAFT-Net cannot start learning until the preprocessing ﬁnishes. GRAFTNet’s faster learning speed then allows it to dominates for some time. GRAFT-Net reaches its peak performance in about 3.6 hours. PullNet passes GRAFT-Net in hits-at-one after around 6 hours, or

5 Conclusions
PullNet is a novel integrated QA framework for (1) learning what to retrieve from a KB and/or corpus and (2) reasoning with this heterogeneous to ﬁnd the best answer. Unlike prior work, PullNet uses an iterative process to construct a question-speciﬁc subgraph that contains information relevant to the question. In each iteration, a graph-CNN is used to identify subgraph nodes that should be expanded using retrieval (or “pull”) operations on the corpus and/or KB. This iterative process makes it possible to retrieve a small graph that contains just the information relevant to a multi-hop question—a task that is in general difﬁcult.
Experimentally PullNet improves over the prior state-of-the art for the setting in which questions are answered with a corpus plus an incomplete KB, or in settings in which questions need complex ”multi-hop” reasoning. Sometimes the performance improvements are dramatic: e.g., an improvement from 62.5% hits-at-one to 91.4% hitsat-one for 3-hop MetaQa with a KB, or improvements from 32.8% to 47.2% for Complex WebQuestions with a KB.
References
Reid Andersen, Fan Chung, and Kevin Lang. 2006. Local graph partitioning using pagerank vectors. In 2006 47th Annual IEEE Symposium on Foundations of Computer Science (FOCS’06), pages 475–486. IEEE.
Hannah Bast and Elmar Haussmann. 2015. More accurate question answering on freebase. In Proceedings of the 24th ACM International on Conference

on Information and Knowledge Management, pages 1431–1440. ACM.
Danqi Chen, Adam Fisch, Jason Weston, and Antoine Bordes. 2017. Reading Wikipedia to answer opendomain questions. In Association for Computational Linguistics (ACL).
Rajarshi Das, Shehzaad Dhuliawala, Manzil Zaheer, Luke Vilnis, Ishan Durugkar, Akshay Krishnamurthy, Alex Smola, and Andrew McCallum. 2017a. Go for a walk and arrive at the answer: Reasoning over paths in knowledge bases using reinforcement learning. arXiv preprint arXiv:1711.05851.
Rajarshi Das, Manzil Zaheer, Siva Reddy, and Andrew McCallum. 2017b. Question answering on knowledge bases and text using universal schema and memory networks. CoRR, abs/1704.08384.
Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2018. Bert: Pre-training of deep bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805.
Bhuwan Dhingra, Hanxiao Liu, Zhilin Yang, William W Cohen, and Ruslan Salakhutdinov. 2016. Gated-attention readers for text comprehension. arXiv preprint arXiv:1606.01549.
Bhuwan Dhingra, Kathryn Mazaitis, and William W Cohen. 2017. Quasar: Datasets for question answering by search and reading. arXiv preprint arXiv:1707.03904.
Matthew Dunn, Levent Sagun, Mike Higgins, V Ugur Guney, Volkan Cirik, and Kyunghyun Cho. 2017. Searchqa: A new q&a dataset augmented with context from a search engine. arXiv preprint arXiv:1704.05179.
Evgeniy Gabrilovich, Michael Ringgaard, and Amarnag Subramanya. 2013. Facc1: Freebase annotation of clueweb corpora, version 1 (release date 2013-0626, format version 1, correction level 0).
Mingfei Gao, Ruichi Yu, Ang Li, Vlad I Morariu, and Larry S Davis. 2018. Dynamic zoom-in network for fast object detection in large images. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 6926–6935.
Heng Ji, Joel Nothman, Ben Hachey, et al. 2014. Overview of tac-kbp2014 entity discovery and linking tasks. In Proc. Text Analysis Conference (TAC2014), pages 1333–1339.
Mandar Joshi, Eunsol Choi, Daniel S. Weld, and Luke Zettlemoyer. 2017. Triviaqa: A large scale distantly supervised challenge dataset for reading comprehension. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, Vancouver, Canada. Association for Computational Linguistics.

Diederik P Kingma and Jimmy Ba. 2014. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980.
Thomas N Kipf and Max Welling. 2016. Semisupervised classiﬁcation with graph convolutional networks. arXiv preprint arXiv:1609.02907.
Tom Kwiatkowski, Jennimaria Palomaki, Olivia Redﬁeld, Michael Collins, Ankur Parikh, Chris Alberti, Danielle Epstein, Illia Polosukhin, Matthew Kelcey, Jacob Devlin, Kenton Lee, Kristina N. Toutanova, Llion Jones, Ming-Wei Chang, Andrew Dai, Jakob Uszkoreit, Quoc Le, and Slav Petrov. 2019. Natural questions: a benchmark for question answering research. Transactions of the Association of Computational Linguistics.
Ni Lao, Amarnag Subramanya, Fernando Pereira, and William W Cohen. 2012. Reading the web with learned syntactic-semantic inference rules. In Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pages 1017–1026. Association for Computational Linguistics.
Yujia Li, Daniel Tarlow, Marc Brockschmidt, and Richard Zemel. 2016. Gated graph sequence neural networks. ICLR.
Chen Liang, Jonathan Berant, Quoc Le, Kenneth D Forbus, and Ni Lao. 2017. Neural symbolic machines: Learning semantic parsers on freebase with weak supervision. ACL.
Rui Liu, Wei Wei, Weiguang Mao, and Maria Chikina. 2017. Phase conductor on multi-layered attentions for machine comprehension. arXiv preprint arXiv:1710.10504.
Michael McCandless, Erik Hatcher, and Otis Gospodnetic. 2010. Lucene in action: covers Apache Lucene 3.0. Manning Publications Co.
Alexander Miller, Adam Fisch, Jesse Dodge, AmirHossein Karimi, Antoine Bordes, and Jason Weston. 2016. Key-value memory networks for directly reading documents. EMNLP.
Bonan Min, Ralph Grishman, Li Wan, Chang Wang, and David Gondek. 2013. Distant supervision for relation extraction with an incomplete knowledge base. In NAACL HLT 2013 - 2013 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Proceedings of the Main Conference, pages 777–782. Association for Computational Linguistics (ACL).
Sebastian Riedel, Limin Yao, Andrew McCallum, and Benjamin M Marlin. 2013. Relation extraction with matrix factorization and universal schemas. In Proceedings of the 2013 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages 74–84.

Uma Sawant, Saurabh Garg, Soumen Chakrabarti, and Ganesh Ramakrishnan. 2019. Neural architecture for question answering using a knowledge graph and web corpus. Information Retrieval Journal, pages 1–26.
Franco Scarselli, Marco Gori, Ah Chung Tsoi, Markus Hagenbuchner, and Gabriele Monfardini. 2009. The graph neural network model. IEEE Transactions on Neural Networks, 20(1):61–80.
Michael Schlichtkrull, Thomas N Kipf, Peter Bloem, Rianne van den Berg, Ivan Titov, and Max Welling. 2017. Modeling relational data with graph convolutional networks. arXiv preprint arXiv:1703.06103.
Minjoon Seo, Aniruddha Kembhavi, Ali Farhadi, and Hannaneh Hajishirzi. 2016. Bidirectional attention ﬂow for machine comprehension. arXiv preprint arXiv:1611.01603.
Minjoon Seo, Tom Kwiatkowski, Ankur Parikh, Ali Farhadi, and Hannaneh Hajishirzi. 2018. Phraseindexed question answering: A new challenge for scalable document comprehension. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 559–564.
Sainbayar Sukhbaatar, Arthur Szlam, Jason Weston, and Rob Fergus. 2015. End-to-end memory networks. In NIPS.
Haitian Sun, Bhuwan Dhingra, Manzil Zaheer, Kathryn Mazaitis, Ruslan Salakhutdinov, and William W Cohen. 2018. Open domain question answering using early fusion of knowledge bases and text. EMNLP.
A. Talmor and J. Berant. 2018. The web as a knowledge-base for answering complex questions. In North American Association for Computational Linguistics (NAACL).
Kristina Toutanova, Danqi Chen, Patrick Pantel, Hoifung Poon, Pallavi Choudhury, and Michael Gamon. 2015. Representing text for joint embedding of text and knowledge bases. In Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing, pages 1499–1509.
Shuohang Wang, Mo Yu, Xiaoxiao Guo, Zhiguo Wang, Tim Klinger, Wei Zhang, Shiyu Chang, Gerry Tesauro, Bowen Zhou, and Jing Jiang. 2018. R 3: Reinforced ranker-reader for open-domain question answering. In Thirty-Second AAAI Conference on Artiﬁcial Intelligence.
Shuohang Wang, Mo Yu, Jing Jiang, Wei Zhang, Xiaoxiao Guo, Shiyu Chang, Zhiguo Wang, Tim Klinger, Gerald Tesauro, and Murray Campbell. 2017. Evidence aggregation for answer reranking in open-domain question answering. CoRR, abs/1711.05116.
Yusuke Watanabe, Bhuwan Dhingra, and Ruslan Salakhutdinov. 2017. Question answering from unstructured text by retrieval and comprehension. arXiv preprint arXiv:1703.08885.

Johannes Welbl, Pontus Stenetorp, and Sebastian Riedel. 2018. Constructing datasets for multi-hop reading comprehension across documents. Transactions of the Association of Computational Linguistics, 6:287–302.
Zhilin Yang, Peng Qi, Saizheng Zhang, Yoshua Bengio, William Cohen, Ruslan Salakhutdinov, and Christopher D Manning. 2018. Hotpotqa: A dataset for diverse, explainable multi-hop question answering. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 2369–2380.
Wen-tau Yih, Ming-Wei Chang, Xiaodong He, and Jianfeng Gao. 2015. Semantic parsing via staged query graph generation: Question answering with knowledge base. In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers), pages 1321–1331, Beijing, China. Association for Computational Linguistics.
Adams Wei Yu, David Dohan, Minh-Thang Luong, Rui Zhao, Kai Chen, Mohammad Norouzi, and Quoc V Le. 2018. Qanet: Combining local convolution with global self-attention for reading comprehension. arXiv preprint arXiv:1804.09541.
John M Zelle and Raymond J Mooney. 1996. Learning to parse database queries using inductive logic programming. In Proceedings of the Thirteenth National conference on Artiﬁcial intelligence-Volume 2, pages 1050–1055. AAAI Press.
Luke S Zettlemoyer and Michael Collins. 2005. Learning to map sentences to logical form: structured classiﬁcation with probabilistic categorial grammars. In Proceedings of the Twenty-First Conference on Uncertainty in Artiﬁcial Intelligence, pages 658–666. AUAI Press.
Yuyu Zhang, Hanjun Dai, Zornitsa Kozareva, Alexander J Smola, and Le Song. 2018. Variational reasoning for question answering with knowledge graph. In AAAI.

