arXiv:2102.07847v1 [cs.CL] 15 Feb 2021

Published as a conference paper at ICLR 2021
META BACK-TRANSLATION
Hieu Pham∗,1,2, Xinyi Wang∗,1, Yiming Yang1, Graham Neubig1
∗Equal contributions 1Language Technology Institute, Carnegie Mellon University, Pittsburgh, PA 15213 2Google AI, Brain Team, Mountain View, CA 94043 {hyhieu,xinyiw1,yiming,gneubig}@cmu.edu
ABSTRACT
Back-translation (Sennrich et al., 2016) is an effective strategy to improve the performance of Neural Machine Translation (NMT) by generating pseudo-parallel data. However, several recent works have found that better translation quality of the pseudo-parallel data does not necessarily lead to better ﬁnal translation models, while lower-quality but more diverse data often yields stronger results (Edunov et al., 2018). In this paper, we propose a novel method to generate pseudo-parallel data from a pre-trained back-translation model. Our method is a meta-learning algorithm which adapts a pre-trained back-translation model so that the pseudoparallel data it generates would train a forward-translation model to do well on a validation set. In our evaluations in both the standard datasets WMT En-De’14 and WMT En-Fr’14, as well as a multilingual translation setting, our method leads to signiﬁcant improvements over strong baselines.1
1 INTRODUCTION
While Neural Machine Translation (NMT) delivers state-of-the-art performance across many translation tasks, this performance is usually contingent on the existence of large amounts of training data (Sutskever et al., 2014; Vaswani et al., 2017). Since large parallel training datasets are often unavailable for many languages and domains, various methods have been developed to leverage abundant monolingual corpora (Gulcehre et al., 2015; Cheng et al., 2016; Sennrich et al., 2016; Xia et al., 2016; Hoang et al., 2018; Song et al., 2019; He et al., 2020). Among such methods, one particularly popular approach is back-translation (BT; Sennrich et al. (2016)). In BT, in order to train a source-to-target translation model, i.e., the forward model, one ﬁrst trains a target-to-source translation model, i.e., the backward model. This backward model is then employed to translate monolingual data from the target language into the source language, resulting in a pseudoparallel corpus. This pseudo-parallel corpus is then combined with the real parallel corpus to train the ﬁnal forward model. While the resulting forward model from BT typically enjoys a signiﬁcant boost in translation quality, we identify that BT inherently carries two weaknesses. First, while the backward model provides a natural way to utilize monolingual data in the target language, the backward model itself is still trained on the parallel corpus. This means that the backward model’s quality is as limited as that of a forward model trained in the vanilla setting. Hoang et al. (2018) proposed iterative BT to avoid this weakness, but this technique requires multiple rounds of retraining models in both directions which are slow and expensive. Second, we do not understand how the pseudo-parallel data translated by the backward model affects the forward model’s performance. For example, Edunov et al. (2018) have observed that pseudoparallel data generated by sampling or by beam-searching with noise from the backward model train better forward models, even though these generation methods typically result in lower BLEU scores
1Code repository: https://github.com/google-research/google-research/tree/ master/meta_back_translation.
1

Published as a conference paper at ICLR 2021

Monolingual Target Data Wie geht es dir haute?

Backward model

Pseudo Parallel Data samples How are you today?

Forward model (t-1)

Wie geht es dir haute?

update backward model gradient
Forward model (t)

Ground Truth Parallel Data How are you?
Wie geht es dir?

Cross Entropy
Loss

Figure 1: An example training step of meta back-translation to train a forward model translating English (En) into German (De). The step consists of two phases, illustrated from left to right in the ﬁgure. Phase 1: a backward model translates a De sentence taken from a monolingual corpus into a pseudo En sentence, and the forward model updates its parameters by back-propagating from canonical training losses on the pair (pseudo En, mono De). Phase 2: the updated forward model computes a cross-entropy loss on a pair of ground truth sentences (real En, real De). As annotated with the red path in the ﬁgure, this cross-entropy loss depends on the backward model, and hence can be back-propagated to update the backward model. Best viewed in colors.

compared to standard beam search. While Edunov et al. (2018) associated their observation to the diversity of the generated pseudo-parallel data, diversity alone is obviously insufﬁcient – some degree of quality is necessary as well.
In summary, while BT is an important technique, training a good backward model for BT is either hard or slow and expensive, and even if we have a good backward model, there is no single recipe how to use it to train a good forward model.
In this paper, we propose a novel technique to alleviate both aforementioned weaknesses of BT. Unlike vanilla BT, which keeps the trained backward model ﬁxed and merely uses it to generate pseudoparallel data to train the forward model, we continue to update the backward model throughout the forward model’s training. Speciﬁcally, we update the backward model to improve the forward model’s performance on a held-out set of ground truth parallel data. We provide an illustrative example of our method in Fig. 1, where we highlight how the forward model’s held-out set performance depends on the pseudo-parallel data sampled from the backward model. This dependency allows us to mathematically derive an end-to-end update rule to continue training the backward model throughout the forward model’s training. As our derivation technique is similar to meta-learning (Schmidhuber, 1992; Finn et al., 2017), we name our method Meta Back-Translation (MetaBT).
In theory, MetaBT effectively resolves both aforementioned weaknesses of vanilla BT. First, the backward model continues its training based on its own generated pseudo-parallel data, and hence is no longer limited to the available parallel data. Furthermore, MetaBT only trains one backward model and then trains one pair of forward and backward models, eschewing the expense of the multiple iterations in Iterative BT (Hoang et al., 2018). Second, since MetaBT updates its backward model in an end-to-end manner based on the forward model’s performance on a held-out set, MetaBT no longer needs to explicitly understand the effect of its generated pseudo-parallel data on the forward model’s quality.
Our empirical experiments verify the theoretical advantages of MetaBT with deﬁnitive improvements over strong BT baselines on various settings. In particular, on the classical benchmark of WMT En-De 2014, MetaBT leads to +1.66 BLEU score over sampling-based BT. Additionally, we discover that MetaBT allows us to extend the initial parallel training set of the backward model by including parallel data from slightly different languages. Since MetaBT continues to reﬁne the backward model, the negative effect of language discrepancy is eventually mitigated throughout the forward model’s training, improving by up to +1.20 BLEU score for low-resource translation tasks.
2 A PROBABILISTIC PERSPECTIVE OF BACK-TRANSLATION
To facilitate the discussion of MetaBT, we introduce a probabilistic framework to interpret BT. Our framework helps to analyze the advantages and disadvantages of a few methods to generate pseudo-parallel data such as sampling, beam-searching, and beam-searching with noise (Sennrich et al., 2016; Edunov et al., 2018). Analyses of these generation methods within our framework also motivates MetaBT and further allows us to mathematically derive MetaBT’s update rules in § 3.
Our Probabilistic Framework. We treat a language S as a probability distribution over all possible sequences of tokens. Formally, we denote by PS(x) the distribution of a random variable x, where each corresponding instance x is a sequence of tokens. To translate from a source language S into a
2

Published as a conference paper at ICLR 2021

target language T , we learn the conditional distribution PS,T (y|x) for sentences from the languages S and T with a parameterized probabilistic model P (y|x; θ). Ideally, we learn θ by minimizing the
objective:

J (θ) = Ex,y∼PS,T (x,y)[ (x, y; θ)] where (x, y; θ) = −logP (y|x; θ)

(1)

Since PS,T (x, y) = PS,T (y)PS,T (x|y) = PT (y)PS,T (x|y), we can refactor J (θ) from Eq. 1 as:

J (θ) = Ey∼PT (y)Ex∼PS,T (x|y)[ (x, y; θ)]

(2)

Motivating BT. In BT, since it is not feasible to draw exact samples y ∼ PT (y) and x ∼ PS,T (x|y), we rely on two approximations. First, instead of sampling y ∼ PT (y), we collect a corpus DT of monolingual data in the target language T and draw the samples y ∼ Uniform(DT ). Second, instead
of sampling x ∼ PS,T (x|y), we derive an approximate distribution P (x|y) and sample x ∼ P (x|y).
Before we explain the derivation of P (x|y), let us state that with these approximations, the objective J(θ) from Eq. 2 becomes the following BT objective:

JBT(θ) = Ey∼Uniform(DT )Ex∼P (x|y)[ (x, y; θ)]

(3)

Rather unsurprisingly, P (x|y) in Eq. 3 above is derived from a pre-trained parameterized backward translation model P (x|y; ψ). For example:

• P (x|y) = 1[x = argmaxx˙ P (x˙ |y; ψ)] results in BT via beam-search (Sennrich et al., 2016). • P (x|y) = P (x|y; ψ) results in BT via sampling (Edunov et al., 2018).
• P (x|y) = 1[x = argmaxx˙ P (x˙ |y; ψ)] results in BT via noisy beam-search (Edunov et al., 2018) where P (x|y; ψ) denotes the joint distribution of the backward model P (x|y; ψ) and the noise.

Therefore, we have shown that in our probabilistic framework for BT, three common techniques to
generate pseudo-parallel data from a pre-trained backward model correspond to different derivations from the backward model’s distribution P (x|y; ψ). Our framework naturally motivates two questions about these generation techniques. First, given a translation task, how do we tell which derivation
of P (x|y) from P (x|y, ψ) is better than another? Second, can we derive better choices for P (x|y) from a pre-trained backward model P (x|y; ψ) according to the answer of the ﬁrst question?

Metric for the Generation Methods. In the existing literature, the answer for our ﬁrst question is relatively straightforward. Since most papers view the method of generating pseudo-parallel data as a design decision, i.e., similar to an architecture choice like Transformer or LSTM, practitioners choose one method over another based on the performance of the resulting forward model on held-out validation sets.

Automatically Deriving Good Generation Methods. We now turn to the second question that our probabilistic framework motivates. Thanks to the generality of our framework, every choice for P (x|y) in Eq. 3 results in an optimization objective. Using this objective, we can train a forward model and measure its validation performance to evaluate our choice of P (x|y). This process of choosing and evaluating P (x|y) can be posed as the following bi-level optimization problem:
Outer loop: P ∗ = argmax ValidPerformance(θ∗ ),
P P
Inner loop: θP∗ = argmin JBT(θ; P ), (4)
θ
where JBT(θ; P ) = Ey∼Uniform(DT )Ex∼P (x|y)[ (x, y; θ)]
The optimal solution of this bi-level optimization problem can potentially train a forward model that generalizes well, as the forward model learns on a pseudo-parallel dataset and yet achieves a good performance on a held-out validation set. Unfortunately, directly solving this optimization problem is not feasible. Not only is the inner loop quite expensive as it includes training a forward model from scratch according to P , the outer loop is also poorly deﬁned as we do not have any restriction on the space that P can take. Next, in § 3, we introduce a restriction on permissible P , and show that our restriction turns the task of choosing P into a differentiable problem that can be solved with gradient descent.

3

Published as a conference paper at ICLR 2021

3 META BACK-TRANSLATION

Continuing our discussion from § 2, we design Meta Back-Translation (MetaBT), which ﬁnds a strategy to generate pseudo-parallel data from a pre-trained backward model such that if a forward model is trained on the generated pseudo-parallel data, it will achieve strong performance on a held-out validation set.

The Usage of “Validation” Data. Throughout this section, readers will see that MetaBT makes extensive use of the “validation” set to provide feedback to reﬁne the pseudo-parallel data’s generating strategy. Thus, to avoid nullifying the meaning of a held-out validation set, we henceforth refer to the ground-truth parallel dataset where the forward model’s performance is measured throughout its training as the meta validation dataset and denote it by DMetaDev. Other than this meta validation set, we also have a separate validation set for hyper-parameter tuning and model selection.

A Differentiable Bi-level Optimization Problem. We now discuss MetaBT, starting with formulating a differentiable version of Problem 4. Suppose we have pre-trained a paramterized backward translation model P (x|y; ψ). Instead of designing the distribution P (x|y) by applying actions such
as sampling or beam-search to P (x|y; ψ), we let P (x|y) = P (x|y; ψ) and continue to update the backward model’s parameters ψ throughout the course of training the forward model. Thus, the parameters ψ control the generation distribution of the pseudo-parallel data used to train the forward model. By setting the differentiable parameters ψ as the optimization variable for the outer loop, we turn the intractable Problem 4 into a differentiable one:
Outer loop: ψ∗ = argmax Performance(θ∗(ψ), DMetaDev) ψ (5)
Inner loop: θ∗(ψ) = argmin Ey∼Uniform(DT )Ex∼P (x|y)[ (x, y; θ)]
θ

Bi-level optimization problems where both outer and inner loops operate on differentiable variables like Problem 5 have appeared repeatedly in the recent literature of meta-learning, spanning many areas such as learning initialization (Finn et al., 2017), learning hyper-parameters (Baydin et al., 2018), designing architectures (Liu et al., 2019), and reweighting examples (Wang et al., 2020a). We thus follow the successful techniques used therein and design a two-phase alternative update rule for the forward model’s parameters θ in the inner loop and the backward model’s parameters ψ in the outer loop:

Phase 1: Update the Forward Parameters θ. Given a batch of monolingual target data y ∼

Uniform(DT ), we sample the pseudo-parallel data (x ∼ P (x|y; ψ), y) and update θ as if (x, y) was

real data. For simplicity, assuming that θ is updated using gradient descent on (x, y), using a learning

rate ηθ, then we have:

θt = θt−1 − ηθ∇θ (x, y; θ)

(6)

Phase 2: Update the Backward Parameters ψ. Note that Eq. 6 means that θt depends on ψ, because x is sampled from a distribution parameterized by ψ. This dependency allows us to compute
the meta validation loss of the forward model at θt, which we denote by J(θt(ψ), DMetaDev), and back-propagate this loss to compute the gradient ∇ψJ(θt(ψ), DMetaDev). Once we have this gradient, we can perform a gradient-based update on the backward parameters ψ with learning rate ηψ:

ψt = ψt−1 − ηψ∇ψ∇θJ (θt(ψ), DMetaDev)

(7)

Computing ∇ψJ(θt(ψ), DMetaDev). Our derivation of this gradient utilizes two techniques: (1) the chain rule to differentiate J(θt(ψ), DMetaDev) with respect to ψ via θt; and (2) the log-gradient trick from reinforcement learning literature (Williams, 1992) to propagate gradients through the sampling
of pseudo-source x. We refer readers to § A.1 for the full derivation. Here, we present the ﬁnal result:

∇ψJ (θt(ψ), DMetaDev) ≈ − ∇θJ (θt, DMetaDev) · ∇θ (x, y; θt−1) · ∇ψlogP (x|y; ψ) (8)
In our implementation, we leverage the recent advances in high-order AutoGrad tools to efﬁciently compute the gradient dot-product term via Jacobian-vector products. By alternating the update rules in Eq. 6 and Eq. 7, we have the complete MetaBT algorithm.

4

Published as a conference paper at ICLR 2021

Remark: An Alternative Interpretation of MetaBT. The update rule of the backward model in Eq. 8 strongly resembles the REINFORCE equation from the reinforcement learning literature. This similarity suggests that the backward model is trained as if it were an agent in reinforcement learning. From this perspective, the backward model is trained so that the pseudo-parallel data sampled from it would maximize the “reward”:

R(x) = ∇θJ (θt, DMetaDev) · ∇θ (x, y; θt−1)

(9)

Since this dot-product measures the similarity in directions of the two gradients, it can be interpreted as saying that MetaBT optimizes the backward model so that the forward model’s gradient on pseudoparallel data sampled from the backward model is similar to the forward model’s gradient computed on the meta validation set. This is a desirable goal because the reward guides the backward model’s parameters to favor samples that are similar to those in the meta validation set.

4 A MULLTILINGUAL APPLICATION OF METABT
We ﬁnd that the previous interpretation of MetaBT in Section 3 leads to a rather unexpected application MetaBT. Speciﬁcally, we consider the situation where the language pair of interest S-T has very limited parallel training data. In such a situation, BT approaches all suffer from a serious disadvantage: since the backward model needs to be trained on the parallel data T -S, when the amount of parallel data is small, the resulting backward model has very low quality. The pseudo-parallel corpus generated from the low-quality backward model can contaminate the training signals of the forward model (Currey et al., 2017).
To compensate for the lack of initial parallel data to train the backward model, we propose to use parallel data from a related language S -T for which we can collect substantially more data. Speciﬁcally, we train the backward model on the union of parallel data T -S and T -S, instead of only T -S. Since this procedure results in a substantially larger set of parallel training data, the obtained backward model has a higher quality. However, since the extra S -T parallel data dominates the training set of the backward model, the pseudo source sentences sampled from the resulting backward model would have more features of the related language S , rather than our language of interest S.
In principle, MetaBT can ﬁx this discrepancy by adapting the backward model using the forward model’s gradient on the meta validation set that only contains parallel data for S-T . This would move the back-translated pseudo source sentences closer to our language of interest S.

5 EXPERIMENTS
We evaluate MetaBT in two settings: (1) a standard back-translation setting to verify that MetaBT can create more effective training data for the forward model, and (2) a multilingual NMT setting to conﬁrm that MetaBT is also effective when the backward model is pre-trained on a related language pair as discussed in § 4.
5.1 DATASET AND PREPROCESSING
Standard For the standard setting, we consider two large datasets: WMT En-De 2014 and WMT En-Fr 20142, tokenized with SentencePiece (Kudo & Richardson, 2018) using a joint vocabulary size of 32K for each dataset. We ﬁlter all training datasets, keeping only sentence pairs where both source and target have no more than 200 tokenized subwords, resulting in a parallel training corpus of 4.5M sentence pairs for WMT En-De and 40.8M sentences for WMT En-Fr. For the target monolingual data, we collect 250M sentences in German and 61 million sentences in French, both from the WMT news datasets between 2007 and 2017. After de-duplication, we ﬁlter out the sentences that have more than 200 subwords, resulting in 220M German sentences and 60M French sentences.
Multilingual The multilingual setting uses the multilingual TED talk dataset (Qi et al., 2018), which contains parallel data from 58 languages to English. We focus on translating 4 low-resource languages to English: Azerbaijani (az), Belarusian (be), Glacian (gl), Slovak (sk). Each low-resource
2Data link: http://www.statmt.org/wmt14/

5

Published as a conference paper at ICLR 2021
language is paired with a corresponding related high-resource language: Turkish (tr), Russian (ru), Portuguese (pt), Czech (cs). We following the setting from prior work (Neubig & Hu, 2018; Wang et al., 2019) and use SentencePiece with a separate vocabulary of 8K for each language.
5.2 BASELINES
Our ﬁrst baseline is No BT, where we train all systems using parallel data only. For the standard setting, we simply train the NMT model on the WMT parallel data. For the multilingual setting, we train the model on the concatenation of the parallel training data from both the low-resource language and the high-resource language. The No BT baseline helps to verify the correctness of our model implementations. For the BT baselines, we consider two strong candidates:
• MLE: we sample the pseudo source sentences from a ﬁxed backward model trained with MLE. This baseline is the same with sampling-based BT (Edunov et al., 2018). We choose sampling instead of beam-search and beam-search with noise as Edunov et al. (2018) found sampling to be stronger than beam-search and on par with noisy beam-search. Our data usage, as speciﬁed in § 5.1, is also the same with Edunov et al. (2018) on WMT. We call this baseline MLE to signify the fact that the backward model is trained with MLE and then is kept ﬁxed throughout the course of the forward model’s learning.
• DualNMT (Xia et al., 2016): this baseline further improves the quality of the backward model using reinforcement learning with a reward that combines the language model score and the reconstruction score from the forward model.
Note that for the multilingual setting, we use top-10 sampling, which we ﬁnd has better performance than sampling from the whole vocabulary in the preliminary experiments.
5.3 IMPLEMENTATION
We use the Transformer-Base architecture (Vaswani et al., 2017) for all forward and backward models in our experiments’ NMT models. All hyper-parameters can be found in § A.2. We choose Transformer-Base instead of Transformer-Large because MetaBT requires storing in memory both the forward model and the backward model, as well as the two-step gradients for meta-learning, which together exceeds our 16G of accelerator memory when we try running Transformer-Large. We further discuss this in § 7.
For the standard setup, we pre-train the backward model on the WMT parallel corpora. In the meta-learning phases that we described in § 3, we initialize the parameters ψ0 using this pre-trained checkpoint. From this checkpoint, at each training step, our forward model is updated using two sources of data: (1) a batch from the parallel training data, and (2) a batch of sentences from the monolingual data, and their source sentences are sampled by the backward model.
For the multilingual setup, we pre-train the backward model on the reverse direction of the parallel data from both the low-resource and the high-resource languages. From this checkpoint, at each meta-learning step, the forward model receives two sources of data: (1) a batch of the parallel data from the low-resource language. (2) a batch of the target English data from the high-resource language, which are fed into the BT model to sample the pseudo-source data.
5.4 RESULTS
We report the BLEU scores (Papineni et al., 2002) for all models and settings in Tab. 1. From the table, we observe that the most consistent baseline is MLE, which signiﬁcantly improves over the No BT baseline. Meanwhile, DualNMT’s performance is much weaker, losing to MLE on all tasks except for az-en where its margin is only +0.19 BLEU compared to No BT. For WMT En-Fr, we even observe that DualNMT often results in numerical instability before reaching 34 BLEU score and thus we do not report the result. By comparing the baselines’ performance, we can see that continuing to train the backward model to outperform MLE is a challenging mission.
Nonetheless, MetaBT consistently outperforms all baselines in both settings. In particular, compared to the best baselines, MetaBT’s gain is up to +1.20 BLEU in the low-resource multilingual setting, and is +1.66 BLEU for WMT En-De 14. Note that WMT En-De 14 is a relatively widely-used
6

Published as a conference paper at ICLR 2021

BT Model Objective
No BT MLE (Edunov et al., 2018) DualNMT (Xia et al., 2016) Meta Back-Translation

az-en
11.50 11.30 11.69 11.92∗

Multilingual be-en gl-en

17.00 17.40 14.81
18.10∗

28.44 29.10 25.30
30.30∗

sk-en
28.19 28.70 27.07 29.00∗

Standard en-de en-fr

26.49 28.73 25.71
30.39∗

38.56 39.77
−
40.28∗

Table 1: BLEU scores of MetaBT and of our baselines in the standard bilingual setting and the multilingual setting. ∗ indicates statistically signiﬁcant improvements with p < 0.001. Our tests follow (Clark et al., 2011).

benchmark for NMT and that a gain of +1.66 BLEU on this benchmark is considered relatively large. While the gain of MetaBT over MLE on WMT En-Fr is somewhat smaller (+0.51 BLEU), our statistical test shows that the gain is still signiﬁcant. Therefore, our experimental results conﬁrm the theoretical advantages of MetaBTare borne out in practice. Next, in § 5.5, we investigate the behavior of MetaBT to further understand how the method controls the generation process of pseudo-parallel data.
Comparison with Unsupervised NMT (UNMT; Artetxe et al. (2018)). Since the Unsupervised NMT (UNMT) method also utilizes monolingual data to train a pair of forward and backward translation models, we also compare it with MetaBT. We experimented with UNMT on the the WMT En-De 14 benchmark, using the same parallel and monolingual data as we used for MetaBT. Under this setting, UNMT attains a BLEU score of 28.76, which is in the same ballpark SampleBT’s BLEU score 28.73. We also found that on our hardware, even with a proper batching schedule, UNMT’s step time was about 1.4 times slower than MetaBT. We suspect this is because each step of UNMT has many rounds of translation and optimization: 2 rounds of back-translation, 2 rounds of denoising, and 1 round of supervised training. On the other hand, each step in MetaBT has only two rounds of translation.
5.5 ANALYSIS

Prob. of BT Samples
Train PPL Dev BLEU

0.0085 0.0080 0.0075 0.0070

MLE MBT

Figure 2: Probability of pseudo-parallel from the forward model for WMT’14 En-Fr. MetaBT produces less diverse data to ﬁt the model better.

27.5

7

MLE

MBT

25.0

6

22.5

5

20.0

MLE

4

17.5

MBT

Figure 3: Training PPL and Validation BLEU for WMT En-De throughout the forward model’s training. MetaBT leads to consistently higher validation BLEU by generating pseudo-parallel data that avoids overﬁtting for the forwarwd model, evident by a higher training PPL.

MetaBT Flexibly Avoids both Overﬁtting and Underﬁtting. We demonstrate two constrasting behaviors of MetaBT in Fig. 2 and Fig. 3. In Fig. 2, MetaBT generates pseudo-parallel data for the forward model to learn in WMT En-Fr. Since WMT En-Fr is large (40.8 million parallel sentences), the Transformer-Base forward model underﬁts. By “observing” the forward model’s underﬁtting, perhaps via low meta validation performance, the backward model generates pseudo-parallel data that the forward model assigns a high probability, hence reducing the difﬁcult learning for the forward model. In contrast, Fig. 3 shows that for WMT En-De, the pseudo-parallel data generated by the backward model leads to a higher training loss for the forward model. Since WMT En-De has only 4.5 million parallel sentences which is about 10x smaller than WMT En-Fr, we suspect that MetaBT generates harder pseudo-parallel data for the backward model to avoid overﬁtting. In both cases, we have no explicit control over the behaviors of MetaBT, and hence we suspect that MetaBT can appropriately adjusts its behavior depending on the forward model’s learning state.
7

Published as a conference paper at ICLR 2021

LRL Vocab Overlap

az 0.595 0.590 0.585 0.580 0.575
0123456789

be 0.49 0.48 0.47 0.46
0123456789

gl 0.90

MLE MBT sk
0.755

0.85

0.750

0.80 0.75
0123456789

0.745 0.740 0 1 2 3 4 5 6 7 8 9

Figure 4: Percentage of words in the pseudo source sentences that are in the low-resource vocabulary throughout training. MetaBT learns to favor the sentences that are more similar to the data from the low-resource language.

MetaBT Samples Pseudo-Parallel Data Closer to the Meta Validation Set. After showing that MetaBT can affect the forward model’s training in opposite, but appropriate, ways, we now show that MetaBT also can generate pseudo-parallel data that are close to the meta validation data. Note that this is the expected behavior of MetaBT, since the ultimate objective is for the forward model to perform well on this meta validation set. We focus on the multilingual setting because this setting highlights the vast difference between the parallel data and the meta validation data. In particular, recall from § 4 that in order to translate a low-resource language S into language T , we use extra data from a language S which is related to S but which has abundant parallel data S -T . Meanwhile, the meta validation set only consists of parallel sentences in S-T .
In Fig. 4, we group the sampled sentences throughout the forward model’s training into 10 bins based on the training steps that they are generated, and plot the percentage of words in the pseudo source sentences that are from the vocabulary of S for each bin. As seen from the ﬁgure, MetaBT keeps increasing the vocabulary coverage throughout training, indicating that it favors the sentences that are more similar to the meta validation data, which are from the low-resource language S.

Src
Ref
MLE MBT

As the town ’ s contribution to the 150th anniversary of the Protestant Church in Haigerloch , the town ’ s Ofﬁce of Culture and Tourism is to dedicate the last of this year ’ s public thematic tours on Sunday 27 October to the Abendsmahlskirche ( Church of the Holy Communion ) .
Als Beitrag der Stadt zum 150 - jährigen Bestehend der Evangelischen Kirche in Haigerloch widmet das Kultur - und Tourismusbüro der Stadt die letzte ihrer diesjährigen öffentlichen Themenführungen am Sonntag , 27 . Oktober , der Abendmahlskirche .
Als Beitrag der Stadt zum 150.
Als Beitrag der Stadt zum 150 - jährigen Bestehen der evangelischen Kirche in Haigerloch widmet das Amt für Kultur und Tourismus am Sonntag , 27 . Oktober , der Abendsmahlskirche die letzten öffentlichen Themenführungen .

Table 2: Examples of en-de translations.

500

mle mbt

400

300

200

100

0

len(output)-len(reference)

Figure 5: Histogram of differences in length between the reference and system outputs. MLE-trained BT tends to generate slightly more outputs with lengths that greatly differ from the reference.

MetaBT Generates Fewer Pathological Outputs. In Fig. 5, we plot the histogram of length differences between the reference sentences and the translations of MetaBT and by our baseline MLE on WMT En-De. We observe a consistent trend of the MLE baseline generating more sentences with pathological length differences, i.e. more than ±5-10 words different from the reference’s lengths. One such example is illustrated in Tab. 2. We suspect that this happens for MLE because while sampling-based back-translation increases diversity of the outputs and aids overall forward performance, it will still sometimes generate extremely bad pseudo-parallel examples. Forward models that learn from these bad inputs will sometimes produces translations that are completely incorrect, for example being too short or too long, causing the trends in Fig. 5. MetaBT suffers less from this problem because the backward model continues training to improve the forward model’s dev set performance.

6 RELATED WORK
Our work is related to methods that leverage monolingual data either on the source side (He et al., 2020) or on the target side (Sennrich et al., 2016; Edunov et al., 2018) to improve the ﬁnal translation

8

count [-20,-<-120)0 [-10,-5)
-5 -4 -3 -2 -1 0 1 2 3 4 5 [ [161,,1211)) >=21

Published as a conference paper at ICLR 2021
quality. Going beyond vanilla BT, IterativeBT (Hoang et al., 2018) trains multiple rounds of backward and forward models and observe further improvement. While MetaBT cannot push the backward model’s quality as well, MetaBT is also much cheaper than multiple training rounds of IterativeBT. DualNMT (Xia et al., 2016) jointly optimizes the backward model with the forward model, but relies on indirect indicators, leading to weak performance as we showed in § 5.4.
As MetaBT essentially learns to generate pseudo-parallel data for effective training, MetaBT is a natural extension of many methods that learn to re-weight or to select extra data for training. For example, Soto et al. (2020) and Dou et al. (2020) select back-translated data from different systems using heuristic, while Wang & Neubig (2019); Lin et al. (2019); Wang et al. (2020a;b) select the multilingual data that is most helpful for a forward model. We ﬁnd the relationship between MetaBT and these methods analogous to the relationship between sampling from a distribution and computing the distribution’s density.
The meta-learning technique in our method has also been applied to other tasks, such as: learning initialization points (Finn et al., 2017; Gu et al., 2018), designing architectures (Liu et al., 2019), generating synthetic input images Such et al. (2019), and pseudo labeling (Pham et al., 2020).
7 LIMITATION, FUTURE WORK, AND CONCLUSION
We propose Meta Back-Translation (MetaBT), an algorithm that learns to adjust a back-translation model to generate data that are most effective for the training of the forward model. Our experiments show that MetaBT outperforms strong existing methods on both a standard NMT setting and a multilingual setting.
As discussed in § 5.3 the large memory footprint is a current weakness that makes it difﬁcult to apply MetaBT to larger models. However, the resulting Transformer-Base model trained with MetaBT still outperforms Transformer-Large models trained in the standard settings. Since the smaller Transformer-Base model are cheaper to deploy, this is a positive result in itself. In the future, we expect this memory limitation will be lifted, e.g. when better technology, such as automated model parallelism (Lepikhin et al., 2020) or more powerful accelerators, become available.
ACKNOWLEDGMENTS
XW is supported by the Apple PhD fellowship. HP wants to thank Quoc Le for his visionary guidance, Hanxiao Liu for his comments on the initial version of the paper, and Adams Yu for his insightful suggestions and experiences with Transformers.
REFERENCES
Mikel Artetxe, Gorka Labaka, Eneko Agirre, and Kyunghyun Cho. Unsupervised neural machine translation. In International Conference on Learning Representations, 2018. 7
Atilim Gunes Baydin, Robert Cornish, David Martínez-Rubio, Mark Schmidt, and Frank Wood. Online learning rate adaptation with hypergradient descent. In ICLR, 2018. 4
Yong Cheng, Wei Xu, Zhongjun He, Wei He, Hua Wu, Maosong Sun, and Yang Liu. Semi-supervised learning for neural machine translation. In ACL, 2016. 1
Jonathan Clark, Chris Dyer, Alon Lavie, and Noah Smith. Better hypothesis testing for statistical machine translation: Controlling for optimizer instability. In ACL, 2011. 7
Anna Currey, Antonio Valerio Miceli Barone, and Kenneth Heaﬁeld. Copied monolingual data improves low-resource neural machine translation. In WMT, 2017. 5
Zi-Yi Dou, Antonios Anastasopoulos, and Graham Neubig. Dynamic data selection and weighting for iterative back-translation. arXiv preprint arXiv:2004.03672, 2020. 9
Sergey Edunov, Myle Ott, Michael Auli, and David Grangier. Understanding back-translation at scale. In EMNLP, 2018. 1, 2, 3, 6, 7, 8
Chelsea Finn, Pieter Abbeel, and Sergey Levine. Model-agnostic meta-learning for fast adaptation of deep networks. In ICML, 2017. 2, 4, 9
9

Published as a conference paper at ICLR 2021
Jiatao Gu, Yong Wang, Yun Chen, Victor O. K. Li, and Kyunghyun Cho. Meta-learning for lowresource neural machine translation. In EMNLP, 2018. URL https://www.aclweb.org/ anthology/D18-1398. 9
Caglar Gulcehre, Orhan Firat, Kelvin Xu, Kyunghyun Cho, Loic Barrault, Huei-Chi Lin, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. On using monolingual corpora in neural machine translation. arXiv preprint arXiv:1503.03535, 2015. 1
Junxian He, Jiatao Gu, Jiajun Shen, and Marc’Aurelio Ranzato. Revisiting self-training for neural sequence generation. In ICLR, 2020. 1, 8
Vu Cong Duy Hoang, Philipp Koehn, Gholamreza Haffari, and Trevor Cohn. Iterative back-translation for neural machine translation. In ACL, 2018. 1, 2, 9
Diederik P. Kingma and Jimmy Lei Ba. Adam: A method for stochastic optimization. In ICLR, 2015. 13
Taku Kudo and John Richardson. Sentencepiece: A simple and language independent subword tokenizer and detokenizer for neural text processing. In EMNLP, 2018. 5
Dmitry Lepikhin, HyoukJoong Lee, Yuanzhong Xu, Dehao Chen, Orhan Firat, Yanping Huang, Maxim Krikun, Noam Shazeer, and Zhifeng Chen. Gshard: Scaling giant models with conditional computation and automatic sharding. Arxiv 2006.16668, 2020. 9
Yu-Hsiang Lin, Chian-Yu Chen, Jean Lee, Zirui Li, Yuyan Zhang, Mengzhou Xia, Shruti Rijhwani, Junxian He, Zhisong Zhang, Xuezhe Ma, Antonios Anastasopoulos, Patrick Littell, and Graham Neubig. Choosing transfer languages for cross-lingual learning. In ACL, 2019. 9
Hanxiao Liu, Karen Simonyan, and Yiming Yang. DARTS: differentiable architecture search. 2019. 4, 9
Graham Neubig and Junjie Hu. Rapid adaptation of neural machine translation to new languages. EMNLP, 2018. 6
Graham Neubig, Zi-Yi Dou, Junjie Hu, Paul Michel, Danish Pruthi, and Xinyi Wang. compare-mt: A tool for holistic comparison of language generation systems. In NAACL, 2019. 14
Kishore Papineni, Salim Roukos, Todd Ward, and Wei-Jing Zhu. Bleu: a method for automatic evaluation of machine translation. In ACL, 2002. 6
Hieu Pham, Qizhe Xie, Zihang Dai, and Quoc V. Le. Meta pseudo labels. Arxiv 2003.10580, 2020. 9
Ye Qi, Devendra Singh Sachan, Matthieu Felix, Sarguna Padmanabhan, and Graham Neubig. When and why are pre-trained word embeddings useful for neural machine translation? In NAACL, 2018. 5
Jurgen Schmidhuber. Learning to control fast-weight memories: An alternative to dynamic recurrent networks. In Neural Computation, 1992. 2
Rico Sennrich, Barry Haddow, and Alexandra Birch. Improving neural machine translation models with monolingual data. In ACL, 2016. 1, 2, 3, 8
Kaitao Song, Xu Tan, Tao Qin, Jianfeng Lu, and Tie-Yan Liu. Mass: Masked sequence to sequence pre-training for language generation. arXiv preprint arXiv:1905.02450, 2019. 1
Xabier Soto, Dimitar Shterionov, Alberto Poncelas, and Andy Way. Selecting backtranslated data from multiple sources for improved neural machine translation. In ACL, 2020. 9
Felipe Petroski Such, Aditya Rawal, Joel Lehman, Kenneth O. Stanley, and Jeff Clune. Generative teaching networks: Accelerating neural architecture search by learning to generate synthetic training data. In arxiv, 2019. 9
Ilya Sutskever, Oriol Vinyals, and Quoc V. Le. Sequence to sequence learning with neural networks. In Advances in Neural Information Processing Systems, 2014. 1
10

Published as a conference paper at ICLR 2021
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin. Attention is all you need. In Advances in Neural Information Processing Systems, 2017. 1, 6, 13
Xinyi Wang and Graham Neubig. Target conditioned sampling: Optimizing data selection for multilingual neural machine translation. In ACL, 2019. 9
Xinyi Wang, Hieu Pham, Philip Arthur, and Graham Neubig. Multilingual neural machine translation with soft decoupled encoding. In ICLR, 2019. 6
Xinyi Wang, Hieu Pham, Paul Mitchel, Antonis Anastasopoulos, Jaime Carbonell, and Graham Neubig. Optimizing data usage via differentiable rewards. In International Conference on Machine Learning, 2020a. 4, 9
Xinyi Wang, Yulia Tsvetkov, and Graham Neubig. Balancing training for multilingual neural machine translation. In ACL, 2020b. 9
Ronald J. Williams. Simple statistical gradient-following algorithms for connectionist reinforcement learning. Machine Learning, 1992. 4
Yingce Xia, Di He, Tao Qin, Liwei Wang, Nenghai Yu, Tie-Yan Liu, and Wei-Ying Ma. Dual learning for machine translation. In Advances in Neural Information Processing Systems, 2016. 1, 6, 7, 9
11

Published as a conference paper at ICLR 2021

A APPENDIX

A.1 DERIVATION FOR THE GRADIENT OF ψ

Notations. We present the derivation of the gradient of our backward model P (x|y; ψ) that we

stated in 8. Throughout the derivation, we use the standard Jacobian notations. Speciﬁcally, if

f (x1, x2, ..., xm)

:

Rm

→

Rn

is

a

smooth

function,

then

∂f ∂x

∈

Rn×m

is

the

Jacobian

matrix,

where

the entry at row ith and column jth is ∂∂xfij . In the special case that n = 1, ∂∂fx is the transpose of

the gradient vector ∇xf . Additionally, per standard conventions, vectors are column vectors unless

otherwise speciﬁed. To avoid confusions, we annotate the dimensions of the matrices and vectors in

our equations.

Derivation. At training step tth, the forward model’s parameter from the previous step was θ(t−1), and the backward model’s parameter was ψ(t−1). Based on ψ(t−1), and receiving a sentence y ∼ PT (y) in the target language T , the backward model samples a pseudo source sentence x ∼ P (x|y; ψ(t−1)). Using (x, y), the forward model computes the gradient and updates its parameter θ. For simplicity, we consider the case where the forward model is trained with SGD with learning
rate η. This leads to the following update:

θ(t) = θ(t−1) − η∇θ x, y; θ(t−1)

(10)

In MetaBT, we update ψ(t−1) into ψ(t) such that the loss of the forward model on the development at the expected parameter θ(t) is minimized. We compute the gradient ∇ψ according to this goal. The expected parameter θ(t) is:

(t)
θ = Ex∼P (x|y;ψ(t−1))

θ(t−1) − η∇θ

x, y; θ(t−1)

= θ(t−1) − η P x y; ψ(t−1) ∇θ x, y; θ(t−1)

(11)

x

Here, the summation is taken over all possible sequences of tokens x. Note that under regulatory conditions of the distribution P x y; ψ(t−1) , this summation converges.

(t)
Now, for simplicity, let us denote the loss of the forward model at θ on the development set Ddev as Jdev θ(t) . We apply the chain rule to compute ∇ψJdev as follows:

[∇ψ Jdev ]

(t)
= ∂Jdev = ∂Jdev · ∂θ ∂ψ ∂θ(t) ∂ψ

1×|ψ|

1×|θ| |θ|×|ψ|

(12)

We will approximate the ﬁrst factor in 12 using a single sample θ(t), which is calculated according to the x that we sample as discussed in 10, that is:

∂Jdev ≈ ∂Jdev

(13)

∂θ(t) ∂θ(t)

Now we expand the second factor in 12 as follows:

∂Jdev = ∂θ(t−1) −η ∇

∂θ(t)

∂ψ

θ x

|θ|×|ψ| ≈0 (Markov)

x, y; θ(t−1)
|θ|×1

∂P x y; ψ(t−1) · ∂ψ
1×|ψ|

(Markov assumption)

= −η ∇θ
x

x, y; θ(t−1)

∂ log P x y; ψ(t−1) ·

·P

x y; ψ(t−1)

∂ψ

|θ|×1

1×|ψ|

scalar

(log-gradient trick)

= −ηEx∼P (x|y;ψ(t−1)) ∇θ

x, y; θ(t−1)

∂ log P x y; ψ(t−1) ·

∂ψ

(14)

12

Published as a conference paper at ICLR 2021

Once again, we approximate this resulting expectation via a single sample x ∼ P x

is:

∂Jdev ≈ −η ∇

x, y; θ(t−1)

∂ log P x y; ψ(t−1) ·

(t)

θ

∂θ

∂ψ

|θ|×|ψ|

|θ|×1

1×|ψ|

Putting 13, 15, and 12 together, we have the ﬁnal approximating gradient ∇ψJdev:

y; ψ(t−1)

, that (15)

[∇ψJdev] ≈ −η · ∂∂Jθd(te)v · ∇θ x, y; θ(t−1) · ∂ log P x∂ψy; ψ(t−1) (16)

1×|θ|

|θ|×1

1×|ψ|

Using associativity of matrix multiplications, we can group the ﬁrst two factors which result in a scalar. Then, by transposing both sides, we obtain the ﬁnal result:

∇ψJdev ≈ −η ·
|ψ|×1

∇θJdev θ(t)
1×|θ|

· ∇θ x, y; θ(t−1)
|θ|×1

· ∇ψ log P x y; ψ(t−1)
|ψ|×1

(17)

This ﬁnal result is almost what we stated in 8. In 8, we do not have the learning rate term −η, since η is a scalar and can be absorbed into the learning rate of the backward model. Thus, our derivation is complete.

It is worth noting that our derivation above assumes that the forward model parameters θ is updated with vanilla stochastic gradient descent. In reality, we either use Adam (Kingma & Ba, 2015) or LAMBOptimizer to update θ. In that case, the derivation of MetaBT stays almost the same, except that at Eq. 11, we will have a slightly different update:

(t)
θ = Ex∼P (x|y;ψ(t−1))

θ(t−1) − η · h

∇θ

x, y; θ(t−1)

,

(18)

where h is the function speciﬁed by the optimizer. If we assume that all moving averages and momentums of the optimizer are independent of θ and ψ, then we can simply replace ∇θ x, y; θ(t−1) with h ∇θ x, y; θ(t−1) and use follow the same derivation.
It is also worth noting that in our derivations, we made two strong approximations about computing an expectation via a single sample, namely at 13 and 15, which could potentially lead to a high variance in our approximation. However, since the backward model P (x|y; ψ) is pre-trained to convergence, most of the samples x from it will concentrate around the correct pseudo source sentence, and hence the variance of these approximations are reasonable. It is hard to measure such variance and conﬁrm our hypothesis here. Nevertheless, the fact that our training procedure does not diverge empirically suggests that our approximations have acceptable variances.

A.2 TRAINING DETAILS
Here we list some other training details of the standard setting:
• We use the Transformer-Base architecture from Vaswani et al. (2017). All initialization follow the paper.
• We share all embeddings and softmax weights between the encoder and the decoder. • We use a batch size of 2048 sentences for the forward model, and a batch size of 1024
sentences for the backward model. We use a smaller batch size of 512 for the validation batches that are sampled from Ddev. • We train for 200,000 update steps, where each update step counts as one update for the forward model and one update for the backward model, as we described in Section 2.
The training details of the multilingual NMT setting are as follows:
• We use the transformer model with word embedding of dimension 512, and feed-forward dimension of 1024. It has 6 layers and 4 attention heads for both the encoder and the decoder.

13

Published as a conference paper at ICLR 2021

az be gl sk

0.01

0.00

−0.01 [1, 10)

[10, 100) [100, 1K) [1K, 10K)

Figure 6: Gain in target word F1 measures of MBT compared to MLE. Words are bucketed from left to right based on increasing frequency in the S -T data. MBT brings more gains on target words have middle frequency in the related language data.

• We share all embeddings between the encoder and the decoder. • Since the dataset is relatively small, we ran each experiment 4 times with different random
seeds and record the average. • To optimize the backward model, we use a baseline to stabilize training. We keep a moving
average baseline of the gradient dot-product as in 8 (the forward model’s gradient alignment), and subtract the baseline from the current reward before each update.
A.3 EFFECT OF MBT ON MULTILINGUAL TRANSFER
To further demonstrate the effect of these improvements in vocabulary coverage, we compare the word prediction accuracy for target words in the training data of S -T . We bucket the target words in the test set according to their frequency in S -T , and then calculate the word F-1 scores for each bucket3. The difference of F-1 score between MBT and MLE for the four languages in the multilingual setting are plotted in 6. We can see that MBT generally has higher word accuracy than MLE, and the gains are most signiﬁcant for middle-frequency words in the related language, probably because high-frequency words may be covered well already by the training data in the low-resource language. The improved word accuracy indicates that MBT can make better use of the data from the related language.
A.4 TRAINING PLOTS FOR WMT EN-FR
We also provide the validation perplexity and BLEU for WMT en-fr in Fig. 7. Similar to the plots in Fig. 3, our method consistently leads to higher dev BLEU and lower perplexity than the standard back-translation.

3We use compare-mt for analysis (Neubig et al., 2019) 14

Published as a conference paper at ICLR 2021

Dev PPL Dev BLEU

4.0

36.0

MLE

MLE

3.9

MBT

35.5 MBT

3.8

35.0

3.7 34.5
3.6 34.0

Figure 7: Validation PPL and BLEU for WMT en-fr.

15

