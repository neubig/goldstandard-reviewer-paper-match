Sanity Simulations for Saliency Methods

arXiv:2105.06506v2 [cs.LG] 27 Jun 2021

Joon Sik Kim Carnegie Mellon University joonsikk@andrew.cmu.edu

Gregory Plumb Carnegie Mellon University gdplumb@andrew.cmu.edu

Ameet Talwalkar Carnegie Mellon University
Determined AI talwalkar@cmu.edu

Abstract
Saliency methods are a popular class of feature attribution explanations that aim to capture a model’s predictive reasoning by identifying “important” pixels in an input image. However, the development and adoption of these methods is currently hindered by the lack of access to ground-truth model reasoning, which prevents accurate evaluation. In this work, we design a synthetic evaluation framework, SMERF, that allows us to perform ground-truth-based evaluation while controlling the complexity of the model’s reasoning. Experimentally, SMERF reveals signiﬁcant limitations in existing saliency methods, especially given the relative simplicity of its synthetic evaluation tasks. Consequently, SMERF represents a useful tool for the development of new saliency methods.
1 Introduction
Saliency methods have emerged as a popular tool to better understand the behavior of machine learning models. Given a model and an input image, these methods output a feature attribution that indicates which pixels they deem to be most “important” to the model’s prediction [1–9]. Thus, a natural question to ask is: how do we deﬁne “important” and subsequently evaluate the efﬁcacy of these methods?
One intuitive approach is to measure how well a saliency method locates the expected pixels of interest in the input image. In fact, this “pointing game” [10] is one of the predominant evaluations used today [11–16]. Currently, these evaluations rely on external knowledge to deﬁne an expected feature attribution that highlights the pixels that a human would expect to be important for the given task. Then, they compute the overlap between the output of a saliency method and this expected feature attribution using metrics such as Intersection-Over-Union (IOU).
Unfortunately, there are two key limitations of existing pointing game evaluations. First, the results are unreliable when the model’s ground-truth reasoning does not match human expectations, e.g., when the model is relying on spurious correlations. This is particularly problematic because detecting such discrepancies is one of the purported use cases of saliency methods. Second, they are based on relatively simple object detection tasks where we expect only a single region of the image, i.e., the object itself, to be relevant to the prediction. In practice, there exist more complex tasks, e.g., in medical imaging or autonomous driving, where considering interactions among multiple regions of the image may be necessary to achieve high predictive accuracy.
These two limitations highlight the same fundamental concern: we do not know a priori what or how complex the model’s reasoning will be, irrespective of how simple we expect the underlying task to be. For instance, the top panel of Figure 1 considers the seemingly simple task of identifying a baseball bat in an image. To perform this task, the model may use simple reasoning by relying on a single region of the image, i.e., the bat itself, to make its prediction. However, it also may use more complex reasoning by relying on interactions among multiple regions of the image, e.g., using the
Preprint. Under review.

Input

Expected Feature Attribution

predict: baseball bat Feature Attribution Model

Typical Pointing
Game
Ideal Pointing
Game

Hypothetical Ground-truth Feature Attribution

predict: alphabet B
Model

Ground-truth Feature Attribution
SMERF

Figure 1: Top. Existing pointing game evaluations do not have access to ground-truth feature attributions and instead rely on expected feature attributions. Potential discrepancies between these attributions represent a fundamental limitation of existing evaluations. For instance, we expect that a model trained to detect a baseball bat will rely on the baseball bat region of the image. However, it may be the case that the model relies on a more complex reasoning by using the presence of a person and a glove to identify a bat. Bottom. SMERF constructs a synthetic set of tasks that are stylized versions of real object detection tasks. For instance, consider the task of identifying the letter ‘B’ in an image, where ‘B’ corresponds to the baseball bat, and the two boxes correspond to the person and the glove. SMERF controls a trained model’s underlying reasoning via simulations over different data distributions, thus providing ground-truth feature attributions that we can use to evaluate saliency methods.
presence of a person and a glove to identify a bat. As illustrated through this example, the practical utility of saliency methods hinges on their robustness to the complexity of the model’s reasoning.
In this work, we aim to address the aforementioned limitations of existing pointing game evaluations and to study the degree to which saliency methods can capture a model’s reasoning. We introduce a synthetic framework called Simulated ModEl Reasoning Evaluation Framework (SMERF) that allows us to perform ground-truth-based evaluation of saliency methods while controlling the complexity of the model’s reasoning. We leverage SMERF to perform an extensive and nuanced evaluation of leading saliency methods on several stylized object detection problems that are motivated by real-world object detection tasks (e.g., Figure 1 Bottom).
Using SMERF, we ﬁnd that, for models with simple reasoning, most saliency methods perform reasonably well on average, as measured by IOU values with a correctness threshold of 0.5. However, we also observe some failure modes across different experimental scenarios. For instance, all methods exhibit certain levels of performance degradation when the input image contains extraneous objects that are not relevant to the prediction. Moreover, for models with more complex reasoning, none of the methods meet the deﬁned correctness threshold on average, and all of them demonstrate acute failure modes. Our key results are summarized in Figure 2.
Our results highlight major limitations in existing saliency methods, especially given the relative simplicity of SMERF’s synthetic evaluation tasks and the arguably lenient deﬁnition of correctness we consider1. Indeed, we view the performance of saliency methods on SMERF’s stylized tasks as an upper bound on the saliency methods’ ability to recover simple or complex model reasoning on tasks involving natural images. Moreover, we believe that benchmarking suites like SMERF can play an important role moving forward in the development of new methods to potentially overcome these limitations.
1While we view the 0.5 IOU threshold as a lenient deﬁnition of correctness in synthetic settings, we selected this notion of correctness because it is commonly used in practice when evaluating on real tasks [17, 18].
2

(higherItOheU better)

1.0

Simple Reasoning

0.8

0.6

0.4

0.2

0.0

Complex Reasoning
Avg Min correctness threshold

Gradient SmoothGrad
Deconvnet GBP
DeepTaylor IG LRP
DeepLIFT Grad-CAM DeepSHAP Gradient SmoothGrad Deconvnet
GBP DeepTaylor
IG LRP DeepLIFT Grad-CAM DeepSHAP

Figure 2: Summary of ground-truth-based evaluation of saliency methods via SMERF. Left. In simple reasoning settings, where the model relies on a single region of the image to make its prediction, performance (blue) is reasonably good for most of the methods. However, all methods still demonstrate failure modes as shown by minimum performance (orange) over various tasks. Right. In more complex reasoning settings, where the model relies on interactions among multiple regions of the image, most of the methods suffer from average performance degradation and demonstrate acute failure modes.
2 Related Work
Pointing Game Evaluation. The pointing game, which measures how well a saliency method identiﬁes the relevant regions of an image, is one of the predominant ways to evaluate the efﬁcacy of these methods [11–16]. Many existing pointing game evaluations lack access to ground truth model reasoning, and instead rely on expected feature attributions generated by domain experts to evaluate saliency methods. Intuitively, this might appear to be reasonable by observing that the model has high test accuracy and concluding that it must be using the correct reasoning. However, datasets often contain spurious correlations and, as a result, a model may be able to achieve high test accuracy using incorrect reasoning. Consequently, these evaluations have confounded the correctness of the explanation with the correctness of the model. SMERF eliminates this confounding factor by leveraging the model’s ground-truth reasoning, which allows us to demonstrate that several methods that were previously deemed to be effective are in fact sometimes ineffective when the model’s reasoning is more complex.
More recently, [19, 20] tried to address this same limitation using semi-synthetic datasets where the ground-truth reasoning is known by combining the object from one image with the background from another image. Both analyses are based on the simple reasoning setting and, in that setting, our results roughly corroborate theirs. However, our analysis extends to more complex reasoning settings and demonstrates that methods that worked in the simple reasoning setting mostly fail or perform much worse in these settings. It is important to consider the more complex reasoning setting because we do not know how complex the model’s reasoning is in practice (e.g., a model may rely on a spurious correlation and use complex reasoning for a simple task).
Other metrics. Beyond the pointing game, several proxy metrics have been proposed to measure the efﬁcacy of saliency methods [4, 21–23]. However, [24] shows that such metrics inherently depend on subtle hyperparameters that are not well understood and that this leads to analyses with inconsistent results. The unreliability of such proxy metrics further emphasizes the advantage of using a more intuitive and direct evaluation like SMERF.
Direct criticisms of saliency methods. [25] uses two sanity checks that measure the statistical relationship between a saliency method and the model’s parameters or the data it was trained on. They found that only a few methods (i.e., Gradients [1] and Grad-CAM [12]) passed these tests. While SMERF is orthogonal to this type of analysis, it demonstrates that even methods that pass these tests, have failure cases (as shown in Figure 2).
3 Methods
We now introduce SMERF, a synthetic evaluation framework where several types of ground-truth model reasoning, ranging from simple to complex, are generated to test saliency methods’ ability to
3

recover them. We ﬁrst describe several types of model reasoning that are motivated by real-world examples and then captured in SMERF’s synthetic family of datasets called TextBox (Section 3.1). In Section 3.2 we explain how the ground-truth model reasoning is generated in SMERF with TextBox and describe the particular model reasoning settings we focus on in our experimental evaluation.

3.1 Types of Simple and Complex Model Reasoning

We are interested in evaluating the performance

of saliency methods in capturing both simple and complex model reasoning, where the com-

No Reliance (NR)

Full Reliance (FR)

Conditional Reliance (CR)

plexity of reasoning is deﬁned based on whether X

Ŷ

X

Ŷ

X

Ŷ

the model relies on a single or multiple regions

of the image. We next describe three different

ways in which a model may exhibit simple or

F

F

complex reasoning, with the different settings

F

Correct Feature

Attribution

characterized by the model’s reliance on the true set of features (X) and/or the set of spurious features (F ).

Figure 3: Given true features X and spurious features F in the training data, the learned model may exhibit simple or complex reasoning in various ways depending on how it relies on X and/or F . No-Reliance (NR) and

Consider the model trained to detect a baseball Full-Reliance (FR) denote settings where the model re-

bat from Figure 1. The model may correctly rely lies solely on X or F , respectively. Conditional Reliance

on the true set of features corresponding to the bat in the image, without relying on spurious features like the glove or the person. We denote models that exhibit no reliance on spurious features as the No-Reliance (NR) setting (Figure 3,

(CR) denotes settings where the model depends on both X and F . SMERF allows us to control the model’s reasoning and to thus evaluate saliency methods against the ground-truth feature attribution (denoted in red) derived from this underlying reasoning.

left). Another model could instead learn to pre-

dict the existence of the bat solely from the existence of the glove and the person, thus fully relying

on spurious features, a setting we call Full-Reliance (FR) (Figure 3, middle). Finally, the model

may rely on both the true and the spurious sets of features (Figure 3 right), a setting we denote as

Conditional-Reliance (CR). For instance, a model may learn to rely on the glove only when the person

is present, but otherwise on the bat itself for the prediction.

CR by default prescribes complex reasoning due to its conditional nature. In contrast, the complexity of model reasoning for NR and FR depends on how many objects are included in X and F . NR and FR prescribe simple reasoning when X and F each consists of features corresponding to a single object. In particular, as visualized in Figure 1, existing pointing game evaluations in the literature are performed with respect to a simple reasoning under the assumption that the model exhibits NR, with X being the single object of interest [11, 12]. Moreover, previous controlled setups for evaluating saliency methods against ground-truth model reasoning were limited to simple model reasoning in the FR setting, e.g., setting F as the background and X as a single object of interest [19, 20]. However, NR or FR can also prescribe complex reasoning by having multiple objects belong to X or F , respectively.

Box2 Box1 Text
Figure 4: Features used in the TextBox datasets.

SMERF instantiates simple and complex model reasoning in these three settings by creating a family of datasets called TextBox. These datasets all consist of 64-by-64 pixel images with black backgrounds that include three types of white objects which may (or may not) appear in random locations in each image (Figure 4): Text, ‘A’, ‘B’; Box1, a 10-by-10 box; and Box2, a 4-by-4 box. SMERF uses these objects to encode different types of relationships in Figure 3 and thus controls the underlying model reasoning, with X = Text and F = {Box1, Box2}.

For instance, we can consider FR with complex reasoning (corresponding to Figure 1 Bottom) by training a model to rely on the presence of both Box1 and Box2 instead of Text, and we can consider CR by training a model to rely on Box1 only when Box2 is present, otherwise on Text. Such instantiations are stylized versions of real object detection scenarios, as TextBox essentially aims to capture plausible reasoning the model may be using in real settings, e.g., with each of the simpliﬁed objects corresponding to the bat, the gloves, and the person from Figure 1.

4

Text

■

0

1

0
Text

䡧

1

Text

■

0

1

Text

1

2

3

4

5

6

7

8

9

10

11

12

Labels A
if (䡧,■): B; else: A

A

A

train

Model

A

A

A

A

A

A

B

B

B

validate with unseen

Bucket Focus Avoid Bucket Focus Avoid Bucket Focus Avoid Bucket Focus Avoid

1

-

-

4

-

-

7

-

-

10 (䡧,■) -

2

-

A

5

-

A

8

-

A

11 (䡧,■) A

3

-

B

6

-

B

9

-

B

12 (䡧,■) B

Ground-truth Feature Attribution

Figure 5: Workﬂow of SMERF for a model with FR on Box1 and Box2 (Complex-FR in Table 1). We ﬁrst generate twelve buckets of images each composed of different sets of features and corresponding labels. The model is trained on samples from each of the buckets and validated on unseen ones. After validation, ground-truth feature attributions are generated for the evaluation of saliency methods.

3.2 Training Models with Ground-truth Reasoning

We now describe the procedure that SMERF uses to encode the desired model reasoning from a given TextBox dataset. For a particular desired model reasoning (e.g., complex reasoning in the FR setting), SMERF creates an appropriate training dataset. Speciﬁcally, SMERF ﬁrst creates several buckets of images, where each bucket corresponds to particular values for X and F , and an associated label based on the desired model reasoning. For instance, a particular bucket could involve setting X = none and F to include Box1 and Box2, and the corresponding label could be ‘B’. The total number of buckets depends on the cardinality of X and F , as we create buckets for all possible (X, F ) value pairs; hence for TextBox datasets we consider 12 buckets2. More formally, considering the joint distribution p(X, F, Y ), each bucket will be composed of images with features X = x, F = f along with the label y ∼ p(Y |X = x, F = f ), with different images in each bucket varying by the location of the features.

Name Simple-NR Simple-FR Complex-FR Complex-CR1
Complex-CR2
Complex-CR3
Complex-CR4

Model Reasoning
Based on Text Based on Box1 Based on Box1 and Box2 Box2: based on Box1; No Box2: based on Text Box1: based on Box2; No Box1: based on Text Box2: based on Text; No Box2: based on Box1 Box1: based on Text; No Box1: based on Box2

Table 1: Types of model reasoning considered by SMERF from TextBox datasets.

Once the dataset has been created, we train a convolutional neural network (see details in Appendix A), which is then validated with unseen data points from each bucket to ensure that the ground-truth model reasoning has been properly encoded. Ground-truth feature attributions for each image are generated based on this veriﬁed model reasoning and are later used for evaluating saliency methods.

Figure 5 depicts the steps of dataset creation and model training / validation when we are interested in complex model reasoning with FR. In this example, we aim to correlate the label with the presence of both boxes, thus providing one label for the three buckets that include both boxes (buckets 10-12), and a separate label for the 9 buckets that include at most one box (buckets 1-9). To balance the number of positive and negative samples in the dataset, more instances are sampled from buckets 10-12 for the training data, and we train the model to near-perfect accuracy. The model is then validated on unseen samples from each bucket to verify the desired model reasoning, namely full reliance on both boxes rather than on Text or on a single box. This ground-truth model reasoning veriﬁed is then used to generate ground-truth feature attribution, deﬁning regions the saliency methods should focus and/or avoid for images in each buckets.

We generate seven types of datasets shown in Table 1 using the three features in TextBox for our experiments, where each dataset is used to train models with different types of reasoning. While all of the listed datasets in Table 1 technically consist of twelve buckets (since the same set of features is

2There are three different values for Text (Nothing, ‘A’, or ‘B’), two for Box1, and two for Box2, resulting in a total of 12 distinct combinations.

5

used throughout), some buckets may be discarded from the dataset when the samples in the bucket do not ﬁt into the model reasoning. For instance, Simple-NR is composed of 8 buckets instead of 12, because images from 4 buckets without any Text (Buckets 1, 4, 7, 10 in Figure 5) have undeﬁned model predictions.
4 Experiments
In this section, we use SMERF and the TextBox datasets to show3 how several leading saliency methods perform in recovering the different types of model reasoning described in Table 1. For simple reasoning (Section 4.1), we ﬁnd that saliency methods perform reasonably well (with a few exceptions), which is generally consistent with previous pointing game evaluations. However, we observe a general trend of decreasing performance as input images become more “saturated” (i.e., ﬁlled with more objects), even though the model’s underlying reasoning does not change. For complex reasoning (Section 4.2), the average performance for all methods decreases and we also see more acute failure cases due to methods incorrectly focusing on irrelevant features. These failure cases make the feature attributions qualitatively indistinguishable across different model reasoning, raising practical concerns since users in general do not know the type of reasoning being used (and in fact rely on saliency methods to discern this information).
Saliency Methods and Simple Baselines. We use a modiﬁed version of the open-source library iNNvestigate[26] which includes several implementations of leading saliency methods. In our experiments, we use the following methods: Gradient [1], SmoothGradients [8], DeConvNet [2], Guided Backpropagation (GBP) [3], Deep Taylor Decomposition (DeepTaylor) [7], Input*Gradient(I*G) [6], Integrated Gradients (IG) [5], and Layerwise Relevance Propagation (LRP) [4] (four variations), DeepLIFT [6] (two variations), Grad-CAM [12], and DeepSHAP [9]. We also add some simple baselines, like Random (random-valued feature attribution) and Edge-detection; both of these are model-independent and therefore are not useful in understanding the model reasoning.
Evaluation Metrics. Typical pointing game evaluations measure the performance of saliency methods with the Intersection-Over-Union (IOU) metric [11, 17]. This metric computes the ratio of the area of the intersection to the area of the union of the binary-masked feature attribution and the ground-truth feature attribution. Given the popularity of this metric, we perform extensive experiments with IOU: Figure 2 summarizes the results and Appendix B.1 provides a detailed analysis of them.4 However, IOU loses information from raw attribution values by thresholding to generate a binary mask for evaluation. It is therefore more likely to ignore non-trivial signals from extra features in the image. For instance, consider two objects A and B each assigned with attribution values 100 and 99, while the background with only 1. IOU will only pick up A after thresholding even when B also should be considered, given the non-trivial attribution values it was given compared to the background.
To address these thresholding issues, we measure the performance of the methods with a previously deﬁned [27] but unnamed metric that we call attribution focus level (AFL). This metric quantiﬁes the proportion of the total attribution values that are assigned to the region of interest. Given the raw feature attribution values, we ﬁrst normalizes them to sum to one and then compute the sum of values assigned to pixels inside the region of interest. Intuitively, values near 1 indicate a stronger level of focus on the region of interest. Consistent with the deﬁnition of correctness for the IOU metric, we deﬁne a threshold value of 0.5 to roughly distinguish good and bad performance in terms of AFL.
To better account for the relationship between multiple features in the image, we compute two types of AFL: (1) Primary AFL (PAFL), which measures the level of focus on the correct (primary) features that are relevant for the prediction, and (2) Secondary AFL (SAFL), which measures the same quantity for the incorrect (secondary) features that are irrelevant for the prediction (excluding background). Notably, the sum of PAFL and SAFL is upper bounded by 1, so PAFL > 0.5 implies that PAFL > SAFL, which further indicates that the feature attribution correctly focuses more on the relevant features than the irrelevant ones. Conversely, when SAFL > PAFL, the feature attribution has failed due to incorrectly focusing on irrelevant regions.
3Code available at github.com/wnstlr/SMERF. 4Although IOU is not our main metric of interest, the general conclusions from Figure 2 are consistent with those of our main results.
6

the higher the better

Simple-FR

the lower the better

Primary ASFimLp(fleorRDeiaffseorneinntgBuckets)
1.0 0.8 0.6 0.4

1.0 SecondarySiAmFpLl(efoRreDaisfofenrienngt Bucke(FtRs)) Text o

PAFL

SAFL

(FR) Text x

0.8

0.8

(NR) Box1 o

0.6

0.3

0.6

(NR) Box1 x 0.5 threshold 0.4

0.2

0.4

average

0.2

0.1

0.2 0.2 0.0

0.0

0.0

Simple-NR

0.8

0.25

1 obj

0.6 00..1250 23 oobbjj

0.4

0.10

0.2

0.05

0.00

SmoGortahdGireantd GuidedDeBcaocknvprnoetp InputD*eeGrpaTdaiyelnotr Integrated GradLiRePn-tsZ LRP-LPrReP-sEetpAsilFloant DeepLIFLT-RPR-ePvreeasleCtaBnFlcaetl DeepLIFGTr-aRde-sCcAalMe
DeReapnSdHoAPm Edge-detection

SmoGortahdGireantd GuidedDeBcaocknvprnoetp InputD*eeGrpaTdaiyelnotr Integrated GradLiRePn-tsZ LRP-LPrReP-sEetpAsilFloant DeepLIFLT-RPR-ePvreeasleCtaBnFlcaetl DeepLIFGTr-aRde-sCcAalMe
DeReapnSdHoAPm Edge-detection

(a) PAFL and SAFL for Simple Reasoning

(b) PAFL and SAFL based on the number of objects in the image (xaxis is the same as Figure 6a)

Figure 6: (a) PAFL (left) and SAFL (right) for Simple-FR and Simple-NR from Table 1. The black vertical lines indicate the standard deviation across different buckets. Most methods perform well on average, with reasonable PAFL and low SAFL. The methods on the left are the exception. The colored lines indicate average performance for different buckets that have either Text or Box1 (i.e. the irrelevant features) present (o) or absent (x). (b) PAFL decreases and SAFL increases as the number of objects increases, which indicates that these methods perform worse as images become “saturated.”

4.1 Simple Reasoning Evaluation
To better understand the methods’ behaviors for different types of inputs, we study PAFL and SAFL computed on images from different buckets containing distinct sets of features. For a high-level understanding of how the methods generally perform across all types of images, we ﬁrst plot PAFL and SAFL averaged across all buckets for simple reasoning instantiated with Simple-FR and SimpleNR (grey vertical bars in Figure 6a). We observe that most of the methods, except for Gradient, SmoothGradient, DeConvNet, and GBP, perform reasonably well, with PAFL exceeding the 0.5 correctness threshold and SAFL being lower. This reasonable level of performance aligns with what existing pointing game evaluations in the literature have shown with simple reasoning [12, 20].
Despite their reasonable performance in average, we observe a trend that PAFL decreases and SAFL increases as more objects are visible in the image, even though the model reasoning remains simple. The colored lines in Figure 6a exemplify this trend by showing per-bucket performance for two buckets for Simple-FR (blue and orange) and Simple-NR (green and red). For both cases, all methods show lower PAFL on buckets where an irrelevant object (Text for Simple-FR in blue and Box1 for Simple-NR in green) is present, compared to buckets where that object is absent (orange and red). This means that part of the feature attribution originally assigned to the relevant object shifts to the irrelevant ones when they are visible in the image. Figure 6b veriﬁes this trend for all buckets containing different number of visible objects: average PAFL from buckets with fewer objects strictly upper bounds average PAFL from buckets with more objects, and SAFL increases along with the number of objects. These variations in AFL based on the number of objects in the image lead to non-trivial variance across buckets as shown with vertical error bars (i.e. standard deviation) in Figure 6a. Qualitative samples from buckets with additional objects conﬁrm that for images with more objects, the methods tend to highlight all of them regardless of the type of reasoning used, leading to decreased PAFL and increased SAFL (Appendix B.2).
To better understand how the methods’ performance may vary across different buckets and to identify failure modes, we record the fraction of buckets for which each method is considered “successful” and indicate it with a color ranging from black (0) to white (1) (Figure 7 Left).5 Here we deﬁne “success” as PAFL > 0.5, which implies (1) feature attribution has reasonable focus on the relevant features, and (2) it correctly focuses more on the relevant features than on other irrelevant ones. This condition should be consistently satisﬁed in all buckets (i.e. the success ratio has to be 1) if the method is to be considered truly effective. Looking at the simple reasoning setups (the ﬁrst two rows) we see that methods in the middle (I*G through DeepLIFT) have relatively higher success rates overall. Among these relatively successful ones, DeepLIFT-Rescale is the only method that succeeds in all buckets for both types of simple reasoning. Methods like Gradients, SmoothGradients,
5This fraction only considers buckets that contain both relevant and irrelevant features.
7

Less than half fails More than half fails

the higher the better

Figure 7: Left: The fraction of buckets for which the methods are successful (i.e., PAFL > 0.5). Most success cases are concentrated on the simple reasoning setting. Right: The cases where the method fails due to wrong focus (i.e., SAFL > PAFL) on more than half of the buckets for each reasoning. Most failure cases are concentrated on complex reasoning, which aligns with the overall increase in SAFL throughout Figure 8a.

PrimaryCAoFmLp(lfeoxr DRiefafesroennitngBuckets)
1.0 0.8 0.6 0.4 0.2 0.0

the lower the better

SecondarCyoAmFpLle(fxorRDeaifsfeorneinngt Buckets)

1.0 (CR2) Box1 o, Box2 x

0.8

(CR2) Box1 x, Box2 o

0.6

(CR2) Box1 o, Box2 o

0.5 threshold

0.4

average

0.2

0.0

(higherPtAhFeLbetter)

Min1i.m0 um PAFL Across Buckets

Simple Reasonig

0.8

Complex Reasoning 0.5 threshold

0.6

0.4

0.2

0.0

SmoGortahdGireantd GuidedDeBcaocknvprnoetp InputD*eeGrpaTdaiyelnotr Integrated GradLiRePn-tsZ LRP-LPrReP-sEetpAsilFloant DeepLIFLT-RPR-ePvreeasleCtaBnFlcaetl DeepLIFGTr-aRde-sCcAalMe
DeReapnSdHoAPm Edge-detection

SmoGortahdGireantd GuidedDeBcaocknvprnoetp InputD*eeGrpaTdaiyelnotr Integrated GradLiRePn-tsZ LRP-LPrReP-sEetpAsilFloant DeepLIFLT-RPR-ePvreeasleCtaBnFlcaetl DeepLIFGTr-aRde-sCcAalMe
DeReapnSdHoAPm Edge-detection

(a) PAFL and SAFL for Complex Reasoning

(b) Minimum PAFL over buckets on simple (blue circle) vs. complex (red x) reasoning (xaxis is the same as Figure 8a).

Figure 8: (a) PAFL and SAFL for complex reasoning. Average performance on PAFL is mostly lower than 0.5, with worse performance compared to the results for simple reasoning. Further, SAFL increases signiﬁcantly (to the point where it is on par with PAFL for some methods). Per-bucket performance variation for Complex-CR2 is plotted with colored lines, each color corresponding to the methods’ performance on a bucket with either Box1 or Box2 present (o) or absent (x). (b) Worst-case buckets show worse PFAL values in complex reasoning, which results in higher variance for the performance.

DeConvNet, and GBP fail to meet the criteria for all buckets, showing signiﬁcantly weak focus on the relevant regions.
4.2 Complex Reasoning Evaluation
We consider 5 types of complex reasoning described in Table 1: Complex-FR, and Complex-CR1 through Complex-CR4. Compared to the simple reasoning case, PAFL drops for all methods (grey vertical bars in Figure 8a). We observe that methods that exhibited strong average performance in simple reasoning settings (IG, LRP, and DeepLIFT) only narrowly meet the correctness threshold for complex reasoning, while methods that previously showed decent performance (Grad-CAM and DeepSHAP) suffer from even bigger drops in PAFL. Methods like Gradient, SmoothGradient, DeConvNet, and GBP, which showed weak performance in simple reasoning settings, still continue to exhibit low PAFL.
In addition to lower average PAFL overall, we see an increase in SAFL from complex reasoning. In some cases, SAFL approaches the 0.5 threshold, demonstrating a clear failure by focusing on the wrong object(s) (grey bars in Figure 8a right). This is immediately veriﬁed in Figure 7(left), where with a single exception (LRP-Epsilon on Complex-FR), none of the methods are able to achieve a PAFL above 0.5 on all of the buckets for complex reasoning (rows below the red dotted line). Figure 7(right) further demonstrates this disparity between simple and complex reasoning settings.
8

Figure 9: Feature attributions obtained by Integrated Gradients for different model reasoning on four inputs from different buckets, labeled with their corresponding relevant features. Essentially all objects in the image are highlighted, which makes it difﬁcult to distinguish or identify precisely which type of model reasoning is used for each column.
For complex reasoning, most methods show SAFL > PAFL on the majority of the buckets (colored with black), in stark contrast to their performance on simple reasoning (mostly white).
We next measure the worst-case performance of different methods (i.e., by evaluating the worstperforming buckets for each method, as we also visualized in Figure 2). We observe that the worst-case PAFL for complex reasoning is much lower than that for simple reasoning (Figure 8b): while most methods for simple reasoning showed the worst-case PAFL near 0.5, all methods for complex reasoning showed much lower values. Qualitative samples from these worst-performing buckets reﬂect the low PAFL with clear lack of focus on the relevant features (Appendix B.2).
Moreover, we observe that per-bucket performance variation is more extreme in complex reasoning settings. For instance, per-bucket performance on Complex-CR2 (blue, orange, and green lines in Figure 8a) shows that most methods are particularly well-behaved (PAFL above 0.5 and low SAFL) in a bucket where only Box2 is present (orange), while for other buckets with only Box1 (blue) or both Boxes (green), all methods clearly fail with PAFL below 0.5 and PAFL less than SAFL. Such variation is also visible across other types of complex reasoning tested (Appendix B.3). Naturally, these altogether contribute to higher variance of performance for complex reasoning settings (indicated with black vertical error bars in Figure 8a), even higher than the simple reasoning settings (Figure 6a).
Finally, we contextualize the aforementioned failure modes of leading saliency methods from a practitioners’ perspective, who are not aware of the type of model reasoning used, but are in fact relying on the feature attributions for this information. By failing to consistently point to only the correct set of features, the various methods we evaluated are likely to mislead practitioners. To illustrate this point, we visualize the feature attributions generated by one of the best performing methods based on our evaluation (Integrated Gradients) for models with various types of model reasoning (more examples in Appendix C). As shown in Figure 9, essentially all objects are highlighted in all of the feature attributions, and it is thus not clear how to discern the underlying model reasoning from any of them. For example, Box1 appears to be the most important object according to the feature attributions in the third row, even when this object is clearly not part of the model reasoning for Simple-NR (3rd column) and Complex-CR1 (5th column).
5 Conclusion
In this work, we propose SMERF to perform ground-truth-based pointing game evaluations for saliency methods with varying levels of underlying model complexity. Our results show that while most methods perform reasonably well on average in simple reasoning settings, they generally exhibit signiﬁcant performance drops and acute failure modes in more complex reasoning settings,
9

particularly from not being able to focus on the correct region of the input. As SMERF is used to reveal the shortcomings of existing methods in their ability to recover complex model reasoning, we believe that it can further play an important role in the development of new methods to overcome existing shortcomings. While SMERF’s synthetic nature allows for a quick sanity check on the methods, it will be useful to construct similar setups with more realistic images to better understand how the results from synthetic setups translate to real setups. Generalizing the main ideas behind SMERF may also be useful in settings where saliency methods are inherently not appropriate, e.g. problems that require counterfactual model explanations [28].
References
[1] Karen Simonyan, Andrea Vedaldi, and Andrew Zisserman. Deep inside convolutional networks: Visualising image classiﬁcation models and saliency maps, 2013.
[2] Matthew D Zeiler and Rob Fergus. Visualizing and understanding convolutional networks. In European conference on computer vision, pages 818–833. Springer, 2014.
[3] J Springenberg, Alexey Dosovitskiy, Thomas Brox, and M Riedmiller. Striving for simplicity: The all convolutional net. In ICLR (workshop track), 2015.
[4] Sebastian Bach, Alexander Binder, Grégoire Montavon, Frederick Klauschen, Klaus-Robert Müller, and Wojciech Samek. On pixel-wise explanations for non-linear classiﬁer decisions by layer-wise relevance propagation. PloS one, 10(7):e0130140, 2015.
[5] Mukund Sundararajan, Ankur Taly, and Qiqi Yan. Axiomatic attribution for deep networks. In Proceedings of the 34th International Conference on Machine Learning-Volume 70, pages 3319–3328, 2017.
[6] Avanti Shrikumar, Peyton Greenside, and Anshul Kundaje. Learning important features through propagating activation differences. In Proceedings of the 34th International Conference on Machine Learning-Volume 70, pages 3145–3153, 2017.
[7] Grégoire Montavon, Sebastian Lapuschkin, Alexander Binder, Wojciech Samek, and KlausRobert Müller. Explaining nonlinear classiﬁcation decisions with deep taylor decomposition. Pattern Recognition, 65:211–222, 2017.
[8] Daniel Smilkov, Nikhil Thorat, Been Kim, Fernanda Viégas, and Martin Wattenberg. Smoothgrad: removing noise by adding noise. arXiv preprint arXiv:1706.03825, 2017.
[9] Scott M Lundberg and Su-In Lee. A uniﬁed approach to interpreting model predictions. Advances in Neural Information Processing Systems, 30:4765–4774, 2017.
[10] Jianming Zhang, Sarah Adel Bargal, Zhe Lin, Jonathan Brandt, Xiaohui Shen, and Stan Sclaroff. Top-down neural attention by excitation backprop. International Journal of Computer Vision, 126(10):1084–1102, 2018.
[11] Bolei Zhou, Aditya Khosla, Agata Lapedriza, Aude Oliva, and Antonio Torralba. Learning deep features for discriminative localization. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), June 2016.
[12] Ramprasaath R Selvaraju, Michael Cogswell, Abhishek Das, Ramakrishna Vedantam, Devi Parikh, and Dhruv Batra. Grad-cam: Visual explanations from deep networks via gradient-based localization. In Proceedings of the IEEE international conference on computer vision, pages 618–626, 2017.
[13] Aditya Chattopadhay, Anirban Sarkar, Prantik Howlader, and Vineeth N Balasubramanian. Grad-cam++: Generalized gradient-based visual explanations for deep convolutional networks. In 2018 IEEE Winter Conference on Applications of Computer Vision (WACV), pages 839–847. IEEE, 2018.
[14] Sanghyun Woo, Jongchan Park, Joon-Young Lee, and In So Kweon. Cbam: Convolutional block attention module. In Proceedings of the European conference on computer vision (ECCV), pages 3–19, 2018.
10

[15] Shanghua Gao, Ming-Ming Cheng, Kai Zhao, Xin-Yu Zhang, Ming-Hsuan Yang, and Philip HS Torr. Res2net: A new multi-scale backbone architecture. IEEE transactions on pattern analysis and machine intelligence, 2019.
[16] Nishanth Arun, Nathan Gaw, Praveer Singh, Ken Chang, Mehak Aggarwal, Bryan Chen, Katharina Hoebel, Sharut Gupta, Jay Patel, Mishka Gidwani, et al. Assessing the (un) trustworthiness of saliency maps for localizing abnormalities in medical imaging. arXiv preprint arXiv:2008.02766, 2020.
[17] Mark Everingham, SM Ali Eslami, Luc Van Gool, Christopher KI Williams, John Winn, and Andrew Zisserman. The pascal visual object classes challenge: A retrospective. International journal of computer vision, 111(1):98–136, 2015.
[18] Yan Wang, Wei-Lun Chao, Divyansh Garg, Bharath Hariharan, Mark Campbell, and Kilian Q Weinberger. Pseudo-lidar from visual depth estimation: Bridging the gap in 3d object detection for autonomous driving. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 8445–8453, 2019.
[19] Mengjiao Yang and Been Kim. Benchmarking attribution methods with relative feature importance, 2019.
[20] Julius Adebayo, Michael Muelly, Ilaria Liccardi, and Been Kim. Debugging tests for model explanations. In H. Larochelle, M. Ranzato, R. Hadsell, M. F. Balcan, and H. Lin, editors, Advances in Neural Information Processing Systems, volume 33, pages 700–712. Curran Associates, Inc., 2020. URL https://proceedings.neurips.cc/paper/2020/file/ 075b051ec3d22dac7b33f788da631fd4-Paper.pdf.
[21] Marco Ancona, Enea Ceolini, Cengiz Öztireli, and Markus Gross. Towards better understanding of gradient-based attribution methods for deep neural networks. In International Conference on Learning Representations, 2018. URL https://openreview.net/forum?id=Sy21R9JAW.
[22] David Alvarez Melis and Tommi Jaakkola. Towards robust interpretability with self-explaining neural networks. In S. Bengio, H. Wallach, H. Larochelle, K. Grauman, N. Cesa-Bianchi, and R. Garnett, editors, Advances in Neural Information Processing Systems, volume 31. Curran Associates, Inc., 2018. URL https://proceedings.neurips.cc/paper/2018/ file/3e9f0fc9b2f89e043bc6233994dfcf76-Paper.pdf.
[23] Sara Hooker, Dumitru Erhan, Pieter-Jan Kindermans, and Been Kim. A benchmark for interpretability methods in deep neural networks. In Advances in Neural Information Processing Systems, pages 9737–9748, 2019.
[24] Richard Tomsett, Dan Harborne, Supriyo Chakraborty, Prudhvi Gurram, and Alun Preece. Sanity checks for saliency metrics. Proceedings of the AAAI Conference on Artiﬁcial Intelligence, 34 (04):6021–6029, Apr 2020. ISSN 2159-5399. doi: 10.1609/aaai.v34i04.6064. URL http: //dx.doi.org/10.1609/AAAI.V34I04.6064.
[25] Julius Adebayo, Justin Gilmer, Michael Muelly, Ian Goodfellow, Moritz Hardt, and Been Kim. Sanity checks for saliency maps. Advances in neural information processing systems, 31: 9505–9515, 2018.
[26] Maximilian Alber, Sebastian Lapuschkin, Philipp Seegerer, Miriam Hägele, Kristof T. Schütt, Grégoire Montavon, Wojciech Samek, Klaus-Robert Müller, Sven Dähne, and Pieter-Jan Kindermans. innvestigate neural networks! Journal of Machine Learning Research, 20(93): 1–8, 2019. URL http://jmlr.org/papers/v20/18-540.html.
[27] Haofan Wang, Zifan Wang, Mengnan Du, Fan Yang, Zijian Zhang, Sirui Ding, Piotr Mardziel, and Xia Hu. Score-cam: Score-weighted visual explanations for convolutional neural networks. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition Workshops, pages 24–25, 2020.
[28] Sandra Wachter, Brent Mittelstadt, and Chris Russell. Counterfactual explanations without opening the black box: Automated decisions and the gdpr. Harv. JL & Tech., 31:841, 2017.
11

A Experiment Details

Model architecture and hyperparameters. For all results in the Experiments section, we trained separate convolutional neural networks for different types of model reasoning, but kept the same architecture for the same type. For simple reasoning, we have three convolutional layers (32 ﬁlters, kernel-size 3, stride (2,2); 64 ﬁlters, kernel-size 3, stride (2,2); 64 ﬁlters, kernel-size 3, stride (2,2)), followed by two fully-connected layers (200 units; 2 units), all with ReLU activation functions except for the output layer. For complex reasoning, to account for the more complex feature relationships encoded in the dataset (lower number of parameters for the model could not achieve near-perfect accuracy on these datasets) we have four convolutional layers (64 ﬁlters, kernel-size 3, stride (2,2); 128 ﬁlters, kernel-size 3, stride (2,2); 256 ﬁlters, kernel-size 3, stride (2,2); 64 ﬁlters, kernel-size 3, stride (2,2)), followed by three fully-connected layers (200 units; 200 units; 2 units), all with ReLU activation functions except for the output layer.
Learning rate was set as 0.0001, trained with Adam optimizer minimizing the binary cross entropy loss, with maximum epoch of 10. No particular grid search on these hyperparameters was performed, but the models were still trained up to near-perfect accuracy for each model reasoning within several runs with different initializations. SMERF does not require much computational load; the entire pipeline was effectively tested out on a machine with a single GPU (GTX 1070). More details on the model and training is available in the source code.
Dataset details. The model was trained on a different number of training data points, based on the number of buckets available to the dataset, as shown below in Table 2. Validation was done with separate unseen data points sampled from the same distribution. The model was trained so that it achieves near-perfect (above 99 percent) training and validation accuracy.

Dataset

Bucket no Training Training/bucket Validation Validation/bucket

Simple-FR

12

24000

2000

6000

500

Simple-NR

8

16000

2000

4000

500

Complex-FR

12

36000 2000 or 6000

6000

500

Complex-CR1 ∼ 4

10

150000

15000

4000

400

Table 2: Number of training and validation data points used for experiments for each model reasoning.

The total number of data points depend on how many points were sampled from each bucket,

accounting for a potential class imbalance between positive and negative samples.

TextBox dataset was generated by sampling a random vector, each element indicating a speciﬁc feature the image should exhibit. The features included: the type of Text, x-axis location of the Text, y-axis location of the Text, color of the character, the background color, existence of Box1 and/or Box2. The resulting images have a dimension of 64-by-64 with three color channels. The pixel values were scaled to be between 0 and 1.
Saliency Methods. We mostly used methods as implemented in iNNvestigate6 library [26]. For methods that are not in the library, we used the existing implementations for Grad-CAM7 and DeepSHAP8 and integrated them into the analysis. The details of the hyperparameters used for these methods are all available in the source code, under smerf/explanations.py ﬁle. No particular grid search was performed for these hyperparameters.
B Additional Experimental Results
B.1 Results with IOU Metric
In addition to our main results presented with AFL values, we also measure the effectiveness of saliency methods with a more popular metric in the ﬁeld: Intersection-Over-Union (IOU) metric, which is a ratio of the intersecting area to the union area of the 0-1 masked feature attribution and the ground-truth feature attribution. The ground-truth feature attributions are predeﬁned from the
6https://github.com/albermax/innvestigate 7https://github.com/wawaku/grad-cam-keras 8https://github.com/slundberg/shap

12

the higher the better

Simple-FR

the lower the better

Primary ISOimUp(fleorRDeiaffseorneinntgBuckets)
1.0 0.8 0.6 0.4

1.0 SecondarySiImOUpl(efoRreDaisfofenrienngt Bucke(FtRs)) Text o

PIOU

SIOU

0.8

(FR) Text x

0.8

0.15

(NR) Box1 o

0.6

0.6

(NR) Box1 x

0.10

0.5 threshold 0.4

0.4

average

0.2

0.05

0.2

0.2

0.0

0.00

0.0

0.0

0.6

0.15

1 obj

2 obj

0.4

0.10

3 obj

Simple-NR

0.2

0.05

0.0

0.00

SmoGortahdGireantd GuidedDeBcaocknvprnoetp InputD*eeGrpaTdaiyelnotr Integrated GradLiRePn-tsZ LRP-LPrReP-sEetpAsilFloant DeepLIFLT-RPR-ePvreeasleCtaBnFlcaetl DeepLIFGTr-aRde-sCcAalMe
DeReapnSdHoAPm Edge-detection

SmoGortahdGireantd GuidedDeBcaocknvprnoetp InputD*eeGrpaTdaiyelnotr Integrated GradLiRePn-tsZ LRP-LPrReP-sEetpAsilFloant DeepLIFLT-RPR-ePvreeasleCtaBnFlcaetl DeepLIFGTr-aRde-sCcAalMe
DeReapnSdHoAPm Edge-detection

(a) PIOU and SIOU for Simple Reasoning

(b) PIOU and SIOU based on the number of objects in the image (xaxis is the same as Figure 10a)

Figure 10: (a) PIOU (left) and SIOU (right) for Simple-FR and Simple-NR from Table 1. The black vertical lines indicate the standard deviation across different buckets. The dotted horizontal line is the correctness threshold of 0.5. Most methods perform well on average, with reasonable PIOU and low SIOU, except for a few methods on the left. (b) There is not much difference between the PIOU and SIOU values based on the number of objects in the image.

PrimaryCIoOmUp(lfeoxr DRiefafesroennitngBuckets)
1.0 0.8 0.6 0.4 0.2 0.0

the lower the better

SecondarCyoImOUple(fxorRDeaifsfeorneinngt Buckets)

1.0 (CR2) Box1 o, Box2 x

0.8

(CR2) Box1 x, Box2 o

0.6

(CR2) Box1 o, Box2 o

0.5 threshold

0.4

average

0.2

0.0

(higherItOheU better)

Min1i.m0 um PIOU Across Buckets

Simple Reasonig

0.8

Complex Reasoning 0.5 threshold

0.6

0.4

0.2

0.0

SmoGortahdGireantd GuidedDeBcaocknvprnoetp InputD*eeGrpaTdaiyelnotr Integrated GradLiRePn-tsZ LRP-LPrReP-sEetpAsilFloant DeepLIFLT-RPR-ePvreeasleCtaBnFlcaetl DeepLIFGTr-aRde-sCcAalMe
DeReapnSdHoAPm Edge-detection

SmoGortahdGireantd GuidedDeBcaocknvprnoetp InputD*eeGrpaTdaiyelnotr Integrated GradLiRePn-tsZ LRP-LPrReP-sEetpAsilFloant DeepLIFLT-RPR-ePvreeasleCtaBnFlcaetl DeepLIFGTr-aRde-sCcAalMe
DeReapnSdHoAPm Edge-detection

(a) PIOU and SIOU for Complex Reasoning

(b) Minimum PIOU across buckets on simple (blue circle) vs. complex (red x) reasoning (x-axis is the same as Figure 11a).

Figure 11: (a) PIOU and SIOU for complex reasoning. Average performance on PIOU is mostly lower than 0.5, with worse performance compared to the results from simple reasoning. (b) Worst-case buckets show worse PIOU values in complex reasoning, which results in higher variance for the performance.

the higher the better

data generation process (by the ground-truth model reasoning). The 0-1 masked feature attribution from the saliency methods is obtained by ﬁrst blurring the original feature attribution, followed by thresholding the pixel intensity to select top-K pixels, where K is equal to the number of pixels that correspond to the primary object. Given the 0-1 masked feature attribution and the ground-truth feature attribution, we compute two types of IOU values just like AFL: (1) primary IOU (PIOU), which measures how much of the 0-1 masked feature attribution overlaps with the ground-truth for the region relevant to the model prediction; and (2) secondary IOU (SIOU), which measures the same value with respect to the region not relevant to the model prediction. Just like AFLs, PIOU should be high and SIOU should be low for methods that are more effective and correct. Throughout this section we use the threshold value of 0.5 to roughly distinguish good and bad performance in terms of IOU as commonly done in practice [17, 18].
Figure 10a shows PIOU and SIOU values for simple reasoning settings. Note that most methods achieve PIOU higher than 0.5, just like the results from AFL. SIOU values are mostly low throughout, even lower than what we observed from AFL. However, we notice that the IOU values are not capturing the unexpected variation of level of focus given to multiple objects based on how saturated the images are, unlike what we observed from AFLs (Figure 10b).
Figure 11a shows the PIOU and SIOU values for complex reasoning settings. In this case, all methods score PIOU below 0.5 correctness threshold, just like AFL. Also the minimum PIOU across different
13

Figure 12: Image samples from buckets where minimum PAFL values are recorded for different methods (marked with red), for FR-Simple. The ground-truth is to focus on Box1 only.
buckets from complex reasoning is strictly lower than those from simple reasoning for all methods (Figure 11b). The general trend of methods being reasonably good for simple reasoning and being bad for complex reasoning still is observable using IOU However, we notice that the SIOU values remain relatively low for both cases despite the decrease in PIOU for complex reasoning. This is where the aforementioned limitation of IOU metric in Section 4 is exposed, where it is difﬁcult to clearly deduce where the change in the values are coming from, contrary to what we observe from AFL.
IOU metric is relatively more generous to primary objects due to the way they are thresholded and it is more prone to ignoring potential non-trivial signals from objects that are not primary. This naturally leads to low SIOU values and a lack of clear relationship between primary and secondary metric: an increase in one would not necessarily imply a decrease in another, and vice-versa. In addition, the loss of information from the attribution values makes it difﬁcult to better understand why one value decreased and how much of that change could be attributed to different objects in the image. Due to these limitations, we present AFL results in the main text for better insights and highlighting the shortcomings of the methods in different settings.
B.2 Qualitative Results
Figure 12 and 13 show samples from simple reasoning (each from Simple-FR and Simple-NR) in buckets where the methods record the lowest PAFL (indicated with red). For instance, in Simple-FR setup (Figure 12) almost all methods achieve the lowest PAFL on the bucket where all features are present (top panel). Recall that Simple-FR has the model rely fully on Box1; however we observe that several methods highlight all objects that are present in the image to a certain degree. Such tendency explains the unexpected variation of AFL based on the number of objects present in the image. Nevertheless, some minimum PAFL values are still above 0.5 for a method like LRP-Epsilon, which makes it the most effective method for Simple-FR that is less prone to errors (it also correctly
14

Figure 13: Image samples from buckets where minimum PAFL values are recorded for different methods (marked with red, along with corresponding PAFL values), for NR-Simple. The ground-truth is to focus on the Text only.
focuses on Box1 without being distracted by other objects in the image). Compared to Simple-FR, Simple-NR shows less one-sided distribution of buckets with minimum PAFL values (Figure 13). In Figure 14 we have the samples from buckets with minimum PAFL for complex reasoning setup, in particular, Complex-CR2. This time most of the cases with minimum performance is concentrated on the bucket with Box1 and Text B (top panel; 13 out of 15 methods have minimum PAFL on this bucket). Recall that for this bucket, the ground-truth feature attribution should highlight just Box1. For most of the methods, more focus is given to the Text, which results in a particularly low PAFL across all methods. Notice that all the values are below 0.5: the worst-case performance of the methods on complex reasoning setup is much worse than simple reasoning setup as we have observed before.
B.3 Per-Bucket Performance Variation for Complex Reasoning
In Figure 15, we show additional details from different types of complex reasoning that show high variance of PAFL and SAFL we observed from Figure 8a. From top to bottom, we plot the variation of the values per bucket for Complex-CR1, Complex-CR3, Complex-CR4, and Complex-FR, in addition to the results from Complex-CR2 reported in the main text. We similarly observe that the variation is quite extreme for different buckets.
B.4 Failure case analysis with MAFL
While the AFL may be more suited to give a high-level understanding of the methods’ performance, to further understand the degree to which the model focuses more on the incorrect region compared to the correct region (i.e. to identify failure due to wrong focus), we also compute the mean of the attribution values inside the relevant (which we call Primary Mean-AFL, or PMAFL) and irrelevant
15

Figure 14: Image samples from buckets where minimum PAFL values are recorded for different methods (marked with red), for CR-Complex2. The ground-truth is to focus on the Box1 and Box2 if Box1 is present, otherwise on Text.
(which we call Secondary Mean-AFL, or SMAFL) regions for comparison. For a successful method, primary MAFL should always upper bound secondary MAFL because on average the correct regions should always be assigned higher attribution values compared to the incorrect regions. In this analysis, the actual values of primary and secondary MAFL do not matter; only a relative comparison does. Figure 16 plots MAFL value comparison for different buckets in FR and NR. It is important that the blue line (PMAFL) should always upper-bound the red line (SMAFL). While that is the case for FR for all buckets, there are occasional cases in NR with the opposite relationship for certain methods. Although the gap between the values are not big, this still indicates that the feature attribution may sometimes be wrongly focusing on irrelevant regions of the image more than the correct ones. Such failure cases have not been actively discussed in previous works that dealt models with simple reasoning [19, 20]. As further shown in Figure 17 it is observed that the gap between PMAFL (blue) and SMAFL (red) is bigger for some buckets in complex reasoning compared to the simple reasoning case in Figure 16. Such large gaps clearly demonstrate and verify the method’s more frequent failure due to wrong focus from complex reasoning.
C Identiﬁability problem samples
More samples that illustrate the difﬁculty of clearly distinguishing model reasoning based on the feature attributions (i.e. identiﬁability) are provided in Figure 18. Along with Integrated Gradients example in the main text (Figure 9), all other methods including the ones presented here (Gradients, LRP-Z, DeepLIFT) also tend to highlight all objects in the image up to a certain level regardless of the precise model reasoning used.
16

Figure 15: Additional information for the variance of PAFL and SAFL for complex reasoning (from top to bottom, Complex-CR1, Complex-CR3, Complex-CR4, Complex-FR). The performance varies signiﬁcantly from bucket to bucket, just as we described in the main text.
17

SmoGortahdGireandt GuidedDBecaocnkpvnroept InputD*eGepraTdaiyelnotr Integrated GradLiRePn-tZs LRP-LPRrePs-EeptAsFilolant DeepLIFLTR-RP-ePvreeasleCtaBnFclaetl DeepLIFGTr-aRde-sCcAaMle
DeReapnSdHoAmP Edge-detection

the higher the better

SmoGortahdGireandt GuidedDBecaocnkpvnroept InputD*eGepraTdaiyelnotr Integrated GradLiRePn-tZs LRP-LPRrePs-EeptAsFilolant DeepLIFLTR-RP-ePvreeasleCtaBnFclaetl DeepLIFGTr-aRde-sCcAaMle
DeReapnSdHoAmP Edge-detection

0.0

0.2

0.4

the lower the better

0.6

0.8

0.5 threshold

(ComplexFR) Box1 x, Box2 o (ComplexFR) Box1 o, Box2 o

1.0 PrimaryCAoFmLp(lfeoxr DRiefafesroennitngBuckets)
0.8 0.6 0.4 0.2 0.0

(ComplexFR) Box1 o, Box2 x

(ComplexFR) Box1 x, Box2 x

1.0 SecondarCyoAmFpLle(fxorRDeaifsfeorneinngt Buckets)

SmoGortahdGireandt GuidedDBecaocnkpvnroept InputD*eGepraTdaiyelnotr Integrated GradLiRePn-tZs LRP-LPRrePs-EeptAsFilolant DeepLIFLTR-RP-ePvreeasleCtaBnFclaetl DeepLIFGTr-aRde-sCcAaMle
DeReapnSdHoAmP Edge-detection

the higher the better

SmoGortahdGireandt GuidedDBecaocnkpvnroept InputD*eGepraTdaiyelnotr Integrated GradLiRePn-tZs LRP-LPRrePs-EeptAsFilolant DeepLIFLTR-RP-ePvreeasleCtaBnFclaetl DeepLIFGTr-aRde-sCcAaMle
DeReapnSdHoAmP Edge-detection

0.0

0.2

0.4

the lower the better

0.6

0.8

0.5 threshold

(CR4) Text A, Box1 o (CR4) Text B, Box1 o

1.0 PrimaryCAoFmLp(lfeoxr DRiefafesroennitngBuckets)
0.8 0.6 0.4 0.2 0.0

(CR4) Text B, Box1 x

(CR4) Text A, Box1 x

1.0 SecondarCyoAmFpLle(fxorRDeaifsfeorneinngt Buckets)

SmoGortahdGireandt GuidedDBecaocnkpvnroept InputD*eGepraTdaiyelnotr Integrated GradLiRePn-tZs LRP-LPRrePs-EeptAsFilolant DeepLIFLTR-RP-ePvreeasleCtaBnFclaetl DeepLIFGTr-aRde-sCcAaMle
DeReapnSdHoAmP Edge-detection

the higher the better

SmoGortahdGireandt GuidedDBecaocnkpvnroept InputD*eGepraTdaiyelnotr Integrated GradLiRePn-tZs LRP-LPRrePs-EeptAsFilolant DeepLIFLTR-RP-ePvreeasleCtaBnFclaetl DeepLIFGTr-aRde-sCcAaMle
DeReapnSdHoAmP Edge-detection

0.0

0.2

0.4

the lower the better

0.6

0.8

0.5 threshold

(CR3) Text A, Box2 o (CR3) Text B, Box2 o

1.0 PrimaryCAoFmLp(lfeoxr DRiefafesroennitngBuckets)
0.8 0.6 0.4 0.2 0.0

(CR3) Text B, Box2 x

(CR3) Text A, Box2 x

1.0 SecondarCyoAmFpLle(fxorRDeaifsfeorneinngt Buckets)

SmoGortahdGireandt GuidedDBecaocnkpvnroept InputD*eGepraTdaiyelnotr Integrated GradLiRePn-tZs LRP-LPRrePs-EeptAsFilolant DeepLIFLTR-RP-ePvreeasleCtaBnFclaetl DeepLIFGTr-aRde-sCcAaMle
DeReapnSdHoAmP Edge-detection

the higher the better

SmoGortahdGireandt GuidedDBecaocnkpvnroept InputD*eGepraTdaiyelnotr Integrated GradLiRePn-tZs LRP-LPRrePs-EeptAsFilolant DeepLIFLTR-RP-ePvreeasleCtaBnFclaetl DeepLIFGTr-aRde-sCcAaMle
DeReapnSdHoAmP Edge-detection

0.0

0.2

0.4

the lower the better

0.6

0.8

(CR1) Box1 o, Box2 o 0.5 threshold

1.0 PrimaryCAoFmLp(lfeoxr DRiefafesroennitngBuckets)
0.8 0.6 0.4 0.2 0.0

(CR1) Box1 x, Box2 o

(CR1) Box1 o, Box2 x

1.0 SecondarCyoAmFpLle(fxorRDeaifsfeorneinngt Buckets)

( ) vs (■) FR

( ) vs (A) ( ) vs (A,■)

( ) vs (B) ( ) vs (B,■)

(䡧) vs ( )

(䡧) vs (■) (䡧) vs (A) (䡧) vs (A,■) (䡧) vs (B) (䡧) vs (B,■)

(A) vs ( )

(B) vs ( )

(A) vs (䡧)

(B) vs (䡧)

(A) vs (■)

(B) vs (■)

(A) vs (䡧,■)

(B) vs (䡧,■)

NR

Figure 16: MAFL value comparison within buckets for simple reasoning with FR and NR. Title of each panel indicates the bucket with “( correct feature ) vs ( incorrect feature )”, and the blue and red lines show the general trend of primary and secondary MAFL values across different methods (x-axis being the same as Figure 6a, omitted for brevity). Primary MAFL should ideally always upper-bound secondary MAFL: while that is the case for FR, there are occasional failure cases in NR where the opposite happens.

( ) vs (A)

FR

(A) vs ( )

CR1 CR2

(A) vs ( )

( ) vs (A) CR3

( ) vs (A) CR4

( ) vs (A,■)

( ) vs (B)

( ) vs (B,■) (䡧,■) vs ( ) ( ) vs (A,䡧) (䡧,■) vs (A) ( ) vs (B,䡧) (䡧,■) vs (B)

(B) vs ( )

(A) vs (䡧)

(B) vs (䡧)

(■) vs ( )

(■) vs (A)

(■) vs (B)

(■,䡧) vs ( ) (■,䡧) vs (A) (■,䡧) vs (B)

(B) vs ( )

(䡧) vs ( )

(䡧) vs (A)

(䡧) vs (B)

(A) vs (■)

(B) vs (■)

(■,䡧) vs ( ) (■,䡧) vs (A) (■,䡧) vs (B)

( ) vs (B)

(䡧) vs ( ) (䡧) vs (A)

(䡧) vs (B)

(■,A) vs ( ) (■,B) vs ( ) (■,A) vs (䡧) (■,B) vs (䡧)

( ) vs (B)

(䡧,A) vs ( ) (䡧,B) vs ( )

(■) vs ( )

(■) vs (A)

(■) vs (B) (䡧,A) vs (■) (䡧,B) vs (■)

Figure 17: MAFL values for complex reasoning. While PMAFL (blue) should be always bigger than SMAFL (red), some buckets exhibit much larger SMAFL. This means the methods are failing due to focusing signiﬁcantly more on irrelevant regions features than relevant ones.

18

Figure 18: Identiﬁability problem samples from more methods. All methods highlight all objects in the image up to certain degree regardless of the model reasoning, making it difﬁcult for the users to clearly distinguish among different types of model reasoning used.
19

