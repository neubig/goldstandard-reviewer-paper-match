arXiv:1005.4178v2 [cs.IT] 20 Jan 2011

Optimal Exact-Regenerating Codes for Distributed Storage at the MSR and MBR Points via a Product-Matrix Construction
K. V. Rashmi, Nihar B. Shah, and P. Vijay Kumar, Fellow, IEEE
Abstract
Regenerating codes are a class of distributed storage codes that optimally trade the bandwidth needed for repair of a failed node with the amount of data stored per node of the network. Minimum Storage Regenerating (MSR) codes minimize ﬁrst, the amount of data stored per node, and then the repair bandwidth, while Minimum Bandwidth Regenerating (MBR) codes carry out the minimization in the reverse order. An [n, k, d] regenerating code permits the data to be recovered by connecting to any k of the n nodes in the network, while requiring that repair of a failed node be made possible by connecting (using links of lesser capacity) to any d nodes. Previous, explicit and general constructions of exact-regenerating codes have been conﬁned to the case n = d + 1.
In this paper, we present optimal, explicit constructions of MBR codes for all feasible values of [n, k, d] and MSR codes for all [n, k, d ≥ 2k − 2], using a product-matrix framework. The particular product-matrix nature of the constructions is shown to signiﬁcantly simplify system operation. To the best of our knowledge, these are the ﬁrst constructions of exact-regenerating codes that allow the number n of nodes in the distributed storage network, to be chosen independent of the other parameters.
The paper also contains a simpler description, in the product-matrix framework, of a previously constructed MSR code in which the parameter d satisﬁes [n = d + 1, k, d ≥ 2k − 1].
I. INTRODUCTION
In a distributed storage system, information pertaining to a data ﬁle (the message) is dispersed across nodes in a network in such a manner that an end-user can retrieve the data stored by tapping into a subset of the nodes. A popular option that reduces network congestion and that leads to increased resiliency in the face of node failures, is to employ erasure coding, for example by calling upon maximum-distance-separable (MDS) codes such as ReedSolomon (RS) codes. Let B be the total ﬁle size measured in terms of symbols over a ﬁnite ﬁeld Fq of size q. With RS codes, data is stored across n nodes in the network in such a way that the entire message can be recovered by a data collector by connecting to any k nodes, a process that we will refer to as data-reconstruction. Several distributed storage systems such as RAID-6 [1], OceanStore [2] and Total Recall [3] employ such an erasure-coding option.
A. Regenerating Codes
Upon failure of an individual node, a self-sustaining data-storage network must necessarily possess the ability to regenerate (i.e., repair) a failed node. An obvious means to accomplish this is to permit the replacement node to connect to any k nodes, download the entire message, and extract the data that was stored in the failed node. But downloading the entire B units of data in order to recover the data stored in a single node that stores only a fraction of the entire message is wasteful, and raises the question as to whether there is a better option. Such an option is indeed available and provided by the concept of a regenerating code introduced in the pioneering paper by Dimakis et al. [4].
K. V. Rashmi, Nihar B. Shah and P. Vijay Kumar are with the Department of Electrical Communication Engineering, Indian Institute of Science, Bangalore-560012, India (email: {rashmikv,nihar,vijay}@ece.iisc.ernet.in). P. Vijay Kumar is also an adjunct faculty member of the Electrical Engineering Systems Department at the University of Southern California, Los Angeles, CA 90089-2565.

2

Conventional RS codes treat each fragment stored in a node as a single symbol belonging to the ﬁnite ﬁeld Fq. It can be shown that when individual nodes are restricted to perform only linear operations over Fq, the total amount of data download needed to repair a failed node, can be no smaller than B, the size of the entire ﬁle. In contrast, regenerating codes are codes over a vector alphabet and hence treat each fragment as being comprised of α symbols over the ﬁnite ﬁeld Fq. Linear operations over Fq in this case, permit the transfer of a fraction of the data stored at a particular node. Apart from this new parameter α, two other parameters d and β are associated with regenerating codes. Under the deﬁnition of regenerating codes introduced in [4], a failed node is permitted to connect to an arbitrary set of d of the remaining nodes while downloading β ≤ α symbols from each node. This process is termed as regeneration and the total amount dβ of data downloaded for repair purposes as the repair bandwidth. Further, the set of d nodes aiding in the repair are termed as helper nodes. Typically, with a regenerating code, the average repair bandwidth is small compared to the size of the ﬁle B.

It will be assumed throughout the paper, that whenever mention is made of an [n, k, d] regenerating code, the

code is such that k and d are the minimum values under which data-reconstruction and regeneration can always be

guaranteed. This restricts the range of d to

k≤d≤n−1 .

(1)

The ﬁrst inequality arises because if the regeneration parameter d were less than the data-reconstruction parameter k then one could, in fact, reconstruct data by connecting to any d < k nodes (treating the data stored in every other node as a function of that stored in these d nodes) thereby contradicting the minimality of k. Finally, while a regenerating code over Fq is associated with the collection of parameters

{n, k, d, α, β, B} ,

it will be found more convenient to regard parameters {n, k, d} as primary and {α, β, B} as secondary and thus we will make frequent references in the sequel, to a code with these six parameters as an [n, k, d] regenerating code having parameter set (α, β, B).

B. Cut-Set Bound and the Storage vs Repair-Bandwidth Tradeoff

A major result in the ﬁeld of regenerating codes is the proof in [5] that uses the cut-set bound of network coding to establish that the parameters of a regenerating code must necessarily satisfy :

k−1

B≤

min{α, (d − i)β} .

(2)

i=0

It is desirable to minimize both α as well as β since, minimizing α results in a minimum storage solution, while minimizing β (for ﬁxed d) results in a storage solution that minimizes repair bandwidth. As can be deduced from (2), it is not possible to minimize both α and β simultaneously and thus there is a tradeoff between choices of the parameters α and β. The two extreme points in this tradeoff are termed the minimum storage regeneration (MSR) and minimum bandwidth regeneration (MBR) points respectively. The parameters α and β for the MSR point on the tradeoff can be obtained by ﬁrst minimizing α and then minimizing β to obtain

B α= ,
k

B

β=

.

(3)

k(d − k + 1)

Reversing the order, leads to the MBR point which thus corresponds to

2B

β=

,

k(2d − k + 1)

2dB

α=

.

(4)

k(2d − k + 1)

We deﬁne an optimal [n, k, d] regenerating code as a code with parameters (α, β, B) satisfying the twin

3
requirements that 1) the parameter set (α, β, B) achieves the cut-set bound with equality and 2) decreasing either α or β will result in a new parameter set that violates the cut set bound.
An MSR code is then deﬁned as an [n, k, d] regenerating code whose parameters (α, β, B) satisfy (3) and similarly, an MBR code as one with parameters (α, β, B) satisfying (4). Clearly, both MSR and MBR codes are optimal regenerating codes.

C. Striping of Data

The nature of the cut-set bound permits a divide-and-conquer approach to be used in the application of optimal regenerating codes to large ﬁle sizes, thereby simplifying system implementation. This is explained below.

Given an optimal [n, k, d] regenerating code with parameter set (α, β, B), a second optimal regenerating code

with parameter set (α = δα, β = δβ, B = δB) for any positive integer δ can be constructed, by dividing the δB

message symbols into δ groups of B symbols each, and applying the (α, β, B) code to each group independently.

Secondly, a common feature of both MSR and MBR regenerating codes is that in either case, their parameter set

(α, β, B)

is

such

that

both

α

and

B

are

multiples

of

β

and

further

that

αβ ,

B β

are

functions

only

of

n,

k

and

d.

It

follows that if one can construct an (optimal) [n, k, d] MSR or MBR code with β = 1, then one can construct

an (optimal) [n, k, d] MSR or MBR code for any larger value of β. In addition, from a practical standpoint,

a code constructed through concatenation of codes for a smaller β will in general, be of lesser complexity (see

Section VI-C). For these reasons, in the present paper we design codes for the case of β = 1. Thus, throughout

the remainder of the paper, we will assume that β = 1. In the terminology of distributed storage, such a process

is called striping.

We document below the values of α and B of MSR and MBR codes respectively, when β = 1:

α = d−k+1 ,

(5)

B = k(d − k + 1)

(6)

for MSR codes and

α = d,

(7)

k

B = kd −

(8)

2

in the case of MBR codes.

D. Additional Terminology
a) Exact versus Functional Regeneration: In the context of a regenerating code, by functional regeneration of a failed node f , we will mean, replacement of the failed node by a new node f in such a way that following replacement, the resulting network of n nodes continues to possess the data-reconstruction and regeneration properties. In contrast, by exact-regeneration, we mean replacement of a failed node f by a replacement node f that stores exactly the same data as was stored in node f . We will use the term exact-regenerating code to denote a regenerating code that has the capability of exactly regenerating each instance of a failed node. Clearly where it is possible, an exact-regeneration code is to be preferred over a functional-regeneration code since, under functional regeneration, there is need for the network to inform all nodes in the network of the replacement, whereas this is clearly unnecessary under exact-regeneration.
b) Systematic Regenerating Codes: A systematic regenerating code can be deﬁned as a regenerating code designed in such a way that the B message symbols are explicitly present amongst the kα code symbols stored in a select set of k nodes, termed as the systematic nodes. Clearly, in the case of systematic regenerating codes, exact-regeneration of (the systematic portion of the data stored in) the systematic nodes is mandated.

4
c) Linear Regenerating Codes: A linear regenerating code is deﬁned as a regenerating code in which
1) the code symbols stored in each node are linear combinations over Fq of the B message symbols {ui}Bi=1, 2) the symbols passed by a helper node h to aid in the regeneration of a failed node f are linear over Fq in the
α symbols stored in node h.
It follows as an easy consequence, that linear operations sufﬁce for a data collector to recover the data from the kα code symbols stored in the k nodes that it has connected to. Similarly, the replacement node for a failed node f , performs linear operations on the d symbols passed on to it by the d helper nodes {hi}di=1 aiding in the regeneration.
E. Results of the Present Paper
While prior work is described in greater detail in Section II, we begin by providing a context for the results presented here.
Background: To-date, explicit and general constructions for exact-regenerating codes at the MSR point have been found only for the case [n = d + 1, k, d ≥ 2k − 1]. Similarly at the MBR point, the only explicit code to previously have been constructed is for the case d = n − 1. Thus, all existing code constructions limit the total number of nodes n in the system to d + 1. This is restrictive since in this case, the system can handle only a single node failure at a time. Also, such a system does not permit additional storage nodes to be brought into the system.
A second open problem in this area that has recently drawn attention is as to whether or not the storage-repair bandwidth tradeoff is achievable under the additional requirement of exact-regeneration. It has previously been shown that the MSR point is not achievable for any [n, k, d ≤ 2k − 3] with β = 1, but is achievable for all parameters [n, k, d] when B (and hence β as well) is allowed to approach inﬁnity.
Results Presented in Present Paper: In this paper, (optimal) explicit constructions of exact-regenerating MBR codes for all feasible values of [n, k, d] and exact-regenerating MSR codes for all [n, k, d ≥ 2k −2] are presented. The constructions are of a product-matrix nature that is shown to signiﬁcantly simplify operation of the distributed storage network. The constructions presented prove that the MBR point for exact-regeneration can be achieved for all values of the parameters and that the MSR point can be achieved for all parameters satisfying d ≥ 2k − 2. In both constructions, the message size is as dictated by cut-set bound. The paper also contains a simpler description, in the product-matrix framework, of an MSR code for the parameters [n = d+1, k, d ≥ 2k −1] that was previously constructed in [6], [7].
A brief overview of prior work in this ﬁeld is provided in the next section, Section II. The product-matrix framework underlying the code construction is described in Section III. An exact-regenerating MBR code for all feasible values of the parameters [n, k, d] is presented in Section IV, and an exact-regenerating MSR code for all [n, k, d ≥ 2k − 2] is presented in Section V. Implementation advantages of the particular product-matrix nature of the code constructions provided here are described in Section VI. The ﬁnal section, Section VII, draws conclusions. Appendix A contains a simpler description, in the product-matrix framework, of an MSR code with parameter d satisfying [n = d + 1, k, d ≥ 2k − 1], that was previously constructed in [6], [7].
II. PRIOR WORK
The concept of regenerating codes was introduced in [4], where it was shown that permitting the storage nodes to store more than B/k units of data helps in reducing the repair bandwidth. Several distributed systems were analyzed, and estimates of the mean node availability in such systems obtained. Using these values, it was shown through simulation, that regenerating codes can reduce repair bandwidth compared to other designs, while simplifying system architecture.
The problem of minimizing repair bandwidth for functional repair of a failed storage node is considered in [4], [5]. Here, the evolution of the storage network through a sequence of failures and regenerations is represented as a network, with all possible data collectors represented as sinks. The data-reconstruction requirement is formulated as a multicast network coding problem, with the network having an inﬁnite number of nodes. The cut-set analysis of

5

this network leads to the relation between the parameters of a regenerating code given in equation (2). It can be seen that there is a tradeoff between the choice of the parameters α and β for a ﬁxed B and this is termed as the storagerepair bandwidth tradeoff. It has been shown ([5], [8]) that this tradeoff is achievable under functional-regeneration. However, the coding schemes suggested are not explicit and require large ﬁeld size. The journal version [9] also contains a handcrafted functional-regenerating code for the MSR point with [n = 4, k = 2, d = 3].
A study of the computational complexity of regenerating codes is carried out in [10], in the context of random linear regenerating codes that achieve functional repair.
The problem of exact-regeneration was ﬁrst considered independently in [11], [12] and [13]. In [11], it is shown that the MSR point is achievable under exact-regeneration when (k = 2, d = n − 1). The coding scheme proposed is based on the concept of interference alignment developed in the context of wireless communication. However, the construction is not explicit and has a large ﬁeld size requirement. In [13], the authors carry out a computer search to ﬁnd exact-regenerating codes at the MSR point, resulting in identiﬁcation of codes with parameters [n = 5, k = 3, d = 4].
The ﬁrst, explicit construction of regenerating codes for a general set of parameters was provided for the MBR point in [12] with d = n − 1 and arbitrary k. These codes have low regeneration complexity as no computation is involved during the exact-regeneration of a failed node. The ﬁeld size required is of the order of n2. In addition [12] (see also [14]) also contains the construction of an explicit MSR code for d = k + 1, that performs approximatelyexact-regeneration of all failed nodes, i.e., regeneration where a part of the code is exactly regenerated, and the remaining is functionally regenerated (it is shown subsequently in [6], [14] that exact-regeneration is not possible, when k > 4, for the set of parameters considered therein).
MSR codes performing a hybrid of exact and functional-regeneration are provided in [15], for the parameters d = k + 1 and n > 2k. The codes given even here are non-explicit, and have high complexity and large ﬁeld-size requirement.
A code structure that guarantees exact-regeneration of just the systematic nodes is provided in [6], for the MSR point with parameters [n = d + 1, k, d ≥ 2k − 1]. This code makes use of interference alignment, and is termed as the ‘MISER’ code in journal-submission version [14] of [6]. Subsequently, it was shown in [7] that for this set of parameters, the code introduced in [6] for exact-regeneration of only the systematic nodes can also be used to repair the non-systematic (parity) node failures exactly provided repair construction schemes are appropriately designed. Such an explicit repair scheme is indeed designed and presented in [7]. The paper [7] also contains an exact-regenerating MSR code for parameter set [n = 5, k = 3, d = 4].
A proof of non-achievability of the cut-set bound on exact-regeneration at the MSR point, for the parameters [n, k, d < 2k − 3] when β = 1, is provided in [14]. On the other hand, the MSR point is shown to be achievable in the limiting case of B approaching inﬁnity (i.e., β approaching inﬁnity) in [16], [17].
A ﬂexible setup for regenerating codes is described in [18], where a data collector (or a replacement node) can perform data-reconstruction (or regeneration) irrespective of the number of nodes to which it connects, provided the total data downloaded exceeds a certain threshold.
In [19], the authors establish that essentially all points on the interior of the tradeoff (i.e., points other than MSR and MBR) are not achievable under exact-regeneration.

III. THE COMMON PRODUCT-MATRIX FRAMEWORK

The constructions described in this paper, follow a common product-matrix framework. Under this framework, each codeword in the distributed storage code can be represented by an (n × α) code matrix C whose ith row cti contains the α symbols stored by the ith node. Each code matrix is the product

C = ΨM

(9)

of an (n × d) encoding matrix Ψ and an (d × α) message matrix M . The entries of the matrix Ψ are ﬁxed a priori
and are independent of the message symbols. The message matrix M contains the B message symbols, with some symbols possibly repeated. We will refer to the ith row ψt of Ψ as the encoding vector of node i as it is this vector
i

6

that is used to encode the message into the form in which it is stored within the ith node:

cti

= ψtM
i

,

(10)

where the superscript ‘t’ is used to denote the transpose of a matrix. Throughout this paper, we consider all symbols to belong to a ﬁnite ﬁeld Fq of size q.

This common structure of the code matrices leads to common architectures for both data-reconstruction and exact-regeneration, as explained in greater detail below. It also endows the codes with implementation advantages that are discussed in Section VI.

Data-reconstruction amounts to recovering the message matrix M from the kα symbols obtained from an arbitrary
set of k storage nodes. Let us denote the set of k nodes to which the data collector connects as {i1, . . . , ik}. The jth node in this set passes on the message vector ψt M to the data collector. The data collector thus obtains the
ij
product matrix
ΨDCM ,

where ΨDC is the submatrix of Ψ consisting of the k rows {i1, . . . , ik}. It then uses the properties of the matrices Ψ and M to recover the message. The precise procedure for recovering M is a function of the particular construction.

As noted above, each node in the network is associated to a distinct (d×1) encoding vector ψi. In the regeneration process, we will need to call upon a related vector µi of length α, that contains a subset of the components of ψi. To regenerate a failed node f , the node replacing the failed node connects to an arbitrary subset {h1, . . . , hd} of d storage nodes which we will refer to as the d helper nodes. Each helper node passes on the inner product of the α symbols stored in it with µf , to the replacement node: the helper node hj passes

ψt Mµ .

hj

f

The replacement node thus obtains the product matrix

ΨrepairM µf ,
where Ψrepair is the submatrix of Ψ consisting of the d rows {h1, . . . , hd}. From this it turns out, as will be shown subsequently, that one can recover the desired symbols. Here again, the precise procedure is dependent on the particular construction.
Remark 1: An important feature of the product-matrix construction presented here, is that each of the nodes hj participating in the regeneration of node f , needs only have knowledge of the encoding vector of the failed node f and not the identity of the other nodes participating in the regeneration. This signiﬁcantly simpliﬁes the operation of the system.
Systematic Codes: The following theorem shows that any linear exact-regenerating code can be converted to a systematic form via a linear remapping of the symbols. The proof of the theorem may be found in Appendix B.
Theorem 1: Any linear exact-regenerating code can be converted to a systematic form via a linear remapping of the message symbols. Furthermore, the resulting code is also linear and possesses the data-reconstruction and exact-regeneration properties of the original code.

Thus, all codes provided in the present paper can be converted to a systematic form via a linear remapping of the message symbols. Speciﬁc details on the product-matrix MBR and MSR codes in systematic form are provided in the respective sections, Sections IV and V.

IV. THE PRODUCT-MATRIX MBR CODE CONSTRUCTION
In this section, we identify the speciﬁc make-up of the encoding matrix Ψ and the message matrix M that results in an [n, k, d] MBR code with β = 1. A notable feature of the construction is that it is applicable to all feasible values of [n, k, d], i.e., all n, k, d satisfying k ≤ d ≤ n − 1. Since the code is required to be an MBR code with β = 1, it must possess the data-reconstruction and exact-regeneration properties required of a regenerating code, and in addition, have parameters {α, B} that satisfy equations (7) and (8). Equation (8) can be rewritten in the

7

form:

B=

k+1 + k(d − k) .
2

Thus the parameter set of the desired [n, k, d] MBR code is (α = d, β = 1, B = k+2 1 + k(d − k)).

Let S be a (k × k) matrix constructed so that the k+2 1 entries in the upper-triangular half of the matrix are ﬁlled

up by

k+1 2

distinct message symbols drawn from the set {ui}Bi=1. The

k 2

entries in the strictly lower-triangular

portion of the matrix are then chosen so as to make the matrix S a symmetric matrix. The remaining k(d − k)

message symbols are used to ﬁll up a second (k × (d − k)) matrix T . The message matrix M is then deﬁned as

the (d × d) symmetric matrix given by

ST

M = Tt 0 .

(11)

The symmetry of the matrix will be found to be instrumental when enabling node repair. Next, deﬁne the encoding matrix Ψ to be any (n × d) matrix of the form

Ψ= Φ ∆ ,

where Φ and ∆ are (n × k) and (n × (d − k)) matrices respectively, chosen in such a way that

1) any d rows of Ψ are linearly independent, 2) any k rows of Φ are linearly independent.

The above requirements can be met, for example, by choosing Ψ to be either a Cauchy [20] or else a Vandermonde matrix.1 As per the product-matrix framework, the code matrix is then given by C = ΨM .

The two theorems below establish that the code presented is an [n, k, d] MBR code by establishing respectively, the exact-regeneration and data-reconstruction properties of the code.

Theorem 2 (MBR Exact-Regeneration): In the code presented, exact-regeneration of any failed node can be achieved by connecting to any d of the (n − 1) remaining nodes.

Proof: Let ψt be the row of Ψ corresponding to the failed node f . Thus the d symbols stored in the failed
f

node correspond to the vector

ψt M.

(12)

f

The replacement for the failed node f connects to an arbitrary set {hj | j = 1, . . . , d} of d helper nodes. Upon being contacted by the replacement node, the helper node hj computes the inner product

ψt Mψ

hj

f

and passes on this value to the replacement node. Thus, in the present construction, the vector µf equals ψf itself. The replacement node thus obtains the d symbols ΨrepairM ψf from the d helper nodes, where

 ψt 

h1

 ψt 

Ψrepair

 =


h2
..

 .

.



ψt
hd

By construction, the (d × d) matrix Ψrepair is invertible. Thus, the replacement node recovers M ψf through multiplication on the left by Ψ−rep1air. Since M is symmetric,

t

tM ,

(13)

Mψf = ψf

and this is precisely the data previously stored in the failed node.

1Over a large ﬁnite ﬁeld, every matrix Ψ in general position will also satisfy these requirements.

8

Theorem 3 (MBR Data-Reconstruction): In the code presented, all the B message symbols can be recovered by connecting to any k nodes, i.e., the message symbols can be recovered through linear operations on the entries of any k rows of the matrix C.

Proof: Let

ΨDC = ΦDC ∆DC

(14)

be the (k × d) submatrix of Ψ, corresponding to the k rows of Ψ to which the data collector connects. Thus the data collector has access to the symbols

ΨDCM = ΦDCS + ∆DCT t ΦDCT .

(15)

By construction, ΦDC is a non-singular matrix. Hence, by multiplying the matrix ΨDCM on the left by Φ−DC1, one can recover ﬁrst T and subsequently, S.

A. An Example for the Product-Matrix MBR Code

Let n = 6, k = 3, d = 4. Then α = d = 4 and B = 9. Let us choose q = 7 so we are operating over F7. The matrices S and T are ﬁlled up by the 9 message symbols {ui}9i=1 as shown below:

u1 u2 u3

u7

S = u2 u4 u5 , T = u8 ,

(16)

u3 u5 u6

u9

so that the message matrix M is given by

u1 u2 u3 u7

M = u2 u4 u5 u8 .

(17)

u3 u5 u6 u9

u7 u8 u9 0

We choose Ψ to be the (6 × 4) Vandermonde matrix over F7 given by

1 1 1 1

1 2 4 1





1 3 2 6



Ψ=

.

(18)

1 4 2 1





1 5 4 6

1616

Fig. 1 shows at the top, the (6 × 4) code matrix C = ΨM with entries expressed as functions of the message

symbols {ui}9i=1. The rest of the ﬁgure explains how exact-regeneration of failed node 1 takes place. To regenerate node 1, the helper nodes (nodes 2, 4, 5, 6 in the example), pass on their respective inner products ψtM [1 1 1 1]t

for = 2, 4, 5, 6. The replacement node then recovers the data stored in the failed node by multiplying by Ψ−rep1air

where

1 2 4 1

1 4 2 1 Ψrepair = 1 5 4 6 (19)

1616

as explained in the proof of Theorem 2 above.

B. Systematic Version of the Code
As pointed out in Section III, any exact-regenerating code can be made systematic through a non-singular transformation of the message symbols. In the present case, there is a simpler approach, in which the matrix Ψ can

Node 1 Node 2 Node 3 Node 4 Node 5 Node 6

u1+ u2+ u3+ u7 u1+ 2u2+ 4u3+ u7 u1+ 3u2+ 2u3+ 6u7 u1+ 4u2+ 2u3+ u7 u1+ 5u2+ 4u3+ 6u7 u1+ 6u2+ u3+ 6u7

u2+ u4+ u5+ u8 u2+ 2u4+ 4u5+ u8 u2+ 3u4+ 2u5+ 6u8 u2+ 4u4+ 2u5+ u8 u2+ 5u4+ 4u5+ 6u8 u2+ 6u4+ u5+ 6u8

u3+ u5+ u6+ u9 u3+ 2u5+ 4u6+ u9 u3+ 3u5+ 2u6+ 6u9 u3+ 4u5+ 2u6+ u9 u3+ 5u5+ 4u6+ 6u9 u3+ 6u5+ u6+ 6u9

u7+ u8+ u9 u7+ 2u8+ 4u9 u7+ 3u8+ 2u9 u7+ 4u8+ 2u9 u7+ 5u8+ 4u9 u7+ 6u8+ u9

<•,1>
<•,1> <•,1> <•,1>

9
-1 1241 1421 1546 1616

Replacement Node 1

u1+ u2+ u3+ u7

u2+ u4+ u5+ u8

u3+ u5+ u6+ u9

u7+ u8+ u9

Fig. 1: An example for the MBR code construction: On failure of node 1, the replacement node downloads one
symbol each from nodes 2, 4, 5 and 6, using which node 1 is exactly regenerated. The notation < ., 1 > indicates an inner product of the stored symbols with the vector [1 1 1 1]t.

be chosen in such a way that the code is automatically systematic. We simply make the choice:

Ψ = I˜k 0˜ ,

(20)

Φ∆

where Ik is the (k × k) identity matrix, 0 is a (k × (d − k) zero matrix, Φ˜ and ∆˜ are matrices of sizes ((n − k) × k) and ((n − k) × (d − k)) respectively, such that Φ˜ ∆˜ is a Cauchy matrix2. Clearly the code is systematic. It can
be veriﬁed that the matrix Ψ has the properties listed just above Theorem 2.

V. THE PRODUCT-MATRIX MSR CODE CONSTRUCTION

In this section, we identify the speciﬁc make-up of the encoding matrix Ψ and the message matrix M that results in an [n, k, d] MSR code with β = 1. The construction applies to all parameters [n, k, d ≥ 2k−2].3 Since the code is required to be an MSR code with β = 1, it must possess the data-reconstruction and exact-regeneration properties required of a regenerating code, and in addition, have parameters {α, B} that satisfy equations (5) and (6). We begin by constructing an MSR code in the product-matrix format for d = 2k − 2 and will show in Section V-C how this can be very naturally extended to yield codes with d > 2k − 2.
At the MSR point with d = 2k − 2 we have

α = d−k+1 = k−1 ,

(21)

and hence

d = 2α .

(22)

Also,

B = kα = α(α + 1) .

(23)

We deﬁne the (d × α) message matrix M as

M = S1 ,

(24)

S2

where S1 and S2 are (α × α) symmetric matrices constructed such that the

α+1 2

entries in the upper-triangular

part of each of the two matrices are ﬁlled up by α+2 1 distinct message symbols. Thus, all the B = α(α + 1)

2In general, any matrix, all of whose submatrices are of full rank, will sufﬁce. 3As mentioned previously, it is impossible to construct linear MSR codes for the case of d < 2k − 3 when β = 1.

10

message symbols are contained in the two matrices S1 and S2. The entries in the strictly lower-triangular portion of the two matrices S1 and S2 are chosen so as to make the matrices S1 and S2 symmetric.
Next, we deﬁne the encoding matrix Ψ to be the (n × d) matrix given by

Ψ = Φ ΛΦ ,

(25)

where Φ is an (n × α) matrix and Λ is an (n × n) diagonal matrix. The elements of Ψ are chosen such that the following conditions are satisﬁed:

1) any d rows of Ψ are linearly independent, 2) any α rows of Φ are linearly independent and 3) the n diagonal elements of Λ are distinct.

The above requirements can be met, for example, by choosing Ψ to be a Vandermonde matrix with elements chosen carefully to satisfy the third condition. Then under our code-construction framework, the ith row of the (n × α) product matrix C = ΨM , contains the α code symbols stored by the ith node.

The two theorems below establish that the code presented is an [n, k, d] MSR code by establishing respectively, the exact-regeneration and data-reconstruction properties of the code.

Theorem 4 (MSR Exact-Regeneration): In the code presented, exact-regeneration of any failed node can be achieved by connecting to any d = 2k − 2 of the remaining (n − 1) nodes.

Proof: Let φt
f
failed node were

λf φtf be the row of Ψ corresponding to the failed node. Thus the α symbols stored in the φtf λf φtf M = φtf S1 + λf φtf S2 . (26)

The replacement for the failed node f connects to an arbitrary set {hj | j = 1, . . . , d} of d helper nodes. Upon
being contacted by the replacement node, the helper node hj computes the inner product ψthj M φf and passes on this value to the replacement node. Thus, in the present construction, the vector µf equals φf . The replacement node thus obtains the d symbols ΨrepairM φf from the d helper nodes, where

 ψt 

h1

 ψt 

Ψrepair

 =


h2
..

 .

.



ψt
hd

By construction, the (d × d) matrix Ψrepair is invertible. Thus the replacement node now has access to

M φf =

S1φf . S2φf

As S1 and S2 are symmetric matrices, the replacement node has thus acquired through transposition, both φtf S1 and φtf S2. Using this it can obtain
φtf S1 + λf φtf S2 , (27) which is precisely the data previously stored in the failed node.

Theorem 5 (MSR Data-Reconstruction): In the code presented, all the B message symbols can be recovered by connecting to any k nodes, i.e., the message symbols can be recovered through linear operations on the entries of any k rows of the code matrix C.

Proof: Let

ΨDC = ΦDC ΛDCΦDC

(28)

be the (k × d) submatrix of Ψ, containing the k rows of Ψ which correspond to the k nodes to which the data

11

collector connects. Hence the data collector obtains the symbols

ΨDCM = =

Φ Λ Φ S1

DC

DC DC S2

ΦDCS1 + ΛDCΦDCS2 .

(29)

The data collector can post-multiply this term with ΦTDC to obtain

ΦDCS1 + ΛDCΦDCS2 ΦTDC = ΦDCS1ΦTDC + ΛDCΦDCS2ΦTDC .

(30)

Next, let the matrices P and Q be deﬁned as

P = ΦDCS1ΦTDC ,

(31)

Q = ΦDCS2ΦTDC .

(32)

As S1 and S2 are symmetric, the same is true of the matrices P and Q. In terms of P and Q, the data collector

has access to the symbols of the matrix

P + ΛDCQ .

(33)

The (i, j)th, 1 ≤ i, j ≤ k, element of this matrix is

Pij + λiQij ,

(34)

while the (j, i)th element is given by

Pji + λj Qji

= Pij + λjQij ,

(35)

where equation (35) follows from the symmetry of P and Q. By construction, all the λi are distinct and hence using (34) and (35), the data collector can solve for the values of Pij, Qij for all i = j.

Consider ﬁrst the matrix P . Let ΦDC be given by

 φt 

1

ΦDC =  ...  .

(36)





φt
α+1

All the non-diagonal elements of P are known. The elements in the ith row (excluding the diagonal element) are given by
φtiS1 φ1 · · · φi−1 φi+1 · · · φα+1 . (37)

However, the matrix to the right is non-singular by construction and hence the data collector can obtain

φtiS1 | 1 ≤ i ≤ α + 1 . (38)
Selecting the ﬁrst α of these, the data collector has access to
 φt 
1
 ...  S1 . (39) φt
α
The matrix on the left is also non-singular by construction and hence the data collector can recover S1. Similarly, using the values of the non-diagonal elements of Q, the data collector can recover S2.
Remark 2: It is shown in [6], [14] that interference alignment is, in fact, a necessary ingredient of any minimum storage regenerating code. Interference alignment is also present in the product-matrix MSR code, and Appendix C brings out this connection.

12

A. An Example for the Product-Matrix MSR code
Let n = 6, k = 3, d = 4. Then α = d − k + 1 = 2 and B = kα = 6. Let us choose q = 13, so we are operating over F13. The matrices S1 and S2 are ﬁlled up by the 6 message symbols {ui}6i=1 as shown below:

S1 = u1 u2 , S2 = u4 u5 ,

(40)

u2 u3

u5 u6

so that the message matrix M is given by

u1 u2

M = u2 u3 .

(41)

u4 u5

u5 u6

We choose Ψ to be the (6 × 4) Vandermonde matrix over F13 given by

1 1 1 1 

1 2 4 8 





1 3 9 1



Ψ=

.

(42)

1 4 3 12





1 5 12 8 

1 6 10 8

Hence the (6 × 2) matrix Φ and the (6 × 6) diagonal matrix Λ are

1 1

1



1 2

4









1 3



9





Φ =  , Λ = 

.

(43)

1 4



3







1 5



 12 

16

10

Fig. 2 shows at the top, the (6 × 2) code matrix C = ΨM with entries expressed as functions of the message symbols {ui}. The rest of the ﬁgure explain how exact-regeneration of failed node 1 takes place. To regenerate node node 1, the helper nodes (nodes 2, 4, 5, 6 in the example), pass on their respective inner products ψtM [1 1]t for = 2, 4, 5, 6. The replacement node multiplies the symbols it receives with Ψ−rep1air, where
1 2 4 8  1 4 3 12 Ψrepair = 1 5 12 8  , (44)
1 6 10 8

and decodes S1ψ1 and S2ψ1:

S1ψ = u1 + u2 , S2ψ = u4 + u5 .

(45)

1 u2 + u3

1 u5 + u6

Finally, it processes S1ψ1 and S2ψ1 to obtain the data stored in the failed node as explained in the proof of Theorem 4 above.

B. Systematic Version of the Code
It was pointed out in Section III, that every exact-regenerating code has a systematic version and further, that the code could be made systematic through a process of message-symbol remapping. In the following, we make this more explicit in the context of the product-matrix MSR code.
Let Ψk be the (k × d) submatrix of Ψ, containing the k rows of Ψ corresponding to the k nodes which are chosen to be made systematic. The set of kα symbols stored in these k nodes are given by the elements of the

13

Node 1 Node 2 Node 3 Node 4 Node 5 Node 6

u1+ u2+ u4+ u5 u1+ 2u2+ 4u4+ 8u5 u1+ 3u2+ 9u4+ u5 u1+ 4u2+ 3u4+ 12u5 u1+ 5u2+ 12u4+ 8u5 u1+ 6u2+ 10u4+ 8u5

u2+ u3+ u5+ u6 u2+ 2u3+ 4u5+ 8u6 u2+ 3u3+ 9u5+ u6 u2+ 4u3+ 3u5+12 u6 u2+ 5u3+ 12u5+ 8u6 u2+ 6u3+ 10u5+ 8u6

<•,1>
<•,1> <•,1> <•,1>

-1 1248 1 4 3 12 1 5 12 8 1 6 10 8

u1+ u2 u2+ u3 u4+ u5 u5+ u6

Replacement Node 1

u1+ u2+ u4+ u5

u2+ u3+ u5+ u6

Fig. 2: An example for the MSR code construction: On failure of node 1, the replacement node downloads one
symbol each from nodes 2, 4, 5 and 6, using which node 1 is exactly regenerated. The notation < ., 1 > indicates an inner product of the stored symbols with the vector [1 1]t.

(k × α) matrix ΨkM . Let U be a (k × α) matrix containing the B = kα source symbols. We map

ΨkM = U ,

(46)

and solve for the entries of M in terms of the symbols in U . This is precisely the data-reconstruction process that takes place when a data collector connects to the k chosen nodes. Thus, the value of the entries in M can be obtained by following the procedure outlined in Theorem 5. Then, use this M to obtain the code C = ΨM . Clearly, in this representation, the k chosen nodes store the source symbols U in uncoded form.

C. Explicit MSR Product-Matrix Codes for d ≥ 2k − 2

In this section, we show how an MSR code for d = 2k − 2 can be used to obtain MSR codes for all d ≥ 2k − 2. Our starting point is the following theorem.
Theorem 6: An explicit [n = n + 1, k = k + 1, d = d + 1] exact-regenerating code C that achieves the cut-set bound at the MSR point can be used to construct an explicit [n, k, d] exact-regenerating code C that also achieves the cut-set bound at the MSR point. Furthermore if d = ak + b in code C , d = ak + b + (a − 1) in code C. If C is linear, so is C.
Proof: If both codes operate at the MSR point, then the number of message symbols B , B in the two cases must satisfy

B = k (d − k + 1) and B = k(d − k + 1)

respectively, so that

B −B = d−k+1=α .

We begin by constructing an MSR-point-optimal [n , k , d ] exact-regenerating code C in systematic form with the ﬁrst k rows containing the B message symbols. Let C be the subcode of C consisting of all code matrices in C whose top row is the all-zero row (i.e., the ﬁrst α of the B message symbols are all zero). Clearly, the subcode C is of size qB −α = qB. Note that C also possesses the same exact-regeneration and data-reconstruction properties as does the parent code C .
Let the code C now be formed from subcode C by puncturing (i.e., deleting) the ﬁrst row in each code matrix of C . Clearly, code C is also of size qB. We claim that C is an [n, k, d] exact-regenerating code. The data-reconstruction requirement requires that the B underlying message symbols be recoverable from the contents of any k rows of a code matrix C in C. But this follows since, by augmenting the matrices of code C by placing at the top an additional

14
all-zero row, we obtain a code matrix in C and code C has the property that the data can be recovered from any (k + 1) rows of each code matrix in C . A similar argument shows that code C also possesses the exact-regeneration property. Clearly if C is linear, so is code C. Finally, we have
d = ak + b ⇒ d + 1 = a(k + 1) + b
⇒ d = ak + b + (a − 1) .
By iterating the procedure in the proof of Theorem 6 above i times we obtain: Corollary 7: An explicit [n = n + i, k = k + i, d = d + i] exact-regenerating code C that achieves the cut-set bound at the MSR point can be used to construct an explicit [n, k, d] exact-regenerating code C that also achieves the cut-set bound at the MSR point. Furthermore if d = ak + b in code C , d = ak + b + i(a − 1) in code C. If C is linear, so is C. The corollary below follows from Corollary 7 above. Corollary 8: An MSR-point optimal exact-regenerating code C with parameters [n, k, d] for any 2k − 2 ≤ d ≤ n − 1 can be constructed from an MSR-point optimal exact-regenerating [n = n + i, k = k + i, d = d + i] code C with d = 2k − 2 and i = d − 2k + 2. If C is linear, so is C.
VI. ANALYSIS AND ADVANTAGES OF THE CODES
In this section, we detail the system-implementation advantages of the two code constructions presented in the paper.
A. Reduced Overhead In the product-matrix based constructions provided, the data stored in the ith storage node in the system is
completely determined by the single encoding vector ψi of length d. This is in contrast to a (B × α) generator matrix in a general code, comprising of the α global kernels of length B, each associated to a different symbol stored in the node. The encoding vector sufﬁces for the encoding, data-reconstruction, and regeneration purposes. The short length of the encoding vector reduces the overhead associated with the need for nodes to communicate their encoding vectors to the data collector during data-reconstruction, and to the replacement node during regeneration of a failed node.
Also, in both MBR and MSR code constructions, during regeneration of a failed node, the information passed on to the replacement node by a helper node is only a function of the index of the failed node. Thus, it is independent of the identity of the d − 1 other nodes that are participating in the regeneration. Once again, this reduces the communication overhead by requiring less information to be disseminated.
B. Applicability to Arbitrary n
In any real-world distributed storage application such as peer-to-peer storage, cloud storage, etc, it is natural that the number of nodes may go up or down: in due course of time, new nodes may be added to the system, or multiple nodes may fail or exit the system. For example, in peer-to-peer systems, individual nodes are free to come and go at will. The existing, explicit constructions of exact-regenerating codes [6], [7], [11]–[13] restrict the value of n to be d + 1. On the other hand, the codes presented in this paper are applicable for all values of n, and independent of the values of the parameters k and d. This gives a practical appeal to the code constructions presented here.
C. Complexity
1) Linearity and Field Size: The codes are linear over a chosen ﬁnite ﬁeld Fq, i.e., the source symbols are from this ﬁnite ﬁeld, and any stored symbol is a linear combination of these symbols over Fq. To arrive at the

15
product-matrix MBR code, any ﬁeld of size 2n or higher sufﬁces, and for the product-matrix MSR code, any ﬁeld of size n2 or higher sufﬁces. By cleverly choosing the matrix Ψ that meets the conditions governing the respective codes, it may often be possible to reduce the ﬁeld size even further.
2) Striping: The codes presented here divide the entire message into stripes of sizes corresponding to β = 1. Since each stripe is of minimal size, the complexity of encoding, data-reconstruction and regeneration operations, are considerably lowered, and so are the buffer sizes required at data collectors and replacement nodes. Furthermore, the operations that need to be performed on each stripe are identical and independent, and hence can be performed in parallel efﬁciently by a GPU/FPGA/multi-core processor.
3) Choice of the Encoding Matrix Ψ: The encoding matrix Ψ, for both the codes described, can be chosen as a Vandermonde matrix. Then each encoding vector can be described by just a scalar. Moreover with this choice, the encoding, data-reconstruction, and regeneration operations are, for the most part, identical to encoding or decoding of conventional Reed-Solomon codes.
VII. CONCLUSIONS
In this paper, an explicit MBR code for all values of the system parameters [n, k, d], and an explicit MSR code for all parameters satisfying [n, k, d ≥ 2k − 2] are presented. Both constructions are based on a common productmatrix framework introduced in this paper, and possess attributes that make them attractive from an implementation standpoint. To the best of our knowledge, these are the ﬁrst explicit constructions of exact-regenerating codes that allow n to take any value independent of the other parameters; this results in a host of desirable properties such as the ability to optimally handle multiple simultaneous, node failures as well as the ability of allowing the total number of storage nodes in the system to vary with time. Our results also prove that the MBR point on the storage-repair bandwidth tradeoff is achievable under the additional constraint of exact-regeneration for all values of the system parameters, and that the MSR point is achievable under exact-regeneration for all d ≥ 2k − 2.
REFERENCES
[1] D. A. Patterson, G. Gibson, and R. H. Katz, “A Case for Redundant Arrays of Inexpensive Disks (RAID),” in Proc. ACM SIGMOD international conference on management of data, Chicago, USA, Jun. 1988, pp. 109–116.
[2] S. Rhea, P. Eaton, D. Geels, H. Weatherspoon, B. Zhao, and J. Kubiatowicz, “Pond: The OceanStore Prototype,” in Proc. 2nd USENIX conference on File and Storage Technologies (FAST), 2003, pp. 1–14.
[3] R. Bhagwan, K. Tati, Y. C. Cheng, S. Savage, , and G. M. Voelker, “Total Recall: System Support for Automated Availability Management,” in Proc. 1st conference on Symposium on Networked Systems Design and Implementation (NSDI), 2004.
[4] A. G. Dimakis, P. B. Godfrey, M. Wainwright, and K. Ramchandran, “Network Coding for distributed storage systems,” in Proc. 26th IEEE International Conference on Computer Communications (INFOCOM), Anchorage, May 2007, pp. 2000–2008.
[5] Y. Wu, A. G. Dimakis, and K. Ramchandran, “Deterministic Regenerating codes for Distributed Storage,” in Proc. 45th Annual Allerton Conference on Control, Computing, and Communication, Urbana-Champaign, Sep. 2007.
[6] N. B. Shah, K. V. Rashmi, P. V. Kumar, and K. Ramchandran, “Explicit Codes Minimizing Repair Bandwidth for Distributed Storage,” in Proc. IEEE Information Theory Workshop (ITW), Cairo, Jan. 2010.
[7] C. Suh and K. Ramchandran, “Exact-Repair MDS Codes for Distributed Storage Using Interference Alignment,” in Proc. IEEE International Symposium on Information Theory (ISIT), Austin, Jun. 2010, pp. 161–165.
[8] Y. Wu, “Existence and Construction of Capacity-Achieving Network Codes for Distributed Storage,” in IEEE Journal on Selected Areas in Communications, vol. 28, no. 2, 2010, pp. 277–288.
[9] A. G. Dimakis, P. B. Godfrey, Y. Wu, M. Wainwright, and K. Ramchandran, “Network Coding for Distributed Storage Systems,” IEEE Transactions on Information Theory, vol. 56, no. 9, pp. 4539–4551, 2010.
[10] A. Duminuco and E. Biersack, “A Practical Study of Regenerating Codes for Peer-to-Peer Backup Systems,” in Proc. 29th IEEE International Conference on Distributed Computing Systems (ICDCS), Jun. 2009, pp. 376–384.
[11] Y. Wu and A. Dimakis, “Reducing Repair Trafﬁc for Erasure Coding-Based Storage via Interference Alignment,” in Proc. IEEE International Symposium on Information Theory (ISIT), Seoul, Jul. 2009, pp. 2276–2280.
[12] K. V. Rashmi, N. B. Shah, P. V. Kumar, and K. Ramchandran, “Explicit Construction of Optimal Exact Regenerating Codes for Distributed Storage,” in Proc. 47th Annual Allerton Conference on Communication, Control, and Computing, Urbana-Champaign, Sep. 2009, pp. 1243–1249.
[13] D. Cullina, A. G. Dimakis, and T. Ho, “Searching for Minimum Storage Regenerating Codes,” in Proc. 47th Annual Allerton Conference on Communication, Control, and Computing, Urbana-Champaign, Sep. 2009.
[14] N. B. Shah, K. V. Rashmi, P. V. Kumar, and K. Ramchandran, “Interference Alignment in Regenerating Codes for Distributed Storage: Necessity and Code Constructions,” IEEE Transactions on Information Theory, submitted for publication. [Online]. Available: arXiv:1005.1634v2[cs.IT]

16

[15] Y. Wu, “A Construction of Systematic MDS Codes with Minimum Repair Bandwidth,” IEEE Transactions on Information Theory, submitted for publication. [Online]. Available: arXiv:0910.2486[cs.IT]
[16] V. R. Cadambe, S. A. Jafar, and H. Maleki, “Distributed Data Storage with Minimum Storage Regenerating Codes - Exact and Functional Repair are Asymptotically Equally Efﬁcient.” [Online]. Available: arXiv:1004.4299[cs.IT]
[17] C. Suh and K. Ramchandran, “On the Existence of Optimal Exact-Repair MDS Codes for Distributed Storage.” [Online]. Available: arXiv:1004.4663[cs.IT]
[18] N. B. Shah, K. V. Rashmi, , and P. V. Kumar, “A Flexible Class of Regenerating Codes for Distributed Storage,” in Proc. IEEE International Symposium on Information Theory (ISIT), Austin, Jun. 2010, pp. 1943–1947.
[19] N. B. Shah, K. V. Rashmi, P. V. Kumar, and K. Ramchandran, “Distributed Storage Codes with Repair-by-Transfer and Non-achievability of Interior Points on the Storage-Bandwidth Tradeoff,” IEEE Transactions on Information Theory, submitted for publication. [Online]. Available: arXiv:1011.2361[cs.IT]
[20] D. S. Bernstein, Matrix mathematics: Theory, facts, and formulas with application to linear systems theory. Princeton University Press, 2005.
[21] M. Maddah-Ali, A. Motahari, and A. Khandani, “Communication over MIMO X Channels: Interference Alignment, Decomposition, and Performance Analysis,” IEEE Transactions on Information Theory, vol. 54, no. 8, pp. 3457–3470, 2008.
[22] V. Cadambe and S. Jafar, “Interference Alignment and Spatial Degrees of Freedom for the k User Interference Channel,” IEEE Transactions on Information Theory, vol. 54, no. 8, pp. 3425–3441, Aug. 2008.

APPENDIX A DESCRIPTION OF A PREVIOUSLY CONSTRUCTED MSR CODE IN THE PRODUCT-MATRIX FRAMEWORK

A code structure that guarantees exact-regeneration of just the systematic nodes is provided in [6], for the MSR point with parameters [n = d+1, k, d ≥ 2k−1]. Subsequently, it was shown in [7] that for this set of parameters, the code introduced in [6] for exact-regeneration of only the systematic nodes can also be used for exact-regeneration of the non-systematic (parity) nodes, provided repair construction schemes are appropriately designed. Such an explicit repair scheme is indeed designed and presented in [7]. In this section, we provide a simpler description of this code in the product-matrix framework.
As in [6], [7], we begin with the case d = 2k − 1, since the code as well as both data-reconstruction and exact-regeneration algorithms can be extended to larger values of d by making use of Corollary 8.
At the MSR point, with d = n − 1 = 2k − 1, we have from equations (5) and (6) that

α = d−k+1 = k ,

(47)

B = kα = k2 .

(48)

Let S be a (k × k) matrix whose entries are precisely the B message symbols {ui}Bi=1 and let M be the (2k × k) message matrix4 given by:

S

M = St .

(49)

Next, let Φ be a (k × k) Cauchy matrix over Fq and ρ a scalar chosen such that

ρ = 0, ρ2 = 1 .

(50)

Let Ψ be the (n × 2k) encoding matrix given by Ψ = I 0 . (51) Φ ρΦ

The code constructed in [6], [7] can be veriﬁed to have an alternate description as the collection of code matrices

of the form

S

C = ΨM = Φ(S + ρSt) .

(52)

Note that the ﬁrst k nodes store the message symbols in uncoded form and hence correspond to the systematic nodes. A simple description of the exact-regeneration and data-reconstruction properties of the code is presented below.

4Note that the constructions presented in Sections IV and V employ a (d × α) matrix M as the message matrix, whereas the dimension of M in the present construction is ((d + 1) × α).

17

Theorem 9 (Exact-Regeneration): In the code presented, exact-regeneration of any failed node can be achieved by connecting to the remaining n − 1 nodes.

Proof: In this construction, the vector µf used in the exact-regeneration of a failed node f is composed of the ﬁrst k = α symbols of ψf .

a) Exact-regeneration of systematic nodes: Consider regeneration of the ith systematic node. The k symbols

thus desired by the replacement node are etiS. The replacement node obtains the following n − 1 symbols from the

remaining nodes:

I˜ 0 S e =

I˜Sei

.

(53)

Φ ρΦ St i Φ(S + ρSt)ei

where I˜ is a ((k − 1) × k) matrix which is the identity matrix with ith row removed. Since Φ is full rank by construction, the replacement node has access to

(S + ρSt)ei

= ρetiS + etiSt .

(54)

From (53) and (54), we see that the replacement node has access to

 I˜ 0  S

 Φ ρΦ St ei .

(55)

ρeti eti

Since ρ = 1, the (2k × 2k) matrix on the left is non-singular. This allows the replacement node to recover the symbols Stei, which are precisely the set of symbols etiS desired.
b) Exact-regeneration of non-systematic nodes: Let φt be the row of Φ corresponding to the failed node.
f
Then the k symbols stored in the failed node are φt (S + ρSt). The replacement node requests and obtains the
f
following n − 1 symbols from the remaining nodes:

I

0S

Φk−1 ρΦk−1 St φf ,

(56)

where Φk−1 is the submatrix of Φ containing the k − 1 rows corresponding to the remaining non-systematic nodes. This gives the replacement node access to Sφf and therefore to

(Sφ )tφ = φt Stφ .

(57)

ff

ff

Hence the replacement node has access to

I

0

Φk−1 ρΦk−1 S φ .

(58)

 0t

φt  St f

f

The matrix on the left is easily veriﬁed to be non-singular and thus the replacement node acquires Sφf and Stφf

individually from which it can derive the desired vector (φt S + ρφt St).

f

f

Theorem 10 (Data-Reconstruction): In the code presented, all the B message symbols can be recovered by connecting to any k nodes, i.e., the message symbols can be recovered through linear operations on the entries of any k rows of the matrix C.

Proof: We ﬁrst introduce the following notation to denote submatrices of a matrix. If A is an (m1 × m2) matrix and P, Q are arbitrary subsets of {1, . . . , m1} and {1, . . . , m2} respectively, we will use A(P,Q) to denote the submatrix of A containing only the rows and columns respectively speciﬁed by the indices in P and Q. For
the cases when either P = {1, . . . , m1} or Q = {1, . . . , m2}, we will simply indicate this as ‘all’.

Let P = {n1, . . . , ni} and Q = {m1, . . . , m(k−i)} be the systematic and non-systematic nodes respectively to which the data collector connects. Let T = {1, . . . , k}\P , i.e., the systematic nodes to which the data collector

18

does not connect. Then the data collector is able to access the kα symbols

S(P,all)

.

(59)

Φ(Q,all)(S + ρSt)

Thus the data collector has access to the i rows of S indexed by the entries of P and consequently, has access to the corresponding columns of St as well.

Consider the i columns of Φ(Q,all)(S + ρSt) indexed by P . Since the entries of these columns in St are known, the data collector has access to Φ(Q,all)S(all,P ) . Now since the i rows of S indexed through P are also known, the data collector has thus access to the product

Φ(Q,T )S(T,P ) .

(60)

Now as Φ(Q,T ) is non-singular, being a (k − |P |, k − |P |) sub-matrix of a Cauchy matrix, the data collector can recover S(T,P ). In this way, the data collector has recovered all the entries in the rows of S indexed by P as well as all the entries in the columns of S indexed by P . Clearly, the same statement holds when S is replaced by St.
Thus the data collector has access to the product:

Φ(T,T )(S + ρSt)(T,T ) .

(61)

Again Φ(T,T ) being a sub-matrix of a Cauchy matrix is of full rank and enables the data collector to recover (S + ρSt)(T,T ). It is easy to see that from the diagonal elements of this matrix, all the diagonal elements of S(T,T )
can be obtained. The non-diagonal elements are however of the form Slj+ρSjl and Sjl+ρSlj for l ∈ T, j ∈ T, l = j. As ρ2 = 1, all the non-diagonal elements of S(T,T ) can also be decoded. In this way, the data collector has recovered
all the B entries of S.

APPENDIX B EQUIVALENT CODES AND CONVERSION OF NON-SYSTEMATIC CODES TO SYSTEMATIC

In this section, we deﬁne the notion of ‘equivalent codes’, and show that any exact-regenerating code is equivalent to a systematic exact-regenerating code.
Given any linear exact-regenerating code, one can express each of the nα symbols stored in the nodes as a linear combination of the B message symbols {ui}Bi=1. Let {cij|1 ≤ i ≤ n, 1 ≤ j ≤ α} denote the jth symbol stored in the ith node. Thus we have the relation:

[u1 u2 · · · uB][G1 G2 · · · Gn] = [c11 · · · c1α|c21 · · · c2α| · · · · · · |cn1 · · · cnα] ,

(62)

where the (B × nα) block generator matrix G = [G1 G2 · · · Gn] is composed of the n component generator sub-matrices
Gi = gi1 gi2 · · · giα ,
each of size (B × α), and associated to a distinct node.5 Let Wi denote the column-space of Gi. A little thought will show that a distributed storage code is an exact-regenerating code iff

1) for every subset of k nodes {ij | 1 ≤ j ≤ k},

dim(Wi1 + Wi2 + · · · + Wik ) = B ,

and

2)

for

every

subset

of

(d + 1)

nodes

{ij

|

1

≤

j

≤

(d + 1)},

the

subspaces

{

W

i

j

}

d j=1

contain

a

vector

wj

such

that

Wid+1 ⊆ span wi1 , wi2 , · · · , wid .

We can thus deﬁne two exact-regenerating codes to be equivalent if the associated subspaces {Wi}ni=1 are identical. It is also clear that two codes are equivalent if one can be obtained from the other through a non-singular transformation

5In the terminology of network coding, the (B × 1) column vector g is termed the jth global kernel associated to the ith node. ij

19

of the message symbols and the symbols stored within the nodes. With these two observations, it follows that two codes with generator matrices having the following relation are equivalent:

 Y1





Y2



G, and XG  

...

, 





Yn

where the (B × B) pre-multiplication matrix X, and the (nα × nα) post-multiplication block diagonal matrix comprising of the (α × α) matrices {Yi}ni=1, are non-singular. Clearly, equivalent codes have identical datareconstruction and regeneration properties.

Systematic Version of Exact-Regenerating Codes: It also follows that any exact-regenerating code is equivalent to a systematic, exact-regenerating code. To see this, suppose the set of k nodes to be systematic are the ﬁrst k nodes. Let
{g˜a1, g˜a2, · · · , g˜aB } ⊆ {gij | 1 ≤ i ≤ k, 1 ≤ j ≤ α}
denote a set of B linearly independent column vectors drawn from the generator matrices of the ﬁrst k nodes [G1 · · · Gk]. That such a subset is guaranteed to exist follows from the data-reconstruction property of a regenerating code. Let G˜ be the (B × B) invertible matrix

G˜ = g˜a1 g˜a2 · · · g˜aB .

Then we have the relation:

[u1 u2 · · · uB]G˜ = [c˜a1 c˜a2 · · · c˜aB ] , (63) where {c˜ai}Bi=1 is the corresponding set of code symbols. It follows that if we wish to encode in such a way that the code is systematic with respect to code symbols {c˜ai}Bi=1, the input to be “fed” to the generator matrix G is
[u1 u2 · · · uB]G˜−1 .

APPENDIX C INTERFERENCE ALIGNMENT IN THE PRODUCT-MATRIX MSR CODE

The concept of interference alignment was introduced in [21], [22] in the context of wireless communication. This concept was subsequently used to construct regenerating codes in [6], [7], [11], [14]. Furthermore, [6], [14] showed that interference alignment is in fact, a necessary ingredient of any linear MSR code. Since the product-matrix MSR construction provided in the present paper does not explicitly use the concept of interference alignment, a natural question that arises is how does interference alignment manifest itself in this code. We answer this question in the present section.

Consider repair of a failed node (say, node f ) in a distributed storage system employing an MSR code, and let nodes {1, . . . , d} be the set of d helper nodes. Recall that (from equation (3)), at the MSR point we have B = kα. Further, since all the B message symbols should be recoverable from any subset of k nodes, it must be that any subset of k nodes does not store any redundant information. Let ci, 1 ≤ i ≤ n, be an α-length vector denoting the α symbols stored in node i. Then, from the above argument, it is clear that any symbol in the system can be written as a linear combination of the B symbols in {cf , c1, . . . , c(k−1)}.

Let θ , k ≤ ≤ d, denote the symbol passed by node to assist in the repair of node f . Then we can write,

k−1

θ = ctf v ,f + cti v ,i

(64)

i=1

for some vectors v ,i and v ,f each of length α. The symbols in {cf , c1, . . . , c(k−1)} have no redundancy among themselves. Thus, the components comprising of {c1, . . . , c(k−1)} are undesired and hence are termed as interference components, and the component comprising of cf is termed the desired component.

20

It is shown in [6], [14] that for any MSR code, it must be that for every i ∈ {1, . . . , k − 1}, the set of vectors

v ,i|k ≤ ≤ d

(65)

are aligned (i.e., are scalar multiples of each other).

The following lemma considers the repair scenario discussed above to illustrate how interference alignment arises in the product-matrix MSR code presented in Section V.

Lemma 11: For every helper node , k ≤ ≤ d, there exist scalars {a( ,i)|1 ≤ i ≤ k − 1} and an α-length vector b = [b ,1 · · · b ,α]t such that

k−1
ψtM φf = ψtf M b + a ,iψtiM φf . (66)
i=1

Proof: Re-writing the symbols passed by the helper node j (1 ≤ j ≤ d),

ψtjM φf = φtjS1 + λjφtjS2 φf (67)

= φtf S1 + λjφtf S2 φj (68)

= φtf S1 + λf φtf S2 φj + (λj − λf )φtf S2φj (69) = ψtf M φj + (λj − λf )φtf S2φj , (70)

where equation (68) follows from the symmetry of matrices S1 and S2. By construction, the values of the scalars {λj | 1 ≤ j ≤ n} are distinct, which allows us to write

φtf S2φj = (λj − λf )−1(ψtjM φf − ψtf M φj) . (71)

Also, since the (k − 1 =)α-length vectors {φi | 1 ≤ i ≤ k − 1} are linearly independent, for k ≤ scalars {a˜ ,i | 1 ≤ i ≤ k − 1} such that
k−1
φ = a˜ ,iφi .
i=1

≤ d, there exist (72)

From equations (70), (71) and (72), for any ∈ {k, . . . , d}, we can write

ψtM φf = ψtf M φ + (λ − λf )φtf S2φ (73)

k−1
= ψtf M φ + (λ − λf ) a˜ ,iφtf S2φi (74)
i=1

k−1

k−1

= ψtf M φ − (λ − λf ) a˜ ,i(λi − λf )−1φi +

a˜ ,i(λ − λf )(λi − λf )−1 (ψtiM φf ) (75)

i=1

i=1

where equation (74) follows from (72), and equation (75) follows from (71).

